commit bee05c9d58a34ec5886faf3b56ecaa56355d94bf
Author: Florian Weimer <fweimer@redhat.com>
Date:   Wed Apr 19 14:29:11 2017 +0200

    resolv: Replace __builtin_expect with __glibc_unlikely/__glibc_likely

diff --git a/resolv/gai_suspend.c b/resolv/gai_suspend.c
index 3ee6a08b4fd9f2fb..a86bd4360d6b03e8 100644
--- a/resolv/gai_suspend.c
+++ b/resolv/gai_suspend.c
@@ -141,7 +141,7 @@ gai_suspend (const struct gaicb *const list[], int ent,
 	  /* An error occurred.  Possibly it's EINTR.  We have to translate
 	     the timeout error report of `pthread_cond_timedwait' to the
 	     form expected from `gai_suspend'.  */
-	  if (__builtin_expect (result, ETIMEDOUT) == ETIMEDOUT)
+	  if (__glibc_likely (result == ETIMEDOUT))
 	    result = EAI_AGAIN;
 	  else if (result == EINTR)
 	    result = EAI_INTR;
diff --git a/resolv/nss_dns/dns-host.c b/resolv/nss_dns/dns-host.c
index 705b3c9c078c41bf..7099d093f357e16c 100644
--- a/resolv/nss_dns/dns-host.c
+++ b/resolv/nss_dns/dns-host.c
@@ -619,7 +619,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
   ancount = ntohs (hp->ancount);
   qdcount = ntohs (hp->qdcount);
   cp = answer->buf + HFIXEDSZ;
-  if (__builtin_expect (qdcount, 1) != 1)
+  if (__glibc_unlikely (qdcount != 1))
     {
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
@@ -633,7 +633,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 			packtmp, sizeof packtmp);
   if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
     {
-      if (__builtin_expect (errno, 0) == EMSGSIZE)
+      if (__glibc_unlikely (errno) == EMSGSIZE)
 	goto too_small;
 
       n = -1;
@@ -642,13 +642,19 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
   if (n > 0 && bp[0] == '.')
     bp[0] = '\0';
 
-  if (__builtin_expect (n < 0 || ((*name_ok) (bp) == 0 && (errno = EBADMSG)),
-			0))
+  if (__glibc_unlikely (n < 0))
     {
       *errnop = errno;
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
     }
+  if (__glibc_unlikely (name_ok (bp) == 0))
+    {
+      errno = EBADMSG;
+      *errnop = EBADMSG;
+      *h_errnop = NO_RECOVERY;
+      return NSS_STATUS_UNAVAIL;
+    }
   cp += n + QFIXEDSZ;
 
   if (qtype == T_A || qtype == T_AAAA)
@@ -690,7 +696,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 			    packtmp, sizeof packtmp);
       if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
 	{
-	  if (__builtin_expect (errno, 0) == EMSGSIZE)
+	  if (__glibc_unlikely (errno == EMSGSIZE))
 	    goto too_small;
 
 	  n = -1;
@@ -750,7 +756,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 	  /* Store alias.  */
 	  *ap++ = bp;
 	  n = strlen (bp) + 1;		/* For the \0.  */
-	  if (__builtin_expect (n, 0) >= MAXHOSTNAMELEN)
+	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
 	    {
 	      ++had_error;
 	      continue;
@@ -761,7 +767,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 	  n = strlen (tbuf) + 1;	/* For the \0.  */
 	  if (__glibc_unlikely (n > linebuflen))
 	    goto too_small;
-	  if (__builtin_expect (n, 0) >= MAXHOSTNAMELEN)
+	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
 	    {
 	      ++had_error;
 	      continue;
@@ -789,7 +795,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 	  n = strlen (tbuf) + 1;   /* For the \0.  */
 	  if (__glibc_unlikely (n > linebuflen))
 	    goto too_small;
-	  if (__builtin_expect (n, 0) >= MAXHOSTNAMELEN)
+	  if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
 	    {
 	      ++had_error;
 	      continue;
@@ -821,7 +827,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 				packtmp, sizeof packtmp);
 	  if (n != -1 && __ns_name_ntop (packtmp, bp, linebuflen) == -1)
 	    {
-	      if (__builtin_expect (errno, 0) == EMSGSIZE)
+	      if (__glibc_unlikely (errno == EMSGSIZE))
 		goto too_small;
 
 	      n = -1;
@@ -854,7 +860,7 @@ getanswer_r (const querybuf *answer, int anslen, const char *qname, int qtype,
 	  return NSS_STATUS_SUCCESS;
 	case T_A:
 	case T_AAAA:
-	  if (__builtin_expect (strcasecmp (result->h_name, bp), 0) != 0)
+	  if (__glibc_unlikely (strcasecmp (result->h_name, bp) != 0))
 	    {
 	      cp += n;
 	      continue;			/* XXX - had_error++ ? */
@@ -975,7 +981,7 @@ gaih_getanswer_slice (const querybuf *answer, int anslen, const char *qname,
      it later.  */
   if (n != -1 && __ns_name_ntop (packtmp, buffer, buflen) == -1)
     {
-      if (__builtin_expect (errno, 0) == EMSGSIZE)
+      if (__glibc_unlikely (errno == EMSGSIZE))
 	{
 	too_small:
 	  *errnop = ERANGE;
@@ -986,13 +992,19 @@ gaih_getanswer_slice (const querybuf *answer, int anslen, const char *qname,
       n = -1;
     }
 
-  if (__builtin_expect (n < 0 || (res_hnok (buffer) == 0
-				  && (errno = EBADMSG)), 0))
+  if (__glibc_unlikely (n < 0))
     {
       *errnop = errno;
       *h_errnop = NO_RECOVERY;
       return NSS_STATUS_UNAVAIL;
     }
+  if (__glibc_unlikely (res_hnok (buffer) == 0))
+    {
+      errno = EBADMSG;
+      *errnop = EBADMSG;
+      *h_errnop = NO_RECOVERY;
+      return NSS_STATUS_UNAVAIL;
+    }
   cp += n + QFIXEDSZ;
 
   int haveanswer = 0;
@@ -1014,7 +1026,7 @@ gaih_getanswer_slice (const querybuf *answer, int anslen, const char *qname,
       if (n != -1 &&
 	  (h_namelen = __ns_name_ntop (packtmp, buffer, buflen)) == -1)
 	{
-	  if (__builtin_expect (errno, 0) == EMSGSIZE)
+	  if (__glibc_unlikely (errno == EMSGSIZE))
 	    goto too_small;
 
 	  n = -1;
@@ -1128,8 +1140,7 @@ gaih_getanswer_slice (const querybuf *answer, int anslen, const char *qname,
 	  buffer += pad;
 	  buflen = buflen > pad ? buflen - pad : 0;
 
-	  if (__builtin_expect (buflen < sizeof (struct gaih_addrtuple),
-				0))
+	  if (__glibc_unlikely (buflen < sizeof (struct gaih_addrtuple)))
 	    goto too_small;
 
 	  *pat = (struct gaih_addrtuple *) buffer;
diff --git a/resolv/res_init.c b/resolv/res_init.c
index 923724f86d6a0edc..23676e994dd58be7 100644
--- a/resolv/res_init.c
+++ b/resolv/res_init.c
@@ -356,7 +356,7 @@ __res_vinit(res_state statp, int preinit) {
 	    statp->nsort = nsort;
 	    (void) fclose(fp);
 	}
-	if (__builtin_expect(statp->nscount == 0, 0)) {
+	if (__glibc_unlikely (statp->nscount == 0)) {
 	    statp->nsaddr.sin_addr = __inet_makeaddr(IN_LOOPBACKNET, 1);
 	    statp->nsaddr.sin_family = AF_INET;
 	    statp->nsaddr.sin_port = htons(NAMESERVER_PORT);
diff --git a/resolv/res_query.c b/resolv/res_query.c
index ec65bab04153c2ff..0ca3a650282ec7f0 100644
--- a/resolv/res_query.c
+++ b/resolv/res_query.c
@@ -199,7 +199,7 @@ __libc_res_nquery(res_state statp,
 	    nquery1 = n;
 	  }
 
-	if (__builtin_expect (n <= 0, 0) && !use_malloc) {
+	if (__glibc_unlikely (n <= 0) && !use_malloc) {
 		/* Retry just in case res_nmkquery failed because of too
 		   short buffer.  Shouldn't happen.  */
 		bufsize = (type == T_QUERY_A_AND_AAAA ? 2 : 1) * MAXPACKET;
diff --git a/resolv/res_send.c b/resolv/res_send.c
index 440da90a0b381b84..1835ec7ee507d215 100644
--- a/resolv/res_send.c
+++ b/resolv/res_send.c
@@ -424,7 +424,7 @@ __libc_res_nsend(res_state statp, const u_char *buf, int buflen,
 	 * Some resolvers want to even out the load on their nameservers.
 	 * Note that RES_BLAST overrides RES_ROTATE.
 	 */
-	if (__builtin_expect ((statp->options & RES_ROTATE) != 0, 0)) {
+	if (__glibc_unlikely ((statp->options & RES_ROTATE) != 0)) {
 		struct sockaddr_in ina;
 		struct sockaddr_in6 *inp;
 		int lastns = statp->nscount - 1;
