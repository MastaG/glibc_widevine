--- glibc-20070515T2025/ChangeLog	15 May 2007 20:24:57 -0000	1.10641
+++ glibc-20070515T2025-fedora/ChangeLog	8 Jul 2007 10:08:23 -0000	1.8782.2.258
@@ -1,3 +1,237 @@
+2007-07-07  Ulrich Drepper  <drepper@redhat.com>
+
+	[BZ #4745]
+	* stdio-common/vfscanf.c (_IO_vfscanf): Add additional test for EOF
+	in loop to look for conversion specifier to avoid testing of
+	wrong errno value.
+	* stdio-common/Makefile (tests): Add bug18, bug18a, bug19, bug19a.
+	* stdio-common/bug18.c: New file.
+	* stdio-common/bug18a.c: New file.
+	* stdio-common/bug19.c: New file.
+	* stdio-common/bug19a.c: New file.
+
+2007-06-06  Jakub Jelinek  <jakub@redhat.com>
+
+	[BZ #4586]
+	* sysdeps/i386/ldbl2mpn.c (__mpn_extract_long_double): Treat
+	pseudo-zeros as zero.
+	* sysdeps/x86_64/ldbl2mpn.c: New file.
+	* sysdeps/ia64/ldbl2mpn.c: New file.
+
+2007-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/dl-sysdep.c (_dl_important_hwcaps): Add integer overflow check.
+	* elf/dl-minimal.c (__libc_memalign): Likewise.  Handle malloc (0).
+	Return NULL if mmap failed instead of asserting it does not.
+	(calloc): Check for integer overflow.
+
+	* elf/dl-minimal.c (__strtoul_internal): Fix parsing of numbers bigger
+	than LONG_MAX / 10.
+
+2007-07-03  Jakub Jelinek  <jakub@redhat.com>
+
+	[BZ #4702]
+	* nis/nss-default.c: Include errno.h.
+	(init): Preserve errno.
+
+2007-06-19  Ulrich Drepper  <drepper@redhat.com>
+
+	* sysdeps/generic/ldsodefs.h (rtld_global): Reorder some elements
+	to fill in holes
+	(rtld_global_ro): Likewise.
+
+2007-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/dl-addr.c (_dl_addr): Skip PT_LOAD checking if l_contiguous.
+	Move PT_LOAD checking to...
+	(_dl_addr_inside_object): ... here, new function.
+	* elf/dl-sym.c (do_sym): If not l_contiguous,
+	call _dl_addr_inside_object.
+	* elf/dl-iteratephdr.c (__dl_iterate_phdr): Likewise.
+	* dlfcn/dlinfo.c (dlinfo_doit): Likewise.
+	* elf/dl-open.c (dl_open_worker): Likewise.
+	(_dl_addr_inside_object): New function if IS_IN_rtld.
+	* elf/dl-load.c (_dl_map_object_from_fd): Set l_contiguous if no
+	holes are present or are PROT_NONE protected.
+	* include/link.h (struct link_map): Add l_contiguous field.
+	* sysdeps/generic/ldsodefs.h (_dl_addr_inside_object): New prototype.
+
+2007-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/rtld.c (dl_main): Don't call init_tls more than once.
+
+2007-06-19  Ulrich Drepper  <drepper@redhat.com>
+
+	* elf/dl-close.c (free_mem): Free _dl_scope_free_list.
+
+2007-06-13  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/link.h: Don't include rtld-lowlevel.h.
+	(struct link_map): Remove l_scope_lock.
+	* sysdeps/generic/ldsodefs.h: Don't include rtld-lowlevel.h.
+	(_dl_scope_free_list): New field (variable) in _rtld_global.
+	(DL_LOOKUP_SCOPE_LOCK): Remove.
+	(_dl_scope_free): New prototype.
+	* elf/dl-runtime.c (_dl_fixup): Don't use __rtld_mrlock_*lock.
+	Don't pass DL_LOOKUP_SCOPE_LOCK to _dl_lookup_symbol_x.
+	(_dl_profile_fixup): Likewise.
+	* elf/dl-sym.c (do_sym): Likewise.  Use wrapped _dl_lookup_symbol_x
+	whenever !RTLD_SINGLE_THREAD_P, use THREAD_GSCOPE_SET_FLAG and
+	THREAD_GSCOPE_RESET_FLAG around it.
+	* elf/dl-close.c (_dl_close_worker): Don't use
+	__rtld_mrlock_{change,done}.  Call _dl_scope_free on the old
+	scope.  Make sure THREAD_GSCOPE_WAIT () happens if any old
+	scopes were queued or if l_scope_mem has been abandoned.
+	* elf/dl-open.c (_dl_scope_free): New function.
+	(dl_open_worker): Use it.  Don't use __rtld_mrlock_{change,done}.
+	* elf/dl-support.c (_dl_scope_free_list): New variable.
+	* elf/dl-lookup.c (add_dependency): Remove flags argument.
+	Remove DL_LOOKUP_SCOPE_LOCK handling.
+	(_dl_lookup_symbol_x): Adjust caller.  Remove DL_LOOKUP_SCOPE_LOCK
+	handling.
+	* elf/dl-object.c (_dl_new_object): Don't use
+	__rtld_mrlock_initialize.
+
+2007-06-09  Ulrich Drepper  <drepper@redhat.com>
+
+	* elf/do-lookup.h (do_lookup_x): Read r_nlist before r_list and
+	make sure gcc doesn't mess around with this.
+
+2007-06-08  Ulrich Drepper  <drepper@redhat.com>
+
+	* elf/dl-lookup.c (_dl_lookup_symbol_x): Remove use of r_nlist.
+
+2007-06-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/dl-close.c (_dl_close_worker): Remove all to be removed
+	libraries from the global scope at once and call THREAD_GSCOPE_WAIT
+
+2007-05-18  Ulrich Drepper  <drepper@redhat.com>
+
+	* elf/dl-close.c (_dl_close_worker): When removing object from
+	global scope, wait for all lookups to finish afterwards.
+	* elf/dl-open.c (add_to_global): When global scope array must
+	grow, allocate a new one and free old array only after all
+	lookups finish.
+	* elf/dl-runtime.c (_dl_fixup): Protect using global scope.
+	(_dl_lookup_symbol_x): Likewise.
+	* elf/dl-support.c: Define _dl_wait_lookup_done.
+	* sysdeps/generic/ldsodefs.h (struct rtld_global): Add
+	_dl_wait_lookup_done.
+
+2007-06-05  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/ieee754/ldbl-128ibm/mpn2ldbl.c
+	(__mpn_construct_long_double): Fix conversion where result ought
+	to be smaller than __LDBL_MIN__, or the low double should be
+	denormal.  Fix decision where to negate low double - honor round
+	to even rules.
+	* stdio-common/tst-sprintf2.c: Include string.h.
+	(COMPARE_LDBL): Define.
+	(TEST): Also test whether a string hexadecimal float representation
+	can be parsed back to the number.
+	(main): Add a couple of further tests.
+
+2007-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/ieee754/ldbl-128ibm/printf_fphex.c
+	(PRINT_FPHEX_LONG_DOUBLE): Fix printing numbers where lower double
+	is non-zero, but smaller than 2 * __DBL_MIN__.
+	* stdio-common/tst-sprintf2.c: New test.
+	* stdio-common/Makefile (tests): Add tst-sprintf2.
+
+2007-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/ieee754/ldbl-128ibm/s_nextafterl.c (nextafterl): Remove
+	unused ily variable.  Fix nextafterl on +-__LDBL_MAX__ and +-Inf.
+	Remove unreachable code at the end.
+
+2007-06-01  Steven Munroe  <sjmunroe@us.ibm.com>
+
+	* sysdeps/ieee754/ldbl-128ibm/s_fpclassifyl.c: Correct description of
+	ldbl-128ibm in comment.
+	(fpclassifyl): Correct classification of denormals.
+	* sysdeps/ieee754/ldbl-128ibm/s_nextafterl.c (nextafterl): Correct
+	return value for MIN denormal. Rewrite using long double math too
+	correctly handle denormals and canonicalize the results.
+
+2007-05-29  Ulrich Drepper  <drepper@redhat.com>
+
+	* nscd/nscd_helper.c (get_mapping): Handle short replies instead
+	of crashing.  When this is the case or if the reply is malformed,
+	don't try to close the new file descriptor since it does not
+	exist.
+	Patch in part by Guillaume Chazarain <guichaz@yahoo.fr>.
+
+2007-05-21  Ulrich Drepper  <drepper@redhat.com>
+
+	* sysdeps/x86_64/cacheinfo.c (init_cacheinfo): Pass correct value
+	as second parameter to handle_intel.
+
+	* sysdeps/unix/sysv/linux/x86_64/sysconf.c: Move cache information
+	handling to ...
+	* sysdeps/x86_64/cacheinfo.c: ... here.  New file.
+	* sysdeps/x86_64/Makefile [subdir=string] (sysdep_routines): Add
+	cacheinfo.
+	* sysdeps/x86_64/memcpy.S: Complete rewrite.
+	* sysdeps/x86_64/mempcpy.S: Adjust appropriately.
+	Patch by Evandro Menezes <evandro.menezes@amd.com>.
+
+2007-05-21  Ulrich Drepper  <drepper@redhat.com>
+
+	* sysdeps/unix/sysv/linux/i386/epoll_pwait.S: New file.
+
+2007-05-21  Jakub Jelinek  <jakub@redhat.com>
+
+	[BZ #4525]
+	* sysdeps/unix/sysv/linux/Makefile (sysdep_routines): Add epoll_pwait.
+	* sysdeps/unix/sysv/linux/epoll_pwait.c: New file.
+	* sysdeps/unix/sysv/linux/syscalls.list (epoll_pwait): Remove.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/epoll.h (epoll_pwait): Declare.
+
+	[BZ #4514]
+	* stdio-common/vfprintf.c (vfprintf): Don't shadow workstart variable,
+	reinitialize workend at the start of each do_positional format spec
+	loop, free workstart before do_positional loops.
+	(printf_unknown): Fix size of work_buffer.
+	* stdio-common/tst-sprintf.c (main): Add 3 new testcases.
+
+	* malloc/hooks.c (MALLOC_STATE_VERSION): Bump.
+	(public_sET_STATe): If ms->version < 3, put all chunks into
+	unsorted chunks and clear {fd,bk}_nextsize fields of largebin
+	chunks.
+
+	* malloc/malloc.c [MALLOC_DEBUG]: Revert 2007-05-13 changes.
+	* malloc/hooks.c: Likewise.
+	* malloc/arena.c: Likewise.
+	* malloc/malloc.c (do_check_malloc_state): Don't assert
+	n_mmaps is not greater than n_mmaps_max.  This removes the need
+	for the previous change.
+
+	* malloc/Makefile (CFLAGS-malloc.c): Revert accidental
+	2007-05-07 commit.
+
+2007-05-18  Ulrich Drepper  <drepper@redhat.com>
+
+	* malloc/malloc.c (do_check_chunk): Correct check for mmaped block
+	not overlapping with arena.
+
+	* malloc/mcheck.c (reallochook): If size==0, free the block.
+
+	* rt/tst-shm.c: Use fstat64 instead of fstat.
+
+	* sysdeps/unix/sysv/linux/i386/sync_file_range.S: Fix case where
+	__NR_sync_file_range is not defined.
+
+2007-05-17  Ulrich Drepper  <drepper@redhat.com>
+
+	Dummy files to prevent stub versions from being used.
+	* sysdeps/x86_64/fpu/k_cosl.c: New file.
+	* sysdeps/x86_64/fpu/k_rem_pio2l.c: New file.
+	* sysdeps/x86_64/fpu/k_sinl.c: New file.
+	* sysdeps/x86_64/fpu/k_tanl.c: New file.
+
 2007-05-14  Ulrich Drepper  <drepper@redhat.com>
 
 	* version.h (VERSION): Define to 6.
@@ -71,6 +305,13 @@
 	* include/sys/cdefs.h: Redefine __nonnull so that test for
 	incorrect parameters in the libc code itself are not omitted.
 
+2006-07-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* nscd/connections.c (sighup_pending): New variable.
+	(nscd_run): If sighup_pending, prune all 3 caches.
+	(sighup_handler): Don't prune caches here, rather just set
+	sighup_pending flag.
+
 2007-05-09  Jakub Jelinek  <jakub@redhat.com>
 
 	* sysdeps/ia64/fpu/fraiseexcpt.c (feraiseexcept): Don't raise overflow
@@ -366,6 +607,10 @@
 	[BZ #4368]
 	* stdlib/stdlib.h: Remove obsolete part of comment for realpath.
 
+2007-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* locale/programs/locarchive.c (add_alias, insert_name): Remove static.
+
 2007-04-16  Ulrich Drepper  <drepper@redhat.com>
 
 	[BZ #4364]
@@ -1623,6 +1868,15 @@
 	separators also if no non-zero digits found.
 	* stdlib/Makefile (tests): Add tst-strtod3.
 
+2006-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/unix/sysv/linux/netlinkaccess.h: Include linux/if_addr.h
+	if IFA_MAX is not defined.
+	(IFA_RTA, IFA_PAYLOAD, IFLA_RTA, IFLA_PAYLOAD): Define if not
+	defined.
+	* sysdeps/unix/sysv/linux/check_pf.c: Include netlinkaccess.h
+	instead of asm/types.h, linux/netlink.h and linux/rtnetlink.h.
+
 2006-12-09  Ulrich Drepper  <drepper@redhat.com>
 
 	[BZ #3632]
--- glibc-20070515T2025/ChangeLog.15	16 Feb 2005 07:34:17 -0000	1.1
+++ glibc-20070515T2025-fedora/ChangeLog.15	19 Dec 2006 19:05:40 -0000	1.1.6.3
@@ -477,6 +477,14 @@
 
 2004-11-26  Jakub Jelinek  <jakub@redhat.com>
 
+	* posix/Makefile (generated: Add getconf.speclist.
+	($(inst_libexecdir)/getconf): Use getconf.speclist instead of
+	getconf output.
+	($(objpfx)getconf.speclist): New rule.
+	* posix/getconf.speclist.h: New file.
+
+2004-11-26  Jakub Jelinek  <jakub@redhat.com>
+
 	* sysdeps/generic/unsecvars.h (UNSECURE_ENVVARS): Add GETCONF_DIR.
 
 2004-11-26  Kaz Kojima  <kkojima@rr.iij4u.or.jp>
@@ -1103,6 +1111,13 @@
 	* sysdeps/generic/tempname.c (__path_search): Add missing argument
 	TRY_TMPDIR.
 
+2004-11-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/features.h (__USE_FORTIFY_LEVEL): Also set for Red Hat
+	GCC 3.4.x-RH >= 3.4.2-8.
+	* debug/tst-chk1.c (do_test): Deal with GCC 3.4.x-RH not
+	being able to recognize subobjects.
+
 2004-10-31  Mariusz Mazur <mmazur@kernel.pl>
 
 	* sysdeps/unix/sysv/linux/alpha/setregid.c: New file.
@@ -1443,6 +1458,11 @@
 	* sysdeps/generic/readonly-area.c (__readonly_str): Renamed to ...
 	(__readonly_area): ... this.
 
+2004-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/features.h (__USE_FORTIFY_LEVEL): Enable even with
+	Red Hat gcc4 4.0.0 and above.
+
 2004-10-18  Jakub Jelinek  <jakub@redhat.com>
 
 	* sysdeps/generic/strcpy_chk.c (__strcpy_chk): Speed up by checking
@@ -3182,6 +3202,23 @@
 	before return type.
 	* locale/localename.c (__current_locale_name): Likewise.
 
+2004-08-31  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/ldconfig.c (parse_conf): Add prefix argument, prepend it
+	before arguments to add_dir and pass to parse_conf_include.
+	(parse_conf_include): Add prefix argument, pass it down to
+	parse_conf.
+	(main): Call arch_startup.  Adjust parse_conf caller.
+	Call add_arch_dirs.
+	* sysdeps/generic/dl-cache.h (arch_startup, add_arch_dirs): Define.
+	* sysdeps/unix/sysv/linux/i386/dl-cache.h: New file.
+	* sysdeps/unix/sysv/linux/ia64/dl-cache.h (EMUL_HACK, arch_startup,
+	add_arch_dirs): Define.
+	* sysdeps/unix/sysv/linux/ia64/ldd-rewrite.sed: Prepend
+	/emul/ia32-linux before the 32-bit ld.so pathname.
+	* sysdeps/unix/sysv/linux/ia64/dl-procinfo.c: New file.
+	* sysdeps/unix/sysv/linux/ia64/dl-procinfo.h: New file.
+
 2004-08-30  Roland McGrath  <roland@frob.com>
 
 	* scripts/extract-abilist.awk: If `lastversion' variable defined, omit
--- glibc-20070515T2025/ChangeLog.16	4 May 2006 16:05:24 -0000	1.1
+++ glibc-20070515T2025-fedora/ChangeLog.16	5 May 2006 06:11:52 -0000	1.1.2.1
@@ -171,6 +171,11 @@
 	[BZ #2611]
 	* stdio-common/renameat.c (renameat): Fix typo.
 
+2006-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* nscd/connections.c (sighup_handler): Only run prune_cache on
+	enabled databases.
+
 2006-04-26  Roland McGrath  <roland@redhat.com>
 
 	* Makeconfig (%.v.i rule): Don't use -DASSEMBLER.
@@ -1030,6 +1035,34 @@
 	_SC_CPUTIME and _SC_THREAD_CPUTIME here.
 	* sysdeps/unix/sysv/linux/x86_64/sysconf.c (__sysconf): Likewise.
 
+2006-03-04  Jakub Jelinek  <jakub@redhat.com>
+	    Roland McGrath  <roland@redhat.com>
+
+	* sysdeps/unix/sysv/linux/i386/lowlevellock.h
+	(LLL_STUB_UNWIND_INFO_START, LLL_STUB_UNWIND_INFO_END,
+	LLL_STUB_UNWIND_INFO_3, LLL_STUB_UNWIND_INFO_4): Define.
+	(lll_mutex_lock, lll_robust_mutex_lock, lll_mutex_cond_lock,
+	lll_robust_mutex_cond_lock, lll_mutex_timedlock,
+	lll_robust_mutex_timedlock, lll_mutex_unlock,
+	lll_robust_mutex_unlock, lll_lock, lll_unlock): Use them.
+	Add _L_*_ symbols around the subsection.
+	* sysdeps/unix/sysv/linux/i386/i486/lowlevellock.S: Add unwind info.
+	* sysdeps/unix/sysv/linux/i386/i486/lowlevelrobustlock.S: Likewise.
+
+2006-03-03  Jakub Jelinek  <jakub@redhat.com>
+	    Roland McGrath  <roland@redhat.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
+	(LLL_STUB_UNWIND_INFO_START, LLL_STUB_UNWIND_INFO_END,
+	LLL_STUB_UNWIND_INFO_5, LLL_STUB_UNWIND_INFO_6): Define.
+	(lll_mutex_lock, lll_robust_mutex_lock, lll_mutex_cond_lock,
+	lll_robust_mutex_cond_lock, lll_mutex_timedlock,
+	lll_robust_mutex_timedlock, lll_mutex_unlock,
+	lll_robust_mutex_unlock, lll_lock, lll_unlock): Use them.
+	Add _L_*_ symbols around the subsection.
+	* sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: Add unwind info.
+	* sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S: Likewise.
+
 2006-03-05  Roland McGrath  <roland@redhat.com>
 
 	* malloc/malloc.c (MALLOC_ALIGNMENT): Revert to (2 * SIZE_SZ) value.
@@ -2042,6 +2075,11 @@
 	(__MATHDECL_2): Use __REDIRECT_NTH instead of __REDIRECT
 	followed by __THROW.
 
+	* sysdeps/unix/sysv/linux/futimesat.c (futimesat): If
+	file == NULL, use __futimes unconditionally.
+
+	* manual/filesys.texi (futimes): Fix prototype.
+
 2006-02-02  Ulrich Drepper  <drepper@redhat.com>
 
 	* sysdeps/unix/sysv/linux/futimesat.c [__NR_futimesat]
@@ -2101,6 +2139,11 @@
 	* sysdeps/ieee754/ldbl-128/s_llrintl.c (__llrintl): Fix a typo.
 	* sysdeps/s390/fpu/libm-test-ulps: Remove llrint ulps.
 
+2006-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/bits/stdlib-ldbl.h: New file.
+	* include/bits/wchar-ldbl.h: New file.
+
 2006-01-19  Thomas Schwinge  <tschwinge@gnu.org>
 
 	* libio/genops.c: Include <stdbool.h>.
@@ -4527,6 +4570,10 @@
 
 	* elf/order2mod2.c (init): Cast ignored value to void.
 
+2005-12-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* elf/ldconfig.c (search_dir): Skip prelink temporaries.
+
 2005-12-27  Ulrich Drepper  <drepper@redhat.com>
 
 	* elf/tst-tls13.c (do_test): Avoid using the library path when
@@ -4810,6 +4857,26 @@
 	* sysdeps/unix/sysv/linux/time.c: If __NR_time is not defined,
 	use sysdeps/unix/time.c implementation.
 
+2005-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* malloc/mtrace.c (__libc_malloc, __libc_free, __libc_realloc,
+	__libc_memalign): Add prototypes and libc_hidden_proto resp.
+	defines for !_LIBC.
+	(tr_freehook): Call __libc_free instead of free.
+	(tr_mallochook): Call __libc_malloc instead of malloc.
+	(tr_reallochook): Call __libc_realloc instead of realloc.
+	(tr_memalignhook): Call __libc_memalign instead of memalign.
+	* malloc/mcheck.c: Include stdlib.h.
+	(__libc_malloc, __libc_free, __libc_realloc,
+	__libc_memalign): Add prototypes and libc_hidden_proto resp.
+	defines for !_LIBC.
+	(freehook): Call __libc_free instead of free.
+	(mallochook): Call __libc_malloc instead of malloc.
+	(reallochook): Call __libc_realloc instead of realloc.
+	(memalignhook): Call __libc_memalign instead of memalign.
+	(mcheck): Call __libc_malloc and __libc_free instead of
+	malloc and free.
+
 2005-12-19  Ulrich Drepper  <drepper@redhat.com>
 
 	[BZ #1955]
@@ -7928,6 +7995,11 @@
 	R_ARM_TLS_TPOFF32, R_ARM_TLS_GD32, R_ARM_TLS_LDM32,
 	R_ARM_TLS_LDO32, R_ARM_TLS_IE32, R_ARM_TLS_LE32): New macros.
 
+2005-10-03  Jakub Jelinek  <jakub@redhat.com>
+
+	* nscd/selinux.c (audit_init): Print error string in the failure
+	message.
+
 2005-10-03  Roland McGrath  <roland@redhat.com>
 
 	* sysdeps/powerpc/nofpu: Directory removed, saved in ports repository.
@@ -8922,6 +8994,12 @@
 	* argp/argp-help.c (__argp_error): __asprintf -> vasprintf.
 	(__argp_failure): Likewise.
 
+2005-08-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/unix/sysv/linux/dl-osinfo.h (_dl_setup_stack_chk_guard):
+	Shift marked &errno down on big-endian instead of up.
+	* elf/tst-stackguard1.c (do_test): Fix a typo.
+
 2005-08-08  Ulrich Drepper  <drepper@redhat.com>
 
 	* nscd/cache.c (cache_add): Commit hash table and header to disk.
@@ -9046,6 +9124,17 @@
 	__syslog_chk.
 	* misc/Versions: Export __syslog_chk and __vsyslog_chk.
 
+2005-07-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/unix/sysv/linux/dl-osinfo.h: Include errno.h, hp-timing.h,
+	endian.h.
+	(_dl_setup_stack_chk_guard): Even without
+	--enable-stackguard-randomization attempt to do some guard
+	randomization using hp-timing (if available) and kernel stack and
+	mmap randomization.
+	* elf/tst-stackguard1.c (do_test): Don't fail if the poor man's
+	randomization doesn't work well enough.
+
 2005-07-28  Thomas Schwinge  <schwinge@nic-nac-project.de>
 
 	[BZ #1137]
@@ -12106,6 +12195,18 @@
 
 	* scripts/soversions.awk: Fix default version set handling.
 
+2005-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/unix/sysv/linux/bits/termios.h (CMSPAR): Define.
+	* sysdeps/unix/sysv/linux/alpha/bits/termios.h: Add __USE_MISC
+	and __USE_XOPEN guards to match linux/bits/termios.h.
+	(CMSPAR): Define.
+	* sysdeps/unix/sysv/linux/powerpc/bits/termios.h: Add __USE_MISC
+	and __USE_XOPEN guards to match linux/bits/termios.h.
+	(CMSPAR): Define.
+	* sysdeps/unix/sysv/linux/sparc/bits/termios.h: Add __USE_MISC
+	and __USE_XOPEN guards to match linux/bits/termios.h.
+
 2005-02-10  Roland McGrath  <roland@redhat.com>
 
 	[BZ #157]
--- glibc-20070515T2025/csu/Makefile	1 Mar 2006 10:35:47 -0000	1.79
+++ glibc-20070515T2025-fedora/csu/Makefile	30 Nov 2006 17:07:37 -0000	1.74.2.6
@@ -93,7 +93,8 @@ omit-deps += $(crtstuff)
 $(crtstuff:%=$(objpfx)%.o): %.o: %.S $(objpfx)defs.h
 	$(compile.S) -g0 $(ASFLAGS-.os) -o $@
 
-CFLAGS-initfini.s = -g0 -fPIC -fno-inline-functions $(fno-unit-at-a-time)
+CFLAGS-initfini.s = -g0 -fPIC -fno-inline-functions $(fno-unit-at-a-time) \
+		    -fno-asynchronous-unwind-tables
 
 vpath initfini.c $(sysdirs)
 
--- glibc-20070515T2025/csu/elf-init.c	5 Nov 2005 17:41:38 -0000	1.8
+++ glibc-20070515T2025-fedora/csu/elf-init.c	15 Nov 2005 09:54:10 -0000	1.3.2.6
@@ -49,6 +49,23 @@ extern void (*__init_array_end []) (int,
 extern void (*__fini_array_start []) (void) attribute_hidden;
 extern void (*__fini_array_end []) (void) attribute_hidden;
 
+#if defined HAVE_VISIBILITY_ATTRIBUTE \
+    && (defined SHARED || defined LIBC_NONSHARED)
+# define hidden_undef_2(x) #x
+# define hidden_undef_1(x) hidden_undef_2 (x)
+# define hidden_undef(x) \
+  __asm (hidden_undef_1 (ASM_GLOBAL_DIRECTIVE) " " #x); \
+  __asm (".hidden " #x);
+#else
+# define hidden_undef(x)
+#endif
+
+hidden_undef (__preinit_array_start)
+hidden_undef (__preinit_array_end)
+hidden_undef (__init_array_start)
+hidden_undef (__init_array_end)
+hidden_undef (__fini_array_start)
+hidden_undef (__fini_array_end)
 
 /* These function symbols are provided for the .init/.fini section entry
    points automagically by the linker.  */
--- glibc-20070515T2025/debug/tst-chk1.c	24 Apr 2006 17:00:18 -0000	1.15
+++ glibc-20070515T2025-fedora/debug/tst-chk1.c	24 Apr 2006 20:31:49 -0000	1.1.2.16
@@ -17,6 +17,9 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+/* Hack: make sure GCC doesn't know __chk_fail () will not return.  */
+#define __noreturn__
+
 #include <assert.h>
 #include <fcntl.h>
 #include <locale.h>
@@ -232,7 +235,7 @@ do_test (void)
   if (memcmp (a.buf1, "aabcdabcjj", 10))
     FAIL ();
 
-#if __USE_FORTIFY_LEVEL < 2
+#if __USE_FORTIFY_LEVEL < 2 || !__GNUC_PREREQ (4, 0)
   /* The following tests are supposed to crash with -D_FORTIFY_SOURCE=2
      and sufficient GCC support, as the string operations overflow
      from a.buf1 into a.buf2.  */
@@ -337,7 +340,7 @@ do_test (void)
   memset (a.buf1 + 9, 'j', l0 + 2);
   CHK_FAIL_END
 
-#if __USE_FORTIFY_LEVEL >= 2
+#if __USE_FORTIFY_LEVEL >= 2 && __GNUC_PREREQ (4, 0)
 # define O 0
 #else
 # define O 1
--- glibc-20070515T2025/dlfcn/dlinfo.c	27 Oct 2006 23:11:41 -0000	1.7
+++ glibc-20070515T2025-fedora/dlfcn/dlinfo.c	7 Jul 2007 21:28:54 -0000	1.2.2.7
@@ -1,5 +1,5 @@
 /* dlinfo -- Get information from the dynamic linker.
-   Copyright (C) 2003, 2004, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -56,9 +56,8 @@ dlinfo_doit (void *argsblock)
       /* Find the highest-addressed object that CALLER is not below.  */
       for (nsid = 0; nsid < DL_NNS; ++nsid)
 	for (l = GL(dl_ns)[nsid]._ns_loaded; l != NULL; l = l->l_next)
-	  if (caller >= l->l_map_start && caller < l->l_map_end)
-	    /* There must be exactly one DSO for the range of the virtual
-	       memory.  Otherwise something is really broken.  */
+	  if (caller >= l->l_map_start && caller < l->l_map_end
+	      && (l->l_contiguous || _dl_addr_inside_object (l, caller)))
 	    break;
 
       if (l == NULL)
--- glibc-20070515T2025/elf/dl-addr.c	6 May 2007 21:00:04 -0000	1.33
+++ glibc-20070515T2025-fedora/elf/dl-addr.c	7 Jul 2007 17:31:45 -0000	1.21.2.13
@@ -134,22 +134,12 @@ _dl_addr (const void *address, Dl_info *
   /* Find the highest-addressed object that ADDRESS is not below.  */
   for (Lmid_t ns = 0; ns < DL_NNS; ++ns)
     for (struct link_map *l = GL(dl_ns)[ns]._ns_loaded; l; l = l->l_next)
-      if (addr >= l->l_map_start && addr < l->l_map_end)
+      if (addr >= l->l_map_start && addr < l->l_map_end
+	  && (l->l_contiguous || _dl_addr_inside_object (l, addr)))
 	{
-	  /* Make sure it lies within one of L's segments.  */
-	  int n = l->l_phnum;
-	  const ElfW(Addr) reladdr = addr - l->l_addr;
-	  while (--n >= 0)
-	    if (l->l_phdr[n].p_type == PT_LOAD)
-	      {
-		if (reladdr - l->l_phdr[n].p_vaddr >= 0
-		    && reladdr - l->l_phdr[n].p_vaddr < l->l_phdr[n].p_memsz)
-		  {
-		    determine_info (addr, l, info, mapp, symbolp);
-		    result = 1;
-		    goto out;
-		  }
-	      }
+	  determine_info (addr, l, info, mapp, symbolp);
+	  result = 1;
+	  goto out;
 	}
 
  out:
@@ -158,3 +148,19 @@ _dl_addr (const void *address, Dl_info *
   return result;
 }
 libc_hidden_def (_dl_addr)
+
+/* Return non-zero if ADDR lies within one of L's segments.  */
+int
+internal_function
+_dl_addr_inside_object (struct link_map *l, const ElfW(Addr) addr)
+{
+  int n = l->l_phnum;
+  const ElfW(Addr) reladdr = addr - l->l_addr;
+
+  while (--n >= 0)
+    if (l->l_phdr[n].p_type == PT_LOAD
+	&& reladdr - l->l_phdr[n].p_vaddr >= 0
+	&& reladdr - l->l_phdr[n].p_vaddr < l->l_phdr[n].p_memsz)
+      return 1;
+  return 0;
+}
--- glibc-20070515T2025/elf/dl-close.c	11 May 2007 18:46:34 -0000	1.126
+++ glibc-20070515T2025-fedora/elf/dl-close.c	7 Jul 2007 17:19:40 -0000	1.104.2.13
@@ -31,6 +31,7 @@
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sysdep-cancel.h>
+#include <tls.h>
 
 
 /* Type of the constructor functions.  */
@@ -228,6 +229,8 @@ _dl_close_worker (struct link_map *map)
   bool do_audit = GLRO(dl_naudit) > 0 && !ns->_ns_loaded->l_auditing;
 #endif
   bool unload_any = false;
+  bool scope_mem_left = false;
+  unsigned int unload_global = 0;
   unsigned int first_loaded = ~0;
   for (unsigned int i = 0; i < nloaded; ++i)
     {
@@ -292,6 +295,9 @@ _dl_close_worker (struct link_map *map)
 	  /* We indeed have an object to remove.  */
 	  unload_any = true;
 
+	  if (imap->l_global)
+	    ++unload_global;
+
 	  /* Remember where the first dynamically loaded object is.  */
 	  if (i < first_loaded)
 	    first_loaded = i;
@@ -400,18 +406,18 @@ _dl_close_worker (struct link_map *map)
 
 	      struct r_scope_elem **old = imap->l_scope;
 
-	      if (RTLD_SINGLE_THREAD_P)
-		imap->l_scope = newp;
-	      else
-		{
-		  __rtld_mrlock_change (imap->l_scope_lock);
-		  imap->l_scope = newp;
-		  __rtld_mrlock_done (imap->l_scope_lock);
-		}
+	      imap->l_scope = newp;
 
 	      /* No user anymore, we can free it now.  */
 	      if (old != imap->l_scope_mem)
-		free (old);
+		{
+		  if (_dl_scope_free (old))
+		    /* If _dl_scope_free used THREAD_GSCOPE_WAIT (),
+		       no need to repeat it.  */
+		    scope_mem_left = false;
+		}
+	      else
+		scope_mem_left = true;
 
 	      imap->l_scope_max = new_size;
 	    }
@@ -457,6 +463,46 @@ _dl_close_worker (struct link_map *map)
   r->r_state = RT_DELETE;
   _dl_debug_state ();
 
+  if (unload_global)
+    {
+      /* Some objects are in the global scope list.  Remove them.  */
+      struct r_scope_elem *ns_msl = ns->_ns_main_searchlist;
+      unsigned int i;
+      unsigned int j = 0;
+      unsigned int cnt = ns_msl->r_nlist;
+
+      while (cnt > 0 && ns_msl->r_list[cnt - 1]->l_removed)
+	--cnt;
+
+      if (cnt + unload_global == ns_msl->r_nlist)
+	/* Speed up removing most recently added objects.  */
+	j = cnt;
+      else
+ 	for (i = 0; i < cnt; i++)
+	  if (ns_msl->r_list[i]->l_removed == 0)
+	    {
+	      if (i != j)
+		ns_msl->r_list[j] = ns_msl->r_list[i];
+	      j++;
+	    }
+      ns_msl->r_nlist = j;
+    }
+
+  if (!RTLD_SINGLE_THREAD_P
+      && (unload_global
+	  || scope_mem_left
+	  || (GL(dl_scope_free_list) != NULL
+	      && GL(dl_scope_free_list)->count)))
+    {
+      struct dl_scope_free_list *fsl;
+
+      THREAD_GSCOPE_WAIT ();
+      /* Now we can free any queued old scopes.  */
+      if ((fsl = GL(dl_scope_free_list)) != NULL)
+	while (fsl->count > 0)
+	  free (fsl->list[--fsl->count]);
+    }
+
   size_t tls_free_start;
   size_t tls_free_end;
   tls_free_start = tls_free_end = NO_TLS_OFFSET;
@@ -472,22 +518,6 @@ _dl_close_worker (struct link_map *map)
 
 	  /* That was the last reference, and this was a dlopen-loaded
 	     object.  We can unmap it.  */
-	  if (__builtin_expect (imap->l_global, 0))
-	    {
-	      /* This object is in the global scope list.  Remove it.  */
-	      struct r_scope_elem *ns_msl = ns->_ns_main_searchlist;
-	      unsigned int cnt = ns_msl->r_nlist;
-
-	      do
-		--cnt;
-	      while (ns_msl->r_list[cnt] != imap);
-
-	      /* The object was already correctly registered.  */
-	      while (++cnt < ns_msl->r_nlist)
-		ns_msl->r_list[cnt - 1] = ns_msl->r_list[cnt];
-
-	      --ns_msl->r_nlist;
-	    }
 
 	  /* Remove the object from the dtv slotinfo array if it uses TLS.  */
 	  if (__builtin_expect (imap->l_tls_blocksize > 0, 0))
@@ -769,4 +799,8 @@ libc_freeres_fn (free_mem)
 	   malloc), and in the static library it's in .bss space.  */
 	free_slotinfo (&GL(dl_tls_dtv_slotinfo_list)->next);
     }
+
+  void *scope_free_list = GL(dl_scope_free_list);
+  GL(dl_scope_free_list) = NULL;
+  free (scope_free_list);
 }
--- glibc-20070515T2025/elf/dl-iteratephdr.c	27 Oct 2006 23:11:41 -0000	1.14
+++ glibc-20070515T2025-fedora/elf/dl-iteratephdr.c	7 Jul 2007 21:28:54 -0000	1.11.2.5
@@ -1,5 +1,5 @@
 /* Get loaded objects program headers.
-   Copyright (C) 2001,2002,2003,2004,2006 Free Software Foundation, Inc.
+   Copyright (C) 2001,2002,2003,2004,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Jakub Jelinek <jakub@redhat.com>, 2001.
 
@@ -54,9 +54,9 @@ __dl_iterate_phdr (int (*callback) (stru
 	nloaded += GL(dl_ns)[cnt]._ns_nloaded;
 
 	if (caller >= (const void *) l->l_map_start
-	    && caller < (const void *) l->l_map_end)
-	  /* There must be exactly one DSO for the range of the virtual
-	     memory.  Otherwise something is really broken.  */
+	    && caller < (const void *) l->l_map_end
+	    && (l->l_contiguous
+		|| _dl_addr_inside_object (l, (ElfW(Addr)) caller)))
 	  ns = cnt;
       }
 
--- glibc-20070515T2025/elf/dl-load.c	9 Nov 2006 16:08:30 -0000	1.284
+++ glibc-20070515T2025-fedora/elf/dl-load.c	7 Jul 2007 21:28:54 -0000	1.249.2.28
@@ -1,5 +1,5 @@
 /* Map in a shared object's segments from the file.
-   Copyright (C) 1995-2005, 2006  Free Software Foundation, Inc.
+   Copyright (C) 1995-2005, 2006, 2007  Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -1223,6 +1223,8 @@ cannot allocate TLS data structures for 
 		      loadcmds[nloadcmds - 1].mapstart - c->mapend,
 		      PROT_NONE);
 
+	l->l_contiguous = 1;
+
 	goto postmap;
       }
 
@@ -1242,6 +1244,7 @@ cannot allocate TLS data structures for 
     /* Remember which part of the address space this object uses.  */
     l->l_map_start = c->mapstart + l->l_addr;
     l->l_map_end = l->l_map_start + maplength;
+    l->l_contiguous = !has_holes;
 
     while (c < &loadcmds[nloadcmds])
       {
--- glibc-20070515T2025/elf/dl-lookup.c	15 Jan 2007 20:45:53 -0000	1.126
+++ glibc-20070515T2025-fedora/elf/dl-lookup.c	7 Jul 2007 17:19:40 -0000	1.116.2.11
@@ -86,7 +86,7 @@ dl_new_hash (const char *s)
 /* Add extra dependency on MAP to UNDEF_MAP.  */
 static int
 internal_function
-add_dependency (struct link_map *undef_map, struct link_map *map, int flags)
+add_dependency (struct link_map *undef_map, struct link_map *map)
 {
   struct link_map **list;
   struct link_map *runp;
@@ -99,18 +99,8 @@ add_dependency (struct link_map *undef_m
   if (undef_map == map)
     return 0;
 
-  /* Make sure nobody can unload the object while we are at it.
-     If we hold a scope lock drop it now to avoid ABBA locking problems.  */
-  if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0 && !RTLD_SINGLE_THREAD_P)
-    {
-      __rtld_mrlock_unlock (undef_map->l_scope_lock);
-
-      __rtld_lock_lock_recursive (GL(dl_load_lock));
-
-      __rtld_mrlock_lock (undef_map->l_scope_lock);
-    }
-  else
-    __rtld_lock_lock_recursive (GL(dl_load_lock));
+  /* Make sure nobody can unload the object while we are at it.  */
+  __rtld_lock_lock_recursive (GL(dl_load_lock));
 
   /* Avoid references to objects which cannot be unloaded anyway.  */
   if (map->l_type != lt_loaded
@@ -237,20 +227,15 @@ _dl_lookup_symbol_x (const char *undef_n
 
   bump_num_relocations ();
 
-  /* No other flag than DL_LOOKUP_ADD_DEPENDENCY and DL_LOOKUP_SCOPE_LOCK
-     is allowed if we look up a versioned symbol.  */
-  assert (version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY
-					| DL_LOOKUP_SCOPE_LOCK)) == 0);
+  /* No other flag than DL_LOOKUP_ADD_DEPENDENCY is allowed if we look
+     up a versioned symbol.  */
+  assert (version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY)) == 0);
 
   size_t i = 0;
   if (__builtin_expect (skip_map != NULL, 0))
-    {
-      /* Search the relevant loaded objects for a definition.  */
-      while ((*scope)->r_list[i] != skip_map)
-	++i;
-
-      assert (i < (*scope)->r_nlist);
-    }
+    /* Search the relevant loaded objects for a definition.  */
+    while ((*scope)->r_list[i] != skip_map)
+      ++i;
 
   /* Search the relevant loaded objects for a definition.  */
   for (size_t start = i; *scope != NULL; start = 0, ++scope)
@@ -350,13 +335,11 @@ _dl_lookup_symbol_x (const char *undef_n
 	 runtime lookups.  */
       && (flags & DL_LOOKUP_ADD_DEPENDENCY) != 0
       /* Add UNDEF_MAP to the dependencies.  */
-      && add_dependency (undef_map, current_value.m, flags) < 0)
+      && add_dependency (undef_map, current_value.m) < 0)
       /* Something went wrong.  Perhaps the object we tried to reference
 	 was just removed.  Try finding another definition.  */
-      return _dl_lookup_symbol_x (undef_name, undef_map, ref,
-				  (flags & DL_LOOKUP_SCOPE_LOCK) == 0
-				  ? symbol_scope : undef_map->l_scope, version,
-				  type_class, flags, skip_map);
+      return _dl_lookup_symbol_x (undef_name, undef_map, ref, symbol_scope,
+				  version, type_class, flags, skip_map);
 
   /* The object is used.  */
   current_value.m->l_used = 1;
--- glibc-20070515T2025/elf/dl-minimal.c	25 Jan 2007 17:10:40 -0000	1.53
+++ glibc-20070515T2025-fedora/elf/dl-minimal.c	7 Jul 2007 17:37:06 -0000	1.48.2.5
@@ -75,14 +75,21 @@ __libc_memalign (size_t align, size_t n)
   alloc_ptr = (void *) 0 + (((alloc_ptr - (void *) 0) + align - 1)
 			    & ~(align - 1));
 
-  if (alloc_ptr + n >= alloc_end)
+  if (alloc_ptr + n >= alloc_end || n >= -(uintptr_t) alloc_ptr)
     {
       /* Insufficient space left; allocate another page.  */
       caddr_t page;
       size_t nup = (n + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      if (__builtin_expect (nup == 0, 0))
+	{
+	  if (n)
+	    return NULL;
+	  nup = GLRO(dl_pagesize);
+	}
       page = __mmap (0, nup, PROT_READ|PROT_WRITE,
 		     MAP_ANON|MAP_PRIVATE, _dl_zerofd, 0);
-      assert (page != MAP_FAILED);
+      if (page == MAP_FAILED)
+	return NULL;
       if (page != alloc_end)
 	alloc_ptr = page;
       alloc_end = page + nup;
@@ -108,7 +115,14 @@ calloc (size_t nmemb, size_t size)
   /* New memory from the trivial malloc above is always already cleared.
      (We make sure that's true in the rare occasion it might not be,
      by clearing memory in free, below.)  */
-  return malloc (nmemb * size);
+  size_t bytes = nmemb * size;
+
+#define HALF_SIZE_T (((size_t) 1) << (8 * sizeof (size_t) / 2))
+  if (__builtin_expect ((nmemb | size) >= HALF_SIZE_T, 0)
+      && size != 0 && bytes / size != nmemb)
+    return NULL;
+
+  return malloc (bytes);
 }
 
 /* This will rarely be called.  */
@@ -264,7 +278,7 @@ __strtoul_internal (const char *nptr, ch
   while (*nptr >= '0' && *nptr <= '9')
     {
       unsigned long int digval = *nptr - '0';
-      if (result > LONG_MAX / 10
+      if (result > ULONG_MAX / 10
 	  || (result == ULONG_MAX / 10 && digval > ULONG_MAX % 10))
 	{
 	  errno = ERANGE;
--- glibc-20070515T2025/elf/dl-object.c	27 Oct 2006 23:11:41 -0000	1.43
+++ glibc-20070515T2025-fedora/elf/dl-object.c	7 Jul 2007 21:28:55 -0000	1.37.2.8
@@ -1,5 +1,5 @@
 /* Storage management for the chain of loaded shared objects.
-   Copyright (C) 1995-2002, 2004, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1995-2002, 2004, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -85,11 +85,6 @@ _dl_new_object (char *realname, const ch
   new->l_scope = new->l_scope_mem;
   new->l_scope_max = sizeof (new->l_scope_mem) / sizeof (new->l_scope_mem[0]);
 
-  /* No need to initialize the scope lock if the initializer is zero.  */
-#if _RTLD_MRLOCK_INITIALIZER != 0
-  __rtld_mrlock_initialize (new->l_scope_lock);
-#endif
-
   /* Counter for the scopes we have to handle.  */
   idx = 0;
 
--- glibc-20070515T2025/elf/dl-open.c	11 May 2007 21:34:32 -0000	1.139
+++ glibc-20070515T2025-fedora/elf/dl-open.c	7 Jul 2007 17:31:45 -0000	1.111.2.21
@@ -32,6 +32,7 @@
 #include <bp-sym.h>
 #include <caller.h>
 #include <sysdep-cancel.h>
+#include <tls.h>
 
 #include <dl-dst.h>
 
@@ -125,15 +126,25 @@ add_to_global (struct link_map *new)
     {
       /* We have to extend the existing array of link maps in the
 	 main map.  */
+      struct link_map **old_global
+	= GL(dl_ns)[new->l_ns]._ns_main_searchlist->r_list;
+      size_t new_nalloc = ((ns->_ns_global_scope_alloc + to_add) * 2);
+
       new_global = (struct link_map **)
-	realloc (ns->_ns_main_searchlist->r_list,
-		 ((ns->_ns_global_scope_alloc + to_add + 8)
-		  * sizeof (struct link_map *)));
+	malloc (new_nalloc * sizeof (struct link_map *));
       if (new_global == NULL)
 	goto nomem;
 
-      ns->_ns_global_scope_alloc += to_add + 8;
+      memcpy (new_global, old_global,
+	      ns->_ns_global_scope_alloc * sizeof (struct link_map *));
+
+      ns->_ns_global_scope_alloc = new_nalloc;
       ns->_ns_main_searchlist->r_list = new_global;
+
+      if (!RTLD_SINGLE_THREAD_P)
+	THREAD_GSCOPE_WAIT ();
+
+      free (old_global);
     }
 
   /* Now add the new entries.  */
@@ -154,6 +165,40 @@ add_to_global (struct link_map *new)
   return 0;
 }
 
+int
+_dl_scope_free (struct r_scope_elem **old)
+{
+  struct dl_scope_free_list *fsl;
+#define DL_SCOPE_FREE_LIST_SIZE (sizeof (fsl->list) / sizeof (fsl->list[0]))
+
+  if (RTLD_SINGLE_THREAD_P)
+    free (old);
+  else if ((fsl = GL(dl_scope_free_list)) == NULL)
+    {
+      GL(dl_scope_free_list) = fsl = malloc (sizeof (*fsl));
+      if (fsl == NULL)
+	{
+	  THREAD_GSCOPE_WAIT ();
+	  free (old);
+	  return 1;
+	}
+      else
+	{
+	  fsl->list[0] = old;
+	  fsl->count = 1;
+	}
+    }
+  else if (fsl->count < DL_SCOPE_FREE_LIST_SIZE)
+    fsl->list[fsl->count++] = old;
+  else
+    {
+      THREAD_GSCOPE_WAIT ();
+      while (fsl->count > 0)
+	free (fsl->list[--fsl->count]);
+      return 1;
+    }
+  return 0;
+}
 
 static void
 dl_open_worker (void *a)
@@ -190,10 +235,10 @@ dl_open_worker (void *a)
       for (Lmid_t ns = 0; ns < DL_NNS; ++ns)
 	for (l = GL(dl_ns)[ns]._ns_loaded; l != NULL; l = l->l_next)
 	  if (caller_dlopen >= (const void *) l->l_map_start
-	      && caller_dlopen < (const void *) l->l_map_end)
+	      && caller_dlopen < (const void *) l->l_map_end
+	      && (l->l_contiguous
+		  || _dl_addr_inside_object (l, (ElfW(Addr)) caller_dlopen)))
 	    {
-	      /* There must be exactly one DSO for the range of the virtual
-		 memory.  Otherwise something is really broken.  */
 	      assert (ns == l->l_ns);
 	      call_map = l;
 	      goto found_caller;
@@ -418,17 +463,10 @@ dl_open_worker (void *a)
 	      memcpy (newp, imap->l_scope, cnt * sizeof (imap->l_scope[0]));
 	      struct r_scope_elem **old = imap->l_scope;
 
-	      if (RTLD_SINGLE_THREAD_P)
-		imap->l_scope = newp;
-	      else
-		{
-		  __rtld_mrlock_change (imap->l_scope_lock);
-		  imap->l_scope = newp;
-		  __rtld_mrlock_done (imap->l_scope_lock);
-		}
+	      imap->l_scope = newp;
 
 	      if (old != imap->l_scope_mem)
-		free (old);
+		_dl_scope_free (old);
 
 	      imap->l_scope_max = new_size;
 	    }
@@ -651,3 +689,21 @@ show_scope (struct link_map *new)
     }
 }
 #endif
+
+#ifdef IS_IN_rtld
+/* Return non-zero if ADDR lies within one of L's segments.  */
+int
+internal_function
+_dl_addr_inside_object (struct link_map *l, const ElfW(Addr) addr)
+{
+  int n = l->l_phnum;
+  const ElfW(Addr) reladdr = addr - l->l_addr;
+
+  while (--n >= 0)
+    if (l->l_phdr[n].p_type == PT_LOAD
+	&& reladdr - l->l_phdr[n].p_vaddr >= 0
+	&& reladdr - l->l_phdr[n].p_vaddr < l->l_phdr[n].p_memsz)
+      return 1;
+  return 0;
+}
+#endif
--- glibc-20070515T2025/elf/dl-runtime.c	15 Jan 2007 20:46:54 -0000	1.75
+++ glibc-20070515T2025-fedora/elf/dl-runtime.c	7 Jul 2007 17:19:40 -0000	1.65.2.7
@@ -26,6 +26,8 @@
 #include <ldsodefs.h>
 #include <sysdep-cancel.h>
 #include "dynamic-link.h"
+#include <tls.h>
+
 
 #if (!defined ELF_MACHINE_NO_RELA && !defined ELF_MACHINE_PLT_REL) \
     || ELF_MACHINE_NO_REL
@@ -97,17 +99,15 @@ _dl_fixup (
 	 not necessary for objects which cannot be unloaded or when
 	 we are not using any threads (yet).  */
       int flags = DL_LOOKUP_ADD_DEPENDENCY;
-      if (l->l_type == lt_loaded && !RTLD_SINGLE_THREAD_P)
-	{
-	  __rtld_mrlock_lock (l->l_scope_lock);
-	  flags |= DL_LOOKUP_SCOPE_LOCK;
-	}
+      if (!RTLD_SINGLE_THREAD_P)
+	THREAD_GSCOPE_SET_FLAG ();
 
       result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym, l->l_scope,
 				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);
 
-      if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0)
-	__rtld_mrlock_unlock (l->l_scope_lock);
+      /* We are done with the global scope.  */
+      if (!RTLD_SINGLE_THREAD_P)
+	THREAD_GSCOPE_RESET_FLAG ();
 
       /* Currently result contains the base load address (or link map)
 	 of the object that defines sym.  Now add in the symbol
@@ -191,18 +191,16 @@ _dl_profile_fixup (
 	     not necessary for objects which cannot be unloaded or when
 	     we are not using any threads (yet).  */
 	  int flags = DL_LOOKUP_ADD_DEPENDENCY;
-	  if (l->l_type == lt_loaded && !RTLD_SINGLE_THREAD_P)
-	    {
-	      __rtld_mrlock_lock (l->l_scope_lock);
-	      flags |= DL_LOOKUP_SCOPE_LOCK;
-	    }
+	  if (!RTLD_SINGLE_THREAD_P)
+	    THREAD_GSCOPE_SET_FLAG ();
 
 	  result = _dl_lookup_symbol_x (strtab + refsym->st_name, l,
 					&defsym, l->l_scope, version,
 					ELF_RTYPE_CLASS_PLT, flags, NULL);
 
-	  if ((flags & DL_LOOKUP_SCOPE_LOCK) != 0)
-	    __rtld_mrlock_unlock (l->l_scope_lock);
+	  /* We are done with the global scope.  */
+	  if (!RTLD_SINGLE_THREAD_P)
+	    THREAD_GSCOPE_RESET_FLAG ();
 
 	  /* Currently result contains the base load address (or link map)
 	     of the object that defines sym.  Now add in the symbol
--- glibc-20070515T2025/elf/dl-support.c	13 Mar 2007 21:25:15 -0000	1.92
+++ glibc-20070515T2025-fedora/elf/dl-support.c	7 Jul 2007 17:19:40 -0000	1.84.2.12
@@ -1,5 +1,5 @@
 /* Support for dynamic linking code in static libc.
-   Copyright (C) 1996-2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1996-2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -132,6 +132,11 @@ int (*_dl_make_stack_executable_hook) (v
   = _dl_make_stack_executable;
 
 
+/* Function in libpthread to wait for termination of lookups.  */
+void (*_dl_wait_lookup_done) (void);
+
+struct dl_scope_free_list *_dl_scope_free_list;
+
 #ifdef NEED_DL_SYSINFO
 /* Needed for improved syscall handling on at least x86/Linux.  */
 uintptr_t _dl_sysinfo = DL_SYSINFO_DEFAULT;
--- glibc-20070515T2025/elf/dl-sym.c	15 Jan 2007 20:47:44 -0000	1.34
+++ glibc-20070515T2025-fedora/elf/dl-sym.c	7 Jul 2007 17:31:45 -0000	1.22.2.10
@@ -98,10 +98,9 @@ do_sym (void *handle, const char *name, 
   for (Lmid_t ns = 0; ns < DL_NNS; ++ns)
     for (struct link_map *l = GL(dl_ns)[ns]._ns_loaded; l != NULL;
 	 l = l->l_next)
-      if (caller >= l->l_map_start && caller < l->l_map_end)
+      if (caller >= l->l_map_start && caller < l->l_map_end
+	  && (l->l_contiguous || _dl_addr_inside_object (l, caller)))
 	{
-	  /* There must be exactly one DSO for the range of the virtual
-	     memory.  Otherwise something is really broken.  */
 	  match = l;
 	  break;
 	}
@@ -113,29 +112,29 @@ do_sym (void *handle, const char *name, 
 	 the initial binary.  And then the more complex part
 	 where the object is dynamically loaded and the scope
 	 array can change.  */
-      if (match->l_type != lt_loaded || RTLD_SINGLE_THREAD_P)
+      if (RTLD_SINGLE_THREAD_P)
 	result = GLRO(dl_lookup_symbol_x) (name, match, &ref,
 					   match->l_scope, vers, 0,
 					   flags | DL_LOOKUP_ADD_DEPENDENCY,
 					   NULL);
       else
 	{
-	  __rtld_mrlock_lock (match->l_scope_lock);
-
 	  struct call_dl_lookup_args args;
 	  args.name = name;
 	  args.map = match;
 	  args.vers = vers;
-	  args.flags = flags | DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_SCOPE_LOCK;
+	  args.flags = flags | DL_LOOKUP_ADD_DEPENDENCY;
 	  args.refp = &ref;
 
+	  THREAD_GSCOPE_SET_FLAG ();
+
 	  const char *objname;
 	  const char *errstring = NULL;
 	  bool malloced;
 	  int err = GLRO(dl_catch_error) (&objname, &errstring, &malloced,
 					  call_dl_lookup, &args);
 
-	  __rtld_mrlock_unlock (match->l_scope_lock);
+	  THREAD_GSCOPE_RESET_FLAG ();
 
 	  if (__builtin_expect (errstring != NULL, 0))
 	    {
--- glibc-20070515T2025/elf/dl-sysdep.c	27 Oct 2006 23:11:42 -0000	1.2
+++ glibc-20070515T2025-fedora/elf/dl-sysdep.c	7 Jul 2007 21:28:55 -0000	1.1.2.4
@@ -1,5 +1,5 @@
 /* Operating system support for run-time dynamic linker.  Generic Unix version.
-   Copyright (C) 1995-1998, 2000-2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -460,9 +460,21 @@ _dl_important_hwcaps (const char *platfo
     total = temp[0].len + 1;
   else
     {
-      total = (1UL << (cnt - 2)) * (temp[0].len + temp[cnt - 1].len + 2);
-      for (n = 1; n + 1 < cnt; ++n)
-	total += (1UL << (cnt - 3)) * (temp[n].len + 1);
+      total = temp[0].len + temp[cnt - 1].len + 2;
+      if (cnt > 2)
+	{
+	  total <<= 1;
+	  for (n = 1; n + 1 < cnt; ++n)
+	    total += temp[n].len + 1;
+	  if (cnt > 3
+	      && (cnt >= sizeof (size_t) * 8
+		  || total + (sizeof (*result) << 3)
+		     >= (1UL << (sizeof (size_t) * 8 - cnt + 3))))
+	    _dl_signal_error (ENOMEM, NULL, NULL,
+			      N_("cannot create capability list"));
+
+	  total <<= cnt - 3;
+	}
     }
 
   /* The result structure: we use a very compressed way to store the
--- glibc-20070515T2025/elf/do-lookup.h	4 Sep 2006 20:40:11 -0000	1.36
+++ glibc-20070515T2025-fedora/elf/do-lookup.h	7 Jul 2007 17:15:06 -0000	1.29.2.6
@@ -1,5 +1,5 @@
 /* Look up a symbol in the loaded objects.
-   Copyright (C) 1995-2004, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1995-2004, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -29,8 +29,13 @@ do_lookup_x (const char *undef_name, uin
 	     const struct r_found_version *const version, int flags,
 	     struct link_map *skip, int type_class)
 {
-  struct link_map **list = scope->r_list;
   size_t n = scope->r_nlist;
+  /* Make sure we read the value before proceeding.  Otherwise we
+     might use r_list pointing to the initial scope and r_nlist being
+     the value after a resize.  That is the only path in dl-open.c not
+     protected by GSCOPE.  A read barrier here might be to expensive.  */
+  __asm volatile ("" : "+r" (n), "+m" (scope->r_list));
+  struct link_map **list = scope->r_list;
 
   do
     {
--- glibc-20070515T2025/elf/ldconfig.c	13 Apr 2007 19:53:20 -0000	1.59
+++ glibc-20070515T2025-fedora/elf/ldconfig.c	16 Apr 2007 23:59:03 -0000	1.47.2.14
@@ -965,17 +965,19 @@ search_dirs (void)
 
 
 static void parse_conf_include (const char *config_file, unsigned int lineno,
-				bool do_chroot, const char *pattern);
+				const char *prefix, bool do_chroot,
+				const char *pattern);
 
 /* Parse configuration file.  */
 static void
-parse_conf (const char *filename, bool do_chroot)
+parse_conf (const char *filename, const char *prefix, bool do_chroot)
 {
   FILE *file = NULL;
   char *line = NULL;
   const char *canon;
   size_t len = 0;
   unsigned int lineno;
+  size_t prefix_len = prefix ? strlen (prefix) : 0;
 
   if (do_chroot && opt_chroot)
     {
@@ -1036,7 +1038,14 @@ parse_conf (const char *filename, bool d
 	  cp += 8;
 	  while ((dir = strsep (&cp, " \t")) != NULL)
 	    if (dir[0] != '\0')
-	      parse_conf_include (filename, lineno, do_chroot, dir);
+	      parse_conf_include (filename, lineno, prefix, do_chroot, dir);
+	}
+      else if (prefix != NULL)
+	{
+	  size_t cp_len = strlen (cp);
+	  char new_cp [prefix_len + cp_len + 1];
+	  memcpy (mempcpy (new_cp, prefix, prefix_len), cp, cp_len + 1);
+	  add_dir (new_cp);
 	}
       else if (!strncasecmp (cp, "hwcap", 5) && isblank (cp[5]))
 	{
@@ -1099,7 +1108,7 @@ parse_conf (const char *filename, bool d
    config files to read.  */
 static void
 parse_conf_include (const char *config_file, unsigned int lineno,
-		    bool do_chroot, const char *pattern)
+		    const char *prefix, bool do_chroot, const char *pattern)
 {
   if (opt_chroot && pattern[0] != '/')
     error (EXIT_FAILURE, 0,
@@ -1129,7 +1138,7 @@ parse_conf_include (const char *config_f
     {
     case 0:
       for (size_t i = 0; i < gl.gl_pathc; ++i)
-	parse_conf (gl.gl_pathv[i], false);
+	parse_conf (gl.gl_pathv[i], prefix, false);
       globfree64 (&gl);
       break;
 
@@ -1173,6 +1182,8 @@ main (int argc, char **argv)
   /* Set the text message domain.  */
   textdomain (_libc_intl_domainname);
 
+  arch_startup (argc, argv);
+
   /* Parse and process arguments.  */
   int remaining;
   argp_parse (&argp, argc, argv, 0, &remaining, NULL);
@@ -1284,12 +1295,14 @@ main (int argc, char **argv)
 
   if (!opt_only_cline)
     {
-      parse_conf (config_file, true);
+      parse_conf (config_file, NULL, true);
 
       /* Always add the standard search paths.  */
       add_system_dir (SLIBDIR);
       if (strcmp (SLIBDIR, LIBDIR))
 	add_system_dir (LIBDIR);
+
+      add_arch_dirs (config_file);
     }
 
   search_dirs ();
--- glibc-20070515T2025/elf/rtld.c	12 Feb 2007 15:17:21 -0000	1.370
+++ glibc-20070515T2025-fedora/elf/rtld.c	7 Jul 2007 17:21:49 -0000	1.330.2.35
@@ -1400,6 +1400,11 @@ of this helper program; chances are you 
       /* Iterate over all entries in the list.  The order is important.  */
       struct audit_ifaces *last_audit = NULL;
       struct audit_list *al = audit_list->next;
+
+      /* Since we start using the auditing DSOs right away we need to
+	 initialize the data structures now.  */
+      tcbp = init_tls ();
+
       do
 	{
 	  int tls_idx = GL(dl_tls_max_dtv_idx);
@@ -1409,11 +1414,6 @@ of this helper program; chances are you 
 	     always allocate the static block, we never defer it even if
 	     no DF_STATIC_TLS bit is set.  The reason is that we know
 	     glibc will use the static model.  */
-
-	  /* Since we start using the auditing DSOs right away we need to
-	     initialize the data structures now.  */
-	  tcbp = init_tls ();
-
 	  struct dlmopen_args dlmargs;
 	  dlmargs.fname = al->name;
 	  dlmargs.map = NULL;
--- glibc-20070515T2025/elf/tst-stackguard1.c	26 Jun 2005 18:08:36 -0000	1.1
+++ glibc-20070515T2025-fedora/elf/tst-stackguard1.c	8 Aug 2005 21:24:27 -0000	1.1.2.3
@@ -160,17 +160,21 @@ do_test (void)
      the 16 runs, something is very wrong.  */
   int ndifferences = 0;
   int ndefaults = 0;
+  int npartlyrandomized = 0;
   for (i = 0; i < N; ++i) 
     {
       if (child_stack_chk_guards[i] != child_stack_chk_guards[i+1])
 	ndifferences++;
       else if (child_stack_chk_guards[i] == default_guard)
 	ndefaults++;
+      else if (*(char *) &child_stack_chk_guards[i] == 0)
+	npartlyrandomized++;
     }
 
-  printf ("differences %d defaults %d\n", ndifferences, ndefaults);
+  printf ("differences %d defaults %d partly randomized %d\n",
+	  ndifferences, ndefaults, npartlyrandomized);
 
-  if (ndifferences < N / 2 && ndefaults < N / 2)
+  if ((ndifferences + ndefaults + npartlyrandomized) < 3 * N / 4)
     {
       puts ("stack guard canaries are not randomized enough");
       puts ("nor equal to the default canary value");
--- glibc-20070515T2025/iconv/iconvconfig.c	3 Jan 2007 05:44:11 -0000	1.27
+++ glibc-20070515T2025-fedora/iconv/iconvconfig.c	17 Jan 2007 10:42:36 -0000	1.19.2.8
@@ -1011,6 +1011,34 @@ next_prime (uint32_t seed)
                               module name offset
                          (following last entry with step count 0)
 */
+
+static struct hash_entry *hash_table;
+static size_t hash_size;
+
+/* Function to insert the names.  */
+static void name_insert (const void *nodep, VISIT value, int level)
+{
+  struct name *name;
+  unsigned int idx;
+  unsigned int hval2;
+
+  if (value != leaf && value != postorder)
+    return;
+
+  name = *(struct name **) nodep;
+  idx = name->hashval % hash_size;
+  hval2 = 1 + name->hashval % (hash_size - 2);
+
+  while (hash_table[idx].string_offset != 0)
+    if ((idx += hval2) >= hash_size)
+      idx -= hash_size;
+
+  hash_table[idx].string_offset = strtaboffset (name->strent);
+
+  assert (name->module_idx != -1);
+  hash_table[idx].module_idx = name->module_idx;
+}
+
 static int
 write_output (void)
 {
@@ -1018,8 +1046,6 @@ write_output (void)
   char *string_table;
   size_t string_table_size;
   struct gconvcache_header header;
-  struct hash_entry *hash_table;
-  size_t hash_size;
   struct module_entry *module_table;
   char *extra_table;
   char *cur_extra_table;
@@ -1032,31 +1058,6 @@ write_output (void)
   char tmpfname[(output_file == NULL ? sizeof finalname : output_file_len + 1)
 		+ strlen (".XXXXXX")];
 
-  /* Function to insert the names.  */
-  auto void
-  name_insert (const void *nodep, VISIT value, int level)
-    {
-      struct name *name;
-      unsigned int idx;
-      unsigned int hval2;
-
-      if (value != leaf && value != postorder)
-	return;
-
-      name = *(struct name **) nodep;
-      idx = name->hashval % hash_size;
-      hval2 = 1 + name->hashval % (hash_size - 2);
-
-      while (hash_table[idx].string_offset != 0)
-	if ((idx += hval2) >= hash_size)
-	  idx -= hash_size;
-
-      hash_table[idx].string_offset = strtaboffset (name->strent);
-
-      assert (name->module_idx != -1);
-      hash_table[idx].module_idx = name->module_idx;
-    }
-
   /* Open the output file.  */
   if (output_file == NULL)
     {
--- glibc-20070515T2025/include/features.h	15 May 2007 06:48:32 -0000	1.46
+++ glibc-20070515T2025-fedora/include/features.h	15 May 2007 20:34:29 -0000	1.35.2.15
@@ -274,7 +274,13 @@
 #endif
 
 #if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 \
-    && __GNUC_PREREQ (4, 1) && defined __OPTIMIZE__ && __OPTIMIZE__ > 0
+    && defined __OPTIMIZE__ && __OPTIMIZE__ > 0 \
+    && (__GNUC_PREREQ (4, 1) \
+        || (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (4, 0)) \
+        || (defined __GNUC_RH_RELEASE__ && __GNUC_PREREQ (3, 4) \
+            && __GNUC_MINOR__ == 4 \
+            && (__GNUC_PATCHLEVEL__ > 2 \
+                || (__GNUC_PATCHLEVEL__ == 2 && __GNUC_RH_RELEASE__ >= 8))))
 # if _FORTIFY_SOURCE > 1
 #  define __USE_FORTIFY_LEVEL 2
 # else
--- glibc-20070515T2025/include/link.h	11 May 2007 06:38:05 -0000	1.44
+++ glibc-20070515T2025-fedora/include/link.h	7 Jul 2007 17:31:45 -0000	1.32.2.12
@@ -44,7 +44,6 @@ extern unsigned int la_objopen (struct l
 #include <dl-lookupcfg.h>
 #include <tls.h>
 #include <bits/libc-lock.h>
-#include <rtld-lowlevel.h>
 
 
 /* Some internal data structures of the dynamic linker used in the
@@ -187,6 +186,9 @@ struct link_map
 				       is interested in the PLT interception.*/
     unsigned int l_removed:1;	/* Nozero if the object cannot be used anymore
 				   since it is removed.  */
+    unsigned int l_contiguous:1; /* Nonzero if inter-segment holes are
+				    mprotected or if no holes are present at
+				    all.  */
 
     /* Collected information about own RPATH directories.  */
     struct r_search_path_struct l_rpath_dirs;
@@ -220,8 +222,6 @@ struct link_map
     /* This is an array defining the lookup scope for this link map.
        There are initially at most three different scope lists.  */
     struct r_scope_elem **l_scope;
-    /* We need to protect using the SCOPEREC.  */
-    __rtld_mrlock_define (, l_scope_lock)
 
     /* A similar array, this time only with the local scope.  This is
        used occasionally.  */
--- glibc-20070515T2025/include/bits/stdlib-ldbl.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/include/bits/stdlib-ldbl.h	1 Feb 2006 09:30:43 -0000	1.1.2.1
@@ -0,0 +1 @@
+#include <stdlib/bits/stdlib-ldbl.h>
--- glibc-20070515T2025/include/bits/wchar-ldbl.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/include/bits/wchar-ldbl.h	1 Feb 2006 09:30:43 -0000	1.1.2.1
@@ -0,0 +1 @@
+#include <wcsmbs/bits/wchar-ldbl.h>
--- glibc-20070515T2025/intl/locale.alias	4 Dec 2003 07:57:47 -0000	1.23
+++ glibc-20070515T2025-fedora/intl/locale.alias	22 Sep 2004 21:20:53 -0000	1.23.2.1
@@ -58,8 +58,6 @@ korean		ko_KR.eucKR
 korean.euc 	ko_KR.eucKR
 ko_KR		ko_KR.eucKR
 lithuanian      lt_LT.ISO-8859-13
-no_NO		nb_NO.ISO-8859-1
-no_NO.ISO-8859-1 nb_NO.ISO-8859-1
 norwegian       nb_NO.ISO-8859-1
 nynorsk		nn_NO.ISO-8859-1
 polish          pl_PL.ISO-8859-2
--- glibc-20070515T2025/libio/stdio.h	17 Feb 2007 18:26:15 -0000	1.89
+++ glibc-20070515T2025-fedora/libio/stdio.h	21 Feb 2007 11:15:50 -0000	1.78.2.11
@@ -145,10 +145,12 @@ typedef _G_fpos64_t fpos64_t;
 extern struct _IO_FILE *stdin;		/* Standard input stream.  */
 extern struct _IO_FILE *stdout;		/* Standard output stream.  */
 extern struct _IO_FILE *stderr;		/* Standard error output stream.  */
+#ifdef __STDC__
 /* C89/C99 say they're macros.  Make them happy.  */
 #define stdin stdin
 #define stdout stdout
 #define stderr stderr
+#endif
 
 __BEGIN_NAMESPACE_STD
 /* Remove file FILENAME.  */
--- glibc-20070515T2025/libio/bits/stdio2.h	17 Mar 2007 17:04:08 -0000	1.5
+++ glibc-20070515T2025-fedora/libio/bits/stdio2.h	17 Mar 2007 21:52:49 -0000	1.1.2.7
@@ -61,14 +61,25 @@ extern int __vfprintf_chk (FILE *__restr
 extern int __vprintf_chk (int __flag, __const char *__restrict __format,
 			  _G_va_list __ap);
 
-# define printf(...) \
+# if __GNUC_PREREQ (4, 0)
+#  define printf(...) \
   __printf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
-# define fprintf(stream, ...) \
+#  define fprintf(stream, ...) \
   __fprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
-# define vprintf(format, ap) \
+#  define vprintf(format, ap) \
   __vprintf_chk (__USE_FORTIFY_LEVEL - 1, format, ap)
-# define vfprintf(stream, format, ap) \
+#  define vfprintf(stream, format, ap) \
   __vfprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, format, ap)
+# else
+#  define printf(...) \
+  __builtin___printf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  define fprintf(stream, ...) \
+  __builtin___fprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
+#  define vprintf(format, ap) \
+  __builtin___vprintf_chk (__USE_FORTIFY_LEVEL - 1, format, ap)
+#  define vfprintf(stream, format, ap) \
+  __builtin___vfprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, format, ap)
+# endif
 
 #endif
 
--- glibc-20070515T2025/locale/iso-4217.def	17 Feb 2007 07:46:20 -0000	1.20
+++ glibc-20070515T2025-fedora/locale/iso-4217.def	21 Feb 2007 11:15:50 -0000	1.15.2.5
@@ -8,6 +8,7 @@
  *
  * !!! The list has to be sorted !!!
  */
+DEFINE_INT_CURR("ADP")		/* Andorran Peseta -> EUR  */
 DEFINE_INT_CURR("AED")		/* United Arab Emirates Dirham  */
 DEFINE_INT_CURR("AFN")		/* Afghanistan Afgani  */
 DEFINE_INT_CURR("ALL")		/* Albanian Lek  */
@@ -15,12 +16,14 @@ DEFINE_INT_CURR("AMD")		/* Armenia Dram 
 DEFINE_INT_CURR("ANG")		/* Netherlands Antilles  */
 DEFINE_INT_CURR("AOA")		/* Angolan Kwanza  */
 DEFINE_INT_CURR("ARS")		/* Argentine Peso  */
+DEFINE_INT_CURR("ATS")		/* Austrian Schilling -> EUR  */
 DEFINE_INT_CURR("AUD")		/* Australian Dollar  */
 DEFINE_INT_CURR("AWG")		/* Aruba Guilder  */
 DEFINE_INT_CURR("AZM")		/* Azerbaijan Manat  */
 DEFINE_INT_CURR("BAM")		/* Bosnian and Herzegovina Convertible Mark  */
 DEFINE_INT_CURR("BBD")		/* Barbados Dollar  */
 DEFINE_INT_CURR("BDT")		/* Bangladesh Taka  */
+DEFINE_INT_CURR("BEF")		/* Belgian Franc -> EUR  */
 DEFINE_INT_CURR("BGN")		/* Bulgarian Lev  */
 DEFINE_INT_CURR("BHD")		/* Bahraini Dinar  */
 DEFINE_INT_CURR("BIF")		/* Burundi Franc  */
@@ -44,6 +47,7 @@ DEFINE_INT_CURR("CUP")		/* Cuban Peso  *
 DEFINE_INT_CURR("CVE")		/* Cape Verde Escudo  */
 DEFINE_INT_CURR("CYP")		/* Cypriot Pound  */
 DEFINE_INT_CURR("CZK")		/* Czech Koruna  */
+DEFINE_INT_CURR("DEM")		/* German Mark -> EUR  */
 DEFINE_INT_CURR("DJF")		/* Djibouti Franc  */
 DEFINE_INT_CURR("DKK")		/* Danish Krone (Faroe Islands, Greenland)  */
 DEFINE_INT_CURR("DOP")		/* Dominican Republic  */
@@ -51,16 +55,20 @@ DEFINE_INT_CURR("DZD")		/* Algerian Dina
 DEFINE_INT_CURR("EEK")		/* Estonian Kroon  */
 DEFINE_INT_CURR("EGP")		/* Egyptian Pound  */
 DEFINE_INT_CURR("ERN")		/* Eritrean Nakfa  */
+DEFINE_INT_CURR("ESP")		/* Spanish Peseta -> EUR  */
 DEFINE_INT_CURR("ETB")		/* Ethiopian Birr  */
 DEFINE_INT_CURR("EUR")		/* European Union Euro  */
+DEFINE_INT_CURR("FIM")		/* Finnish Markka -> EUR  */
 DEFINE_INT_CURR("FJD")		/* Fiji Dollar  */
 DEFINE_INT_CURR("FKP")		/* Falkland Islands Pound (Malvinas)  */
+DEFINE_INT_CURR("FRF")		/* French Franc -> EUR  */
 DEFINE_INT_CURR("GBP")		/* British Pound  */
 DEFINE_INT_CURR("GEL")		/* Georgia Lari  */
 DEFINE_INT_CURR("GHC")		/* Ghana Cedi  */
 DEFINE_INT_CURR("GIP")		/* Gibraltar Pound  */
 DEFINE_INT_CURR("GMD")		/* Gambian Dalasi  */
 DEFINE_INT_CURR("GNF")		/* Guinea Franc  */
+DEFINE_INT_CURR("GRD")		/* Greek Drachma -> EUR  */
 DEFINE_INT_CURR("GTQ")		/* Guatemala Quetzal  */
 DEFINE_INT_CURR("GYD")		/* Guyana Dollar  */
 DEFINE_INT_CURR("HKD")		/* Hong Kong Dollar  */
@@ -69,12 +77,14 @@ DEFINE_INT_CURR("HRK")		/* Croatia Kuna 
 DEFINE_INT_CURR("HTG")		/* Haiti Gourde  */
 DEFINE_INT_CURR("HUF")		/* Hungarian Forint  */
 DEFINE_INT_CURR("IDR")		/* Indonesia Rupiah  */
+DEFINE_INT_CURR("IEP")		/* Irish Pound -> EUR  */
 DEFINE_INT_CURR("ILS")		/* Israeli Shekel  */
 DEFINE_INT_CURR("IMP")		/* Isle of Man Pounds  */
 DEFINE_INT_CURR("INR")		/* Indian Rupee (Bhutan)  */
 DEFINE_INT_CURR("IQD")		/* Iraqi Dinar  */
 DEFINE_INT_CURR("IRR")		/* Iranian Rial  */
 DEFINE_INT_CURR("ISK")		/* Iceland Krona  */
+DEFINE_INT_CURR("ITL")		/* Italian Lira -> EUR  */
 DEFINE_INT_CURR("JEP")		/* Jersey Pound  */
 DEFINE_INT_CURR("JMD")		/* Jamaican Dollar  */
 DEFINE_INT_CURR("JOD")		/* Jordanian Dinar  */
@@ -94,6 +104,7 @@ DEFINE_INT_CURR("LKR")		/* Sri Lankan Ru
 DEFINE_INT_CURR("LRD")		/* Liberian Dollar  */
 DEFINE_INT_CURR("LSL")		/* Lesotho Maloti  */
 DEFINE_INT_CURR("LTL")		/* Lithuanian Litas  */
+DEFINE_INT_CURR("LUF")		/* Luxembourg Franc -> EUR  */
 DEFINE_INT_CURR("LVL")		/* Latvia Lat  */
 DEFINE_INT_CURR("LYD")		/* Libyan Arab Jamahiriya Dinar  */
 DEFINE_INT_CURR("MAD")		/* Moroccan Dirham  */
@@ -114,6 +125,7 @@ DEFINE_INT_CURR("MZM")		/* Mozambique Me
 DEFINE_INT_CURR("NAD")		/* Namibia Dollar  */
 DEFINE_INT_CURR("NGN")		/* Nigeria Naira  */
 DEFINE_INT_CURR("NIO")		/* Nicaragua Cordoba Oro  */
+DEFINE_INT_CURR("NLG")		/* Netherlands Guilder -> EUR  */
 DEFINE_INT_CURR("NOK")		/* Norwegian Krone  */
 DEFINE_INT_CURR("NPR")		/* Nepalese Rupee  */
 DEFINE_INT_CURR("NZD")		/* New Zealand Dollar  */
@@ -124,6 +136,7 @@ DEFINE_INT_CURR("PGK")		/* Papau New Gui
 DEFINE_INT_CURR("PHP")		/* Philippines Peso  */
 DEFINE_INT_CURR("PKR")		/* Pakistan Rupee  */
 DEFINE_INT_CURR("PLN")		/* Polish Zloty  */
+DEFINE_INT_CURR("PTE")		/* Portugese Escudo -> EUR  */
 DEFINE_INT_CURR("PYG")		/* Paraguay Guarani  */
 DEFINE_INT_CURR("QAR")		/* Qatar Rial  */
 DEFINE_INT_CURR("ROL")		/* Romanian Leu  */
--- glibc-20070515T2025/locale/programs/3level.h	7 Dec 2005 05:47:27 -0000	1.6
+++ glibc-20070515T2025-fedora/locale/programs/3level.h	19 Dec 2005 12:11:15 -0000	1.5.2.2
@@ -202,6 +202,42 @@ CONCAT(TABLE,_iterate) (struct TABLE *t,
 	}
     }
 }
+
+/* GCC ATM seems to do a poor job with pointers to nested functions passed
+   to inlined functions.  Help it a little bit with this hack.  */
+#define wchead_table_iterate(tp, fn) \
+do									      \
+  {									      \
+    struct wchead_table *t = (tp);					      \
+    uint32_t index1;							      \
+    for (index1 = 0; index1 < t->level1_size; index1++)			      \
+      {									      \
+	uint32_t lookup1 = t->level1[index1];				      \
+	if (lookup1 != ((uint32_t) ~0))					      \
+	  {								      \
+	    uint32_t lookup1_shifted = lookup1 << t->q;			      \
+	    uint32_t index2;						      \
+	    for (index2 = 0; index2 < (1 << t->q); index2++)		      \
+	      {								      \
+		uint32_t lookup2 = t->level2[index2 + lookup1_shifted];	      \
+		if (lookup2 != ((uint32_t) ~0))				      \
+		  {							      \
+		    uint32_t lookup2_shifted = lookup2 << t->p;		      \
+		    uint32_t index3;					      \
+		    for (index3 = 0; index3 < (1 << t->p); index3++)	      \
+		      {							      \
+			struct element_t *lookup3			      \
+			  = t->level3[index3 + lookup2_shifted];	      \
+			if (lookup3 != NULL)				      \
+			  fn ((((index1 << t->q) + index2) << t->p) + index3, \
+			      lookup3);					      \
+		      }							      \
+		  }							      \
+	      }								      \
+	  }								      \
+      }									      \
+  } while (0)
+
 #endif
 
 #ifndef NO_FINALIZE
--- glibc-20070515T2025/locale/programs/locarchive.c	16 Apr 2007 23:30:58 -0000	1.24
+++ glibc-20070515T2025-fedora/locale/programs/locarchive.c	16 Apr 2007 23:59:03 -0000	1.21.2.3
@@ -221,9 +221,9 @@ oldlocrecentcmp (const void *a, const vo
 /* forward decls for below */
 static uint32_t add_locale (struct locarhandle *ah, const char *name,
 			    locale_data_t data, bool replace);
-static void add_alias (struct locarhandle *ah, const char *alias,
-		       bool replace, const char *oldname,
-		       uint32_t *locrec_offset_p);
+void add_alias (struct locarhandle *ah, const char *alias,
+		bool replace, const char *oldname,
+		uint32_t *locrec_offset_p);
 
 static void
 enlarge_archive (struct locarhandle *ah, const struct locarhead *head)
@@ -541,7 +541,7 @@ close_archive (struct locarhandle *ah)
 #include "../../intl/explodename.c"
 #include "../../intl/l10nflist.c"
 
-static struct namehashent *
+struct namehashent *
 insert_name (struct locarhandle *ah,
 	     const char *name, size_t name_len, bool replace)
 {
@@ -599,7 +599,7 @@ insert_name (struct locarhandle *ah,
   return &namehashtab[idx];
 }
 
-static void
+void
 add_alias (struct locarhandle *ah, const char *alias, bool replace,
 	   const char *oldname, uint32_t *locrec_offset_p)
 {
--- glibc-20070515T2025/localedata/Makefile	14 Mar 2007 22:32:43 -0000	1.105
+++ glibc-20070515T2025-fedora/localedata/Makefile	17 Mar 2007 21:52:52 -0000	1.101.2.5
@@ -223,6 +223,7 @@ $(INSTALL-SUPPORTED-LOCALES): install-lo
 	echo -n '...'; \
 	input=`echo $$locale | sed 's/\([^.]*\)[^@]*\(.*\)/\1\2/'`; \
 	$(LOCALEDEF) --alias-file=../intl/locale.alias \
+		     --no-archive \
 		     -i locales/$$input -c -f charmaps/$$charset \
 		     $(addprefix --prefix=,$(install_root)) $$locale; \
 	echo ' done'; \
--- glibc-20070515T2025/localedata/SUPPORTED	4 May 2007 20:52:45 -0000	1.103
+++ glibc-20070515T2025-fedora/localedata/SUPPORTED	10 May 2007 06:44:26 -0000	1.71.2.17
@@ -80,6 +80,7 @@ cy_GB.UTF-8/UTF-8 \
 cy_GB/ISO-8859-14 \
 da_DK.UTF-8/UTF-8 \
 da_DK/ISO-8859-1 \
+da_DK.ISO-8859-15/ISO-8859-15 \
 de_AT.UTF-8/UTF-8 \
 de_AT/ISO-8859-1 \
 de_AT@euro/ISO-8859-15 \
@@ -109,6 +110,7 @@ en_DK.UTF-8/UTF-8 \
 en_DK/ISO-8859-1 \
 en_GB.UTF-8/UTF-8 \
 en_GB/ISO-8859-1 \
+en_GB.ISO-8859-15/ISO-8859-15 \
 en_HK.UTF-8/UTF-8 \
 en_HK/ISO-8859-1 \
 en_IE.UTF-8/UTF-8 \
@@ -123,6 +125,7 @@ en_SG.UTF-8/UTF-8 \
 en_SG/ISO-8859-1 \
 en_US.UTF-8/UTF-8 \
 en_US/ISO-8859-1 \
+en_US.ISO-8859-15/ISO-8859-15 \
 en_ZA.UTF-8/UTF-8 \
 en_ZA/ISO-8859-1 \
 en_ZW.UTF-8/UTF-8 \
@@ -280,6 +283,8 @@ nl_NL/ISO-8859-1 \
 nl_NL@euro/ISO-8859-15 \
 nn_NO.UTF-8/UTF-8 \
 nn_NO/ISO-8859-1 \
+no_NO.UTF-8/UTF-8 \
+no_NO/ISO-8859-1 \
 nr_ZA/UTF-8 \
 nso_ZA/UTF-8 \
 oc_FR.UTF-8/UTF-8 \
@@ -332,6 +337,7 @@ sv_FI/ISO-8859-1 \
 sv_FI@euro/ISO-8859-15 \
 sv_SE.UTF-8/UTF-8 \
 sv_SE/ISO-8859-1 \
+sv_SE.ISO-8859-15/ISO-8859-15 \
 ta_IN/UTF-8 \
 te_IN/UTF-8 \
 tg_TJ.UTF-8/UTF-8 \
--- glibc-20070515T2025/localedata/locales/cy_GB	28 Sep 2004 04:37:33 -0000	1.4
+++ glibc-20070515T2025-fedora/localedata/locales/cy_GB	29 Sep 2004 08:48:23 -0000	1.3.2.2
@@ -248,8 +248,11 @@ mon         "<U0049><U006F><U006E><U0061
 d_t_fmt     "<U0044><U0079><U0064><U0064><U0020><U0025><U0041><U0020><U0025><U0064><U0020><U006d><U0069><U0073><U0020><U0025><U0042><U0020><U0025><U0059><U0020><U0025><U0054><U0020><U0025><U005A>"
 d_fmt       "<U0025><U0064><U002E><U0025><U006D><U002E><U0025><U0079>"
 t_fmt       "<U0025><U0054>"
-am_pm       "";""
-t_fmt_ampm  ""
+am_pm       "<U0041><U004D>";"<U0050><U004D>"
+t_fmt_ampm  "<U0025><U006C><U003A><U0025><U004D><U003A><U0025><U0053><U0020><U0025><U0050><U0020><U0025><U005A>"
+date_fmt    "<U0025><U0061><U0020><U0025><U0062><U0020><U0025><U0065>/
+<U0020><U0025><U0048><U003A><U0025><U004D><U003A><U0025><U0053><U0020>/
+<U0025><U005A><U0020><U0025><U0059>"
 END LC_TIME
 
 LC_MESSAGES
--- glibc-20070515T2025/localedata/locales/en_GB	1 Oct 2006 16:18:33 -0000	1.14
+++ glibc-20070515T2025-fedora/localedata/locales/en_GB	2 Oct 2006 19:02:41 -0000	1.10.2.4
@@ -116,8 +116,8 @@ mon         "<U004A><U0061><U006E><U0075
 d_t_fmt     "<U0025><U0061><U0020><U0025><U0064><U0020><U0025><U0062><U0020><U0025><U0059><U0020><U0025><U0054><U0020><U0025><U005A>"
 d_fmt       "<U0025><U0064><U002F><U0025><U006D><U002F><U0025><U0079>"
 t_fmt       "<U0025><U0054>"
-am_pm       "";""
-t_fmt_ampm  ""
+am_pm       "<U0041><U004D>";"<U0050><U004D>"
+t_fmt_ampm  "<U0025><U006C><U003A><U0025><U004D><U003A><U0025><U0053><U0020><U0025><U0050><U0020><U0025><U005A>"
 date_fmt	"<U0025><U0061><U0020><U0025><U0062><U0020><U0025><U0065>/
 <U0020><U0025><U0048><U003A><U0025><U004D><U003A><U0025><U0053><U0020>/
 <U0025><U005A><U0020><U0025><U0059>"
--- glibc-20070515T2025/localedata/locales/no_NO 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/localedata/locales/no_NO	22 Sep 2004 21:21:01 -0000	1.11.2.1
@@ -0,0 +1,69 @@
+escape_char	/
+comment_char    %
+
+% Norwegian language locale for Norway
+% Source: Norsk Standardiseringsforbund
+% Address: University Library,
+%   Drammensveien 41, N-9242 Oslo, Norge
+% Contact: Kolbjoern Aamboe
+% Tel: +47 - 22859109
+% Fax: +47 - 22434497
+% Email: kolbjorn.aambo@usit.uio.no
+% Language: no
+% Territory: NO
+% Revision: 4.3
+% Date: 1996-10-15
+% Application: general
+% Users: general
+% Repertoiremap: mnemonic.ds
+% Charset: ISO-8859-1
+% Distribution and use is free, also
+% for commercial purposes.
+
+LC_IDENTIFICATION
+copy "nb_NO"
+END LC_IDENTIFICATION
+
+LC_COLLATE
+copy "nb_NO"
+END LC_COLLATE
+
+LC_CTYPE
+copy "nb_NO"
+END LC_CTYPE
+
+LC_MONETARY
+copy "nb_NO"
+END LC_MONETARY
+
+LC_NUMERIC
+copy "nb_NO"
+END LC_NUMERIC
+
+LC_TIME
+copy "nb_NO"
+END LC_TIME
+
+LC_MESSAGES
+copy "nb_NO"
+END LC_MESSAGES
+
+LC_PAPER
+copy "nb_NO"
+END LC_PAPER
+
+LC_TELEPHONE
+copy "nb_NO"
+END LC_TELEPHONE
+
+LC_MEASUREMENT
+copy "nb_NO"
+END LC_MEASUREMENT
+
+LC_NAME
+copy "nb_NO"
+END LC_NAME
+
+LC_ADDRESS
+copy "nb_NO"
+END LC_ADDRESS
--- glibc-20070515T2025/localedata/locales/zh_TW	31 Oct 2004 23:42:28 -0000	1.7
+++ glibc-20070515T2025-fedora/localedata/locales/zh_TW	2 Nov 2004 12:25:57 -0000	1.5.2.2
@@ -1,7 +1,7 @@
 comment_char %
 escape_char /
 %
-% Chinese language locale for Taiwan R.O.C.
+% Chinese language locale for Taiwan
 % charmap: BIG5-CP950
 %
 % Original Author:
@@ -17,7 +17,7 @@ escape_char /
 % Reference:	http://wwwold.dkuug.dk/JTC1/SC22/WG20/docs/n690.pdf
 
 LC_IDENTIFICATION
-title      "Chinese locale for Taiwan R.O.C."
+title      "Chinese locale for Taiwan"
 source     ""
 address    ""
 contact    ""
@@ -25,7 +25,7 @@ email      "bug-glibc-locales@gnu.org"
 tel        ""
 fax        ""
 language   "Chinese"
-territory  "Taiwan R.O.C."
+territory  "Taiwan"
 revision   "0.2"
 date       "2000-08-02"
 %
--- glibc-20070515T2025/malloc/Makefile	7 May 2007 15:30:57 -0000	1.54
+++ glibc-20070515T2025-fedora/malloc/Makefile	21 May 2007 20:01:05 -0000	1.47.2.8
@@ -104,7 +104,6 @@ $(objpfx)memusagestat: $(memusagestat-mo
 include ../Rules
 
 CFLAGS-mcheck-init.c = $(PIC-ccflag)
-CFLAGS-malloc.c += -DMALLOC_DEBUG
 
 $(objpfx)libmcheck.a: $(objpfx)mcheck-init.o
 	-rm -f $@
--- glibc-20070515T2025/malloc/arena.c	13 May 2007 20:32:57 -0000	1.27
+++ glibc-20070515T2025-fedora/malloc/arena.c	21 May 2007 20:01:06 -0000	1.8.2.20
@@ -370,9 +370,6 @@ ptmalloc_init_minimal (void)
   mp_.top_pad        = DEFAULT_TOP_PAD;
 #endif
   mp_.n_mmaps_max    = DEFAULT_MMAP_MAX;
-#if MALLOC_DEBUG
-  mp_.n_mmaps_cmax   = DEFAULT_MMAP_MAX;
-#endif
   mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
   mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;
   mp_.pagesize       = malloc_getpagesize;
--- glibc-20070515T2025/malloc/hooks.c	13 May 2007 20:32:57 -0000	1.21
+++ glibc-20070515T2025-fedora/malloc/hooks.c	21 May 2007 20:01:06 -0000	1.15.2.7
@@ -496,7 +496,7 @@ free_starter(mem, caller) Void_t* mem; c
    then the hooks are reset to 0.  */
 
 #define MALLOC_STATE_MAGIC   0x444c4541l
-#define MALLOC_STATE_VERSION (0*0x100l + 2l) /* major*0x100 + minor */
+#define MALLOC_STATE_VERSION (0*0x100l + 3l) /* major*0x100 + minor */
 
 struct malloc_save_state {
   long          magic;
@@ -507,9 +507,6 @@ struct malloc_save_state {
   unsigned long trim_threshold;
   unsigned long top_pad;
   unsigned int  n_mmaps_max;
-#if MALLOC_DEBUG
-  unsigned int  n_mmaps_cmax;
-#endif
   unsigned long mmap_threshold;
   int           check_action;
   unsigned long max_sbrked_mem;
@@ -553,9 +550,6 @@ public_gET_STATe(void)
   ms->trim_threshold = mp_.trim_threshold;
   ms->top_pad = mp_.top_pad;
   ms->n_mmaps_max = mp_.n_mmaps_max;
-#if MALLOC_DEBUG
-  ms->n_mmaps_cmax = mp_.n_mmaps_cmax;
-#endif
   ms->mmap_threshold = mp_.mmap_threshold;
   ms->check_action = check_action;
   ms->max_sbrked_mem = main_arena.max_system_mem;
@@ -601,8 +595,9 @@ public_sET_STATe(Void_t* msptr)
       assert(ms->av[2*i+3] == 0);
       first(b) = last(b) = b;
     } else {
-      if(i<NSMALLBINS || (largebin_index(chunksize(ms->av[2*i+2]))==i &&
-			  largebin_index(chunksize(ms->av[2*i+3]))==i)) {
+      if(ms->version >= 3 &&
+	 (i<NSMALLBINS || (largebin_index(chunksize(ms->av[2*i+2]))==i &&
+			   largebin_index(chunksize(ms->av[2*i+3]))==i))) {
 	first(b) = ms->av[2*i+2];
 	last(b) = ms->av[2*i+3];
 	/* Make sure the links to the bins within the heap are correct.  */
@@ -622,14 +617,22 @@ public_sET_STATe(Void_t* msptr)
       }
     }
   }
+  if (ms->version < 3) {
+    /* Clear fd_nextsize and bk_nextsize fields.  */
+    b = unsorted_chunks(&main_arena)->fd;
+    while (b != unsorted_chunks(&main_arena)) {
+      if (!in_smallbin_range(chunksize(b))) {
+	b->fd_nextsize = NULL;
+	b->bk_nextsize = NULL;
+      }
+      b = b->fd;
+    }
+  }
   mp_.sbrk_base = ms->sbrk_base;
   main_arena.system_mem = ms->sbrked_mem_bytes;
   mp_.trim_threshold = ms->trim_threshold;
   mp_.top_pad = ms->top_pad;
   mp_.n_mmaps_max = ms->n_mmaps_max;
-#if MALLOC_DEBUG
-  mp_.n_mmaps_cmax = ms->n_mmaps_cmax;
-#endif
   mp_.mmap_threshold = ms->mmap_threshold;
   check_action = ms->check_action;
   main_arena.max_system_mem = ms->max_sbrked_mem;
--- glibc-20070515T2025/malloc/malloc.c	15 May 2007 01:51:17 -0000	1.178
+++ glibc-20070515T2025-fedora/malloc/malloc.c	21 May 2007 20:01:08 -0000	1.127.2.37
@@ -2358,9 +2358,6 @@ struct malloc_par {
   /* Memory map support */
   int              n_mmaps;
   int              n_mmaps_max;
-#if MALLOC_DEBUG
-  int              n_mmaps_cmax;
-#endif
   int              max_n_mmaps;
   /* the mmap_threshold is dynamic, until the user sets
      it manually, at which point we need to disable any
@@ -2572,7 +2569,7 @@ static void do_check_chunk(av, p) mstate
 #if HAVE_MMAP
     /* address is outside main heap  */
     if (contiguous(av) && av->top != initial_top(av)) {
-      assert(((char*)p) < min_address || ((char*)p) > max_address);
+      assert(((char*)p) < min_address || ((char*)p) >= max_address);
     }
     /* chunk is page-aligned */
     assert(((p->prev_size + sz) & (mp_.pagesize-1)) == 0);
@@ -2876,8 +2873,6 @@ static void do_check_malloc_state(mstate
   assert(total <= (unsigned long)(mp_.max_total_mem));
   assert(mp_.n_mmaps >= 0);
 #endif
-  assert(mp_.n_mmaps <= mp_.n_mmaps_cmax);
-  assert(mp_.n_mmaps_max <= mp_.n_mmaps_cmax);
   assert(mp_.n_mmaps <= mp_.max_n_mmaps);
 
   assert((unsigned long)(av->system_mem) <=
@@ -3475,13 +3470,6 @@ munmap_chunk(p) mchunkptr p;
     }
 
   mp_.n_mmaps--;
-#if MALLOC_DEBUG
-  if (mp_.n_mmaps_cmax > mp_.n_mmaps_max)
-    {
-      assert (mp_.n_mmaps_cmax == mp_.n_mmaps + 1);
-      mp_.n_mmaps_cmax = mp_.n_mmaps;
-    }
-#endif
   mp_.mmapped_mem -= total_size;
 
   int ret __attribute__ ((unused)) = munmap((char *)block, total_size);
@@ -5397,9 +5385,6 @@ mstate av; size_t n_elements; size_t* si
   mp_.n_mmaps_max = 0;
   mem = _int_malloc(av, size);
   mp_.n_mmaps_max = mmx;   /* reset mmap */
-#if MALLOC_DEBUG
-  mp_.n_mmaps_cmax = mmx;
-#endif
   if (mem == 0)
     return 0;
 
@@ -5725,17 +5710,8 @@ int mALLOPt(param_number, value) int par
       res = 0;
     else
 #endif
-      {
-#if MALLOC_DEBUG
-	if (mp_.n_mmaps <= value)
-	  mp_.n_mmaps_cmax = value;
-	else
-	  mp_.n_mmaps_cmax = mp_.n_mmaps;
-#endif
-
-	mp_.n_mmaps_max = value;
-	mp_.no_dyn_threshold = 1;
-      }
+      mp_.n_mmaps_max = value;
+      mp_.no_dyn_threshold = 1;
     break;
 
   case M_CHECK_ACTION:
--- glibc-20070515T2025/malloc/mcheck.c	8 Sep 2004 20:36:02 -0000	1.18
+++ glibc-20070515T2025-fedora/malloc/mcheck.c	21 May 2007 20:01:08 -0000	1.18.2.2
@@ -1,5 +1,5 @@
 /* Standard debugging hooks for `malloc'.
-   Copyright (C) 1990-1997,99,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1990-1997,1999,2000-2002,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Written May 1989 by Mike Haertel.
 
@@ -24,9 +24,25 @@
 # include <mcheck.h>
 # include <stdint.h>
 # include <stdio.h>
+# include <stdlib.h>
 # include <libintl.h>
 #endif
 
+#ifdef _LIBC
+extern __typeof (malloc) __libc_malloc;
+extern __typeof (free) __libc_free;
+extern __typeof (realloc) __libc_realloc;
+libc_hidden_proto (__libc_malloc)
+libc_hidden_proto (__libc_realloc)
+libc_hidden_proto (__libc_free)
+libc_hidden_proto (__libc_memalign)
+#else
+# define __libc_malloc(sz) malloc (sz)
+# define __libc_free(ptr) free (ptr)
+# define __libc_realloc(ptr, sz) realloc (ptr, sz)
+# define __libc_memalign(al, sz) memalign (al, sz)
+#endif
+
 /* Old hook values.  */
 static void (*old_free_hook) (__ptr_t ptr, __const __ptr_t);
 static __ptr_t (*old_malloc_hook) (__malloc_size_t size, const __ptr_t);
@@ -197,7 +213,7 @@ freehook (__ptr_t ptr, const __ptr_t cal
   if (old_free_hook != NULL)
     (*old_free_hook) (ptr, caller);
   else
-    free (ptr);
+    __libc_free (ptr);
   __free_hook = freehook;
 }
 
@@ -214,7 +230,7 @@ mallochook (__malloc_size_t size, const 
     hdr = (struct hdr *) (*old_malloc_hook) (sizeof (struct hdr) + size + 1,
 					     caller);
   else
-    hdr = (struct hdr *) malloc (sizeof (struct hdr) + size + 1);
+    hdr = (struct hdr *) __libc_malloc (sizeof (struct hdr) + size + 1);
   __malloc_hook = mallochook;
   if (hdr == NULL)
     return NULL;
@@ -245,7 +261,7 @@ memalignhook (__malloc_size_t alignment,
   if (old_memalign_hook != NULL)
     block = (*old_memalign_hook) (alignment, slop + size + 1, caller);
   else
-    block = memalign (alignment, slop + size + 1);
+    block = __libc_memalign (alignment, slop + size + 1);
   __memalign_hook = memalignhook;
   if (block == NULL)
     return NULL;
@@ -264,6 +280,12 @@ memalignhook (__malloc_size_t alignment,
 static __ptr_t
 reallochook (__ptr_t ptr, __malloc_size_t size, const __ptr_t caller)
 {
+  if (size == 0)
+    {
+      freehook (ptr, caller);
+      return NULL;
+    }
+
   struct hdr *hdr;
   __malloc_size_t osize;
 
@@ -294,8 +316,8 @@ reallochook (__ptr_t ptr, __malloc_size_
 					      sizeof (struct hdr) + size + 1,
 					      caller);
   else
-    hdr = (struct hdr *) realloc ((__ptr_t) hdr,
-				  sizeof (struct hdr) + size + 1);
+    hdr = (struct hdr *) __libc_realloc ((__ptr_t) hdr,
+					 sizeof (struct hdr) + size + 1);
   __free_hook = freehook;
   __malloc_hook = mallochook;
   __memalign_hook = memalignhook;
@@ -355,8 +377,8 @@ mcheck (func)
   if (__malloc_initialized <= 0 && !mcheck_used)
     {
       /* We call malloc() once here to ensure it is initialized.  */
-      void *p = malloc (0);
-      free (p);
+      void *p = __libc_malloc (0);
+      __libc_free (p);
 
       old_free_hook = __free_hook;
       __free_hook = freehook;
--- glibc-20070515T2025/malloc/mtrace.c	25 Jan 2007 00:43:38 -0000	1.43
+++ glibc-20070515T2025-fedora/malloc/mtrace.c	20 Dec 2005 10:59:21 -0000	1.41.2.1
@@ -40,6 +40,18 @@
 # include <libio/iolibio.h>
 # define setvbuf(s, b, f, l) INTUSE(_IO_setvbuf) (s, b, f, l)
 # define fwrite(buf, size, count, fp) _IO_fwrite (buf, size, count, fp)
+extern __typeof (malloc) __libc_malloc;
+extern __typeof (free) __libc_free;
+extern __typeof (realloc) __libc_realloc;
+libc_hidden_proto (__libc_malloc)
+libc_hidden_proto (__libc_realloc)
+libc_hidden_proto (__libc_free)
+libc_hidden_proto (__libc_memalign)
+#else
+# define __libc_malloc(sz) malloc (sz)
+# define __libc_free(ptr) free (ptr)
+# define __libc_realloc(ptr, sz) realloc (ptr, sz)
+# define __libc_memalign(al, sz) memalign (al, sz)
 #endif
 
 #ifndef attribute_hidden
@@ -154,7 +166,7 @@ tr_freehook (ptr, caller)
   if (tr_old_free_hook != NULL)
     (*tr_old_free_hook) (ptr, caller);
   else
-    free (ptr);
+    __libc_free (ptr);
   __free_hook = tr_freehook;
   __libc_lock_unlock (lock);
 }
@@ -173,7 +185,7 @@ tr_mallochook (size, caller)
   if (tr_old_malloc_hook != NULL)
     hdr = (__ptr_t) (*tr_old_malloc_hook) (size, caller);
   else
-    hdr = (__ptr_t) malloc (size);
+    hdr = (__ptr_t) __libc_malloc (size);
   __malloc_hook = tr_mallochook;
 
   tr_where (caller);
@@ -209,7 +221,7 @@ tr_reallochook (ptr, size, caller)
   if (tr_old_realloc_hook != NULL)
     hdr = (__ptr_t) (*tr_old_realloc_hook) (ptr, size, caller);
   else
-    hdr = (__ptr_t) realloc (ptr, size);
+    hdr = (__ptr_t) __libc_realloc (ptr, size);
   __free_hook = tr_freehook;
   __malloc_hook = tr_mallochook;
   __realloc_hook = tr_reallochook;
@@ -251,7 +263,7 @@ tr_memalignhook (alignment, size, caller
   if (tr_old_memalign_hook != NULL)
     hdr = (__ptr_t) (*tr_old_memalign_hook) (alignment, size, caller);
   else
-    hdr = (__ptr_t) memalign (alignment, size);
+    hdr = (__ptr_t) __libc_memalign (alignment, size);
   __memalign_hook = tr_memalignhook;
   __malloc_hook = tr_mallochook;
 
--- glibc-20070515T2025/manual/libc.texinfo	12 Nov 2003 00:37:03 -0000	1.94
+++ glibc-20070515T2025-fedora/manual/libc.texinfo	3 Nov 2006 16:31:21 -0000	1.94.2.1
@@ -5,7 +5,7 @@
 @setchapternewpage odd
 
 @comment Tell install-info what to do.
-@dircategory GNU libraries
+@dircategory Libraries
 @direntry
 * Libc: (libc).                 C library.
 @end direntry
--- glibc-20070515T2025/nis/nss	28 Apr 2006 21:02:23 -0000	1.3
+++ glibc-20070515T2025-fedora/nis/nss	1 May 2006 08:02:53 -0000	1.2.2.2
@@ -25,4 +25,4 @@
 #  memory with every getXXent() call.  Otherwise each getXXent() call
 #  might result into a network communication with the server to get
 #  the next entry.
-#SETENT_BATCH_READ=TRUE
+SETENT_BATCH_READ=TRUE
--- glibc-20070515T2025/nis/nss-default.c	28 Apr 2006 21:03:17 -0000	1.3
+++ glibc-20070515T2025-fedora/nis/nss-default.c	7 Jul 2007 21:28:55 -0000	1.1.2.4
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 2001, 2004, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 2001, 2004, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,6 +17,7 @@
    02111-1307 USA.  */
 
 #include <ctype.h>
+#include <errno.h>
 #include <stdio.h>
 #include <stdio_ext.h>
 #include <stdlib.h>
@@ -54,6 +55,7 @@ static const struct
 static void
 init (void)
 {
+  int saved_errno = errno;
   FILE *fp = fopen (default_nss, "rc");
   if (fp != NULL)
     {
@@ -111,6 +113,7 @@ init (void)
 
       fclose (fp);
     }
+  __set_errno (saved_errno);
 }
 
 
--- glibc-20070515T2025/nptl/ChangeLog	15 May 2007 06:32:02 -0000	1.970
+++ glibc-20070515T2025-fedora/nptl/ChangeLog	7 Jul 2007 17:32:36 -0000	1.706.2.130
@@ -1,3 +1,124 @@
+2007-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* pthread_getattr_np.c (pthread_getattr_np): Clear cpuset and
+	cpusetsize if pthread_getaffinity_np failed with ENOSYS.
+
+2007-05-28  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/i386/tls.h (THREAD_GSCOPE_RESET_FLAG): Use explicit
+	insn suffix.
+	(THREAD_GSCOPE_GET_FLAG): Remove.
+	* sysdeps/x86_64/tls.h (THREAD_GSCOPE_GET_FLAG): Remove.
+	* allocatestack.c (__wait_lookup_done): Revert 2007-05-24
+	changes.
+	* sysdeps/powerpc/tls.h (tcbhead_t): Remove gscope_flag.
+	(THREAD_GSCOPE_GET_FLAG): Remove.
+	(THREAD_GSCOPE_RESET_FLAG): Use THREAD_SELF->header.gscope_flag
+	instead of THREAD_GSCOPE_GET_FLAG.
+	(THREAD_GSCOPE_SET_FLAG): Likewise.  Add atomic_write_barrier after
+	it.
+	* sysdeps/s390/tls.h (THREAD_GSCOPE_FLAG_UNUSED,
+	THREAD_GSCOPE_FLAG_USED, THREAD_GSCOPE_FLAG_WAIT,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_WAIT): Define.
+	* sysdeps/sparc/tls.h (THREAD_GSCOPE_FLAG_UNUSED,
+	THREAD_GSCOPE_FLAG_USED, THREAD_GSCOPE_FLAG_WAIT,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_WAIT): Define.
+	* sysdeps/sh/tls.h (THREAD_GSCOPE_FLAG_UNUSED,
+	THREAD_GSCOPE_FLAG_USED, THREAD_GSCOPE_FLAG_WAIT,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_WAIT): Define.
+	* sysdeps/ia64/tls.h (THREAD_GSCOPE_FLAG_UNUSED,
+	THREAD_GSCOPE_FLAG_USED, THREAD_GSCOPE_FLAG_WAIT,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_WAIT): Define.
+
+2007-05-24  Richard Henderson  <rth@redhat.com>
+
+	* descr.h (struct pthread): Add header.gscope_flag.
+	* sysdeps/alpha/tls.h (THREAD_GSCOPE_FLAG_UNUSED,
+	THREAD_GSCOPE_FLAG_USED, THREAD_GSCOPE_FLAG_WAIT,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_WAIT): Define.
+
+2007-05-26  Ulrich Drepper  <drepper@redhat.com>
+
+	* allocatestack.c: Revert last change.
+	* init.c: Likewise.
+	* sysdeps/i386/tls.h: Likewise.
+	* sysdeps/x86_64/tls.h: Likewise.
+
+2007-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/powerpc/tls.h (tcbhead_t): Add gscope_flag.
+	(THREAD_GSCOPE_FLAG_UNUSED, THREAD_GSCOPE_FLAG_USED,
+	THREAD_GSCOPE_FLAG_WAIT): Define.
+	(THREAD_GSCOPE_GET_FLAG, THREAD_GSCOPE_SET_FLAG,
+	THREAD_GSCOPE_RESET_FLAG, THREAD_GSCOPE_WAIT): Define.
+	* sysdeps/i386/tls.h (THREAD_GSCOPE_WAIT): Don't use
+	PTR_DEMANGLE.
+	(THREAD_GSCOPE_GET_FLAG): Define.
+	* sysdeps/x86_64/tls.h (THREAD_GSCOPE_GET_FLAG): Define.
+	* allocatestack.c (__wait_lookup_done): Use THREAD_GSCOPE_GET_FLAG
+	instead of ->header.gscope_flag directly.
+
+2007-05-21  Ulrich Drepper  <drepper@redhat.com>
+
+	* sysdeps/pthread/pthread-functions.h (struct pthread_functions):
+	Remove ptr_wait_lookup_done again.
+	* init.c (pthread_functions): Don't add .ptr_wait_lookup_done here.
+	(__pthread_initialize_minimal_internal): Initialize
+	_dl_wait_lookup_done pointer in _rtld_global directly.
+	* sysdeps/unix/sysv/linux/libc_pthread_init.c (__libc_pthread_init):
+	Remove code to code _dl_wait_lookup_done.
+	* sysdeps/x86_64/tls.h (THREAD_GSCOPE_WAIT): The pointer is not
+	encrypted for now.
+
+2007-05-19  Ulrich Drepper  <drepper@redhat.com>
+
+	* allocatestack.c (__wait_lookup_done): New function.
+	* sysdeps/pthread/pthread-functions.h (struct pthread_functions):
+	Add ptr_wait_lookup_done.
+	* init.c (pthread_functions): Initialize .ptr_wait_lookup_done.
+	* pthreadP.h: Declare __wait_lookup_done.
+	* sysdeps/i386/tls.h (tcbhead_t): Add gscope_flag.
+	Define macros to implement reference handling of global scope.
+	* sysdeps/x86_64/tls.h: Likewise.
+	* sysdeps/unix/sysv/linux/libc_pthread_init.c (__libc_pthread_init):
+	Initialize GL(dl_wait_lookup_done).
+
+2007-05-25  Ulrich Drepper  <drepper@redhat.com>
+
+	* Makefile (tests): Add tst-sem10.
+	* tst-sem10.c: New file.
+
+2007-05-25  Ulrich Drepper  <drepper@redhat.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	* sysdeps/unix/sysv/linux/i386/i486/sem_timedwait.S (sem_timedwait):
+	Move __pthread_enable_asynccancel right before futex syscall.
+	* sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S (sem_timedwait):
+	Likewise.
+
+2007-05-21  Jakub Jelinek  <jakub@redhat.com>
+
+	* tst-robust9.c (do_test): Don't fail if ENABLE_PI and
+	pthread_mutex_init failed with ENOTSUP.
+
+2007-05-17  Ulrich Drepper  <drepper@redhat.com>
+
+	[BZ #4512]
+	* pthread_mutex_lock.c: Preserve FUTEX_WAITERS bit when dead owner
+	is detected.
+	* pthread_mutex_timedlock.c: Likewise.
+	* pthread_mutex_trylock.c: Likewise.
+	Patch in part by Atsushi Nemoto <anemo@mba.ocn.ne.jp>.
+
+	* Makefile (tests): Add tst-robust9 and tst-robustpi9.
+	* tst-robust9.c: New file.
+	* tst-robustpi9.c: New file.
+
 2007-05-14  Ulrich Drepper  <drepper@redhat.com>
 
 	* sysdeps/unix/sysv/linux/x86_64/sem_wait.S: Remove unnecessary
@@ -1474,6 +1595,15 @@
 	Use __sigfillset.  Document that sigfillset does the right thing wrt
 	to SIGSETXID.
 
+2005-08-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* tst-stackguard1.c (do_test): Likewise.
+
+2005-07-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* tst-stackguard1.c (do_test): Don't fail if the poor man's
+	randomization doesn't work well enough.
+
 2005-07-11  Jakub Jelinek  <jakub@redhat.com>
 
 	[BZ #1102]
@@ -2210,6 +2340,11 @@
 	Move definition inside libpthread, libc, librt check.  Provide
 	definition for rtld.
 
+2004-09-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* pthread_cond_destroy.c (__pthread_cond_destroy): If there are
+	waiters, awake all waiters on the associated mutex.
+
 2004-09-02  Ulrich Drepper  <drepper@redhat.com>
 
 	* sysdeps/alpha/jmpbuf-unwind.h: Define __libc_unwind_longjmp.
@@ -4284,6 +4419,11 @@
 
 	* Makefile [$(build-shared) = yes] (tests): Depend on $(test-modules).
 
+2003-07-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* descr.h: Don't include lowlevellock.h, pthreaddef.h and dl-sysdep.h
+	if __need_struct_pthread_size, instead define lll_lock_t.
+
 2003-07-25  Jakub Jelinek  <jakub@redhat.com>
 
 	* tst-cancel17.c (do_test): Check if aio_cancel failed.
--- glibc-20070515T2025/nptl/Makefile	8 Sep 2006 10:40:49 -0000	1.188
+++ glibc-20070515T2025-fedora/nptl/Makefile	7 Jul 2007 16:11:40 -0000	1.157.2.31
@@ -1,4 +1,4 @@
-# Copyright (C) 2002,2003,2004,2005,2006 Free Software Foundation, Inc.
+# Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
 # This file is part of the GNU C Library.
 
 # The GNU C Library is free software; you can redistribute it and/or
@@ -209,16 +209,16 @@ tests = tst-typesizes \
 	tst-cond14 tst-cond15 tst-cond16 tst-cond17 tst-cond18 tst-cond19 \
 	tst-cond20 tst-cond21 tst-cond22 \
 	tst-robust1 tst-robust2 tst-robust3 tst-robust4 tst-robust5 \
-	tst-robust6 tst-robust7 tst-robust8 \
-	tst-robustpi1 tst-robustpi2 tst-robustpi3 tst-robustpi4 \
-	tst-robustpi5 tst-robustpi6 tst-robustpi7 tst-robustpi8 \
+	tst-robust6 tst-robust7 tst-robust8 tst-robust9 \
+	tst-robustpi1 tst-robustpi2 tst-robustpi3 tst-robustpi4 tst-robustpi5 \
+	tst-robustpi6 tst-robustpi7 tst-robustpi8 tst-robustpi9 \
 	tst-rwlock1 tst-rwlock2 tst-rwlock3 tst-rwlock4 tst-rwlock5 \
 	tst-rwlock6 tst-rwlock7 tst-rwlock8 tst-rwlock9 tst-rwlock10 \
 	tst-rwlock11 tst-rwlock12 tst-rwlock13 tst-rwlock14 \
 	tst-once1 tst-once2 tst-once3 tst-once4 \
 	tst-key1 tst-key2 tst-key3 tst-key4 \
 	tst-sem1 tst-sem2 tst-sem3 tst-sem4 tst-sem5 tst-sem6 tst-sem7 \
-	tst-sem8 tst-sem9 \
+	tst-sem8 tst-sem9 tst-sem10 \
 	tst-barrier1 tst-barrier2 tst-barrier3 tst-barrier4 \
 	tst-align tst-align2 tst-align3 \
 	tst-basic1 tst-basic2 tst-basic3 tst-basic4 tst-basic5 tst-basic6 \
@@ -340,7 +340,8 @@ endif
 extra-objs += $(crti-objs) $(crtn-objs)
 omit-deps += crti crtn
 
-CFLAGS-pt-initfini.s = -g0 -fPIC -fno-inline-functions $(fno-unit-at-a-time)
+CFLAGS-pt-initfini.s = -g0 -fPIC -fno-inline-functions $(fno-unit-at-a-time) \
+		       -fno-asynchronous-unwind-tables
 endif
 
 CFLAGS-flockfile.c = -D_IO_MTSAFE_IO
@@ -524,15 +525,19 @@ $(addprefix $(objpfx), \
     $(tests) $(xtests) $(test-srcs))): $(objpfx)libpthread.so \
 				       $(objpfx)libpthread_nonshared.a
 $(objpfx)tst-unload: $(common-objpfx)dlfcn/libdl.so
-# $(objpfx)../libc.so is used instead of $(common-objpfx)libc.so,
+# $(objpfx)linklibc.so is used instead of $(common-objpfx)libc.so,
 # since otherwise libpthread.so comes before libc.so when linking.
 $(addprefix $(objpfx), $(tests-reverse)): \
-  $(objpfx)../libc.so $(objpfx)libpthread.so \
+  $(objpfx)linklibc.so $(objpfx)libpthread.so \
   $(objpfx)libpthread_nonshared.a
 $(objpfx)../libc.so: $(common-objpfx)libc.so ;
 $(addprefix $(objpfx),$(tests-static) $(xtests-static)): $(objpfx)libpthread.a
 
 $(objpfx)tst-atfork2.out: $(objpfx)tst-atfork2mod.so
+
+$(objpfx)linklibc.so: $(common-objpfx)libc.so
+	ln -s ../libc.so $@
+generated += libclink.so
 else
 $(addprefix $(objpfx),$(tests) $(test-srcs)): $(objpfx)libpthread.a
 endif
--- glibc-20070515T2025/nptl/allocatestack.c	7 May 2007 22:02:37 -0000	1.65
+++ glibc-20070515T2025-fedora/nptl/allocatestack.c	7 Jul 2007 17:15:06 -0000	1.51.2.14
@@ -996,3 +996,60 @@ __pthread_init_static_tls (struct link_m
 
   lll_unlock (stack_cache_lock);
 }
+
+
+void
+attribute_hidden
+__wait_lookup_done (void)
+{
+  lll_lock (stack_cache_lock);
+
+  struct pthread *self = THREAD_SELF;
+
+  /* Iterate over the list with system-allocated threads first.  */
+  list_t *runp;
+  list_for_each (runp, &stack_used)
+    {
+      struct pthread *t = list_entry (runp, struct pthread, list);
+      if (t == self || t->header.gscope_flag == THREAD_GSCOPE_FLAG_UNUSED)
+	continue;
+
+      int *const gscope_flagp = &t->header.gscope_flag;
+
+      /* We have to wait until this thread is done with the global
+	 scope.  First tell the thread that we are waiting and
+	 possibly have to be woken.  */
+      if (atomic_compare_and_exchange_bool_acq (gscope_flagp,
+						THREAD_GSCOPE_FLAG_WAIT,
+						THREAD_GSCOPE_FLAG_USED))
+	continue;
+
+      do
+	lll_futex_wait (gscope_flagp, THREAD_GSCOPE_FLAG_WAIT);
+      while (*gscope_flagp == THREAD_GSCOPE_FLAG_WAIT);
+    }
+
+  /* Now the list with threads using user-allocated stacks.  */
+  list_for_each (runp, &__stack_user)
+    {
+      struct pthread *t = list_entry (runp, struct pthread, list);
+      if (t == self || t->header.gscope_flag == THREAD_GSCOPE_FLAG_UNUSED)
+	continue;
+
+      int *const gscope_flagp = &t->header.gscope_flag;
+
+      /* We have to wait until this thread is done with the global
+	 scope.  First tell the thread that we are waiting and
+	 possibly have to be woken.  */
+      if (atomic_compare_and_exchange_bool_acq (gscope_flagp,
+						THREAD_GSCOPE_FLAG_WAIT,
+						THREAD_GSCOPE_FLAG_USED))
+	continue;
+
+      do
+	lll_futex_wait (gscope_flagp, THREAD_GSCOPE_FLAG_WAIT);
+      while (*gscope_flagp == THREAD_GSCOPE_FLAG_WAIT);
+    }
+
+  lll_unlock (stack_cache_lock);
+}
--- glibc-20070515T2025/nptl/descr.h	11 May 2007 06:11:48 -0000	1.39
+++ glibc-20070515T2025-fedora/nptl/descr.h	7 Jul 2007 17:15:06 -0000	1.23.2.19
@@ -131,6 +131,7 @@ struct pthread
     struct
     {
       int multiple_threads;
+      int gscope_flag;
     } header;
 #endif
 
--- glibc-20070515T2025/nptl/init.c	27 Oct 2006 23:11:43 -0000	1.60
+++ glibc-20070515T2025-fedora/nptl/init.c	7 Jul 2007 21:28:55 -0000	1.49.2.13
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -386,6 +386,8 @@ __pthread_initialize_minimal_internal (v
 
   GL(dl_init_static_tls) = &__pthread_init_static_tls;
 
+  GL(dl_wait_lookup_done) = &__wait_lookup_done;
+
   /* Register the fork generation counter with the libc.  */
 #ifndef TLS_MULTIPLE_THREADS_IN_TCB
   __libc_multiple_threads_ptr =
--- glibc-20070515T2025/nptl/pthreadP.h	23 Aug 2006 17:42:52 -0000	1.64
+++ glibc-20070515T2025-fedora/nptl/pthreadP.h	7 Jul 2007 21:28:55 -0000	1.54.2.12
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -545,6 +545,8 @@ extern int __nptl_setxid (struct xid_com
 
 extern void __free_stack_cache (void) attribute_hidden;
 
+extern void __wait_lookup_done (void) attribute_hidden;
+
 #ifdef SHARED
 # define PTHREAD_STATIC_FN_REQUIRE(name)
 #else
--- glibc-20070515T2025/nptl/pthread_getattr_np.c	7 Apr 2006 04:26:42 -0000	1.12
+++ glibc-20070515T2025-fedora/nptl/pthread_getattr_np.c	7 Jul 2007 21:28:55 -0000	1.11.2.3
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -168,8 +168,12 @@ pthread_getattr_np (thread_id, attr)
 	{
 	  free (cpuset);
 	  if (ret == ENOSYS)
-	    /* There is no such functionality.  */
-	    ret = 0;
+	    {	  
+	      /* There is no such functionality.  */
+	      ret = 0;
+	      iattr->cpuset = NULL;
+	      iattr->cpusetsize = 0;
+	    }
 	}
     }
 
--- glibc-20070515T2025/nptl/pthread_mutex_lock.c	14 Aug 2006 23:01:26 -0000	1.15
+++ glibc-20070515T2025-fedora/nptl/pthread_mutex_lock.c	21 May 2007 20:01:11 -0000	1.8.2.7
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -127,6 +127,8 @@ __pthread_mutex_lock (mutex)
 	      int newval = id;
 #ifdef NO_INCR
 	      newval |= FUTEX_WAITERS;
+#else
+	      newval |= (oldval & FUTEX_WAITERS);
 #endif
 
 	      newval
--- glibc-20070515T2025/nptl/pthread_mutex_timedlock.c	14 Aug 2006 23:01:26 -0000	1.11
+++ glibc-20070515T2025-fedora/nptl/pthread_mutex_timedlock.c	21 May 2007 20:01:11 -0000	1.4.2.7
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -119,9 +119,11 @@ pthread_mutex_timedlock (mutex, abstime)
 	  if ((oldval & FUTEX_OWNER_DIED) != 0)
 	    {
 	      /* The previous owner died.  Try locking the mutex.  */
-	      int newval
+	      int newval = id | (oldval & FUTEX_WAITERS);
+
+	      newval
 		= atomic_compare_and_exchange_val_acq (&mutex->__data.__lock,
-						       id, oldval);
+						       newval, oldval);
 	      if (newval != oldval)
 		{
 		  oldval = newval;
--- glibc-20070515T2025/nptl/pthread_mutex_trylock.c	28 Apr 2007 04:23:43 -0000	1.13
+++ glibc-20070515T2025-fedora/nptl/pthread_mutex_trylock.c	21 May 2007 20:01:11 -0000	1.5.2.7
@@ -84,9 +84,11 @@ __pthread_mutex_trylock (mutex)
 	  if ((oldval & FUTEX_OWNER_DIED) != 0)
 	    {
 	      /* The previous owner died.  Try locking the mutex.  */
-	      int newval
+	      int newval = id | (oldval & FUTEX_WAITERS);
+
+	      newval
 		= atomic_compare_and_exchange_val_acq (&mutex->__data.__lock,
-						       id, oldval);
+						       newval, oldval);
 
 	      if (newval != oldval)
 		{
--- glibc-20070515T2025/nptl/tst-robust9.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/nptl/tst-robust9.c	7 Jul 2007 16:03:57 -0000	1.1.2.2
@@ -0,0 +1,94 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+
+static pthread_mutex_t m;
+
+static void *
+tf (void *data)
+{
+  int err = pthread_mutex_lock (&m);
+  if (err == EOWNERDEAD)
+    {
+      err = pthread_mutex_consistent_np (&m);
+      if (err)
+	{
+	  puts ("pthread_mutex_consistent_np");
+	  exit (1);
+	}
+    }
+  else if (err)
+    {
+      puts ("pthread_mutex_lock");
+      exit (1);
+    }
+  printf ("thread%ld got the lock.\n", (long int) data);
+  sleep (1);
+  /* exit without unlock */
+  return NULL;
+}
+
+static int
+do_test (void)
+{
+  int err, i;
+  pthread_t t[3];
+  pthread_mutexattr_t ma;
+
+  pthread_mutexattr_init (&ma);
+  err = pthread_mutexattr_setrobust_np (&ma, PTHREAD_MUTEX_ROBUST_NP);
+  if (err)
+    {
+      puts ("pthread_mutexattr_setrobust_np");
+      return 1;
+    }
+#ifdef ENABLE_PI
+  if (pthread_mutexattr_setprotocol (&ma, PTHREAD_PRIO_INHERIT) != 0)
+    {
+      puts ("pthread_mutexattr_setprotocol failed");
+      return 1;
+    }
+#endif
+  err = pthread_mutex_init (&m, &ma);
+#ifdef ENABLE_PI
+  if (err == ENOTSUP)
+    {
+      puts ("PI robust mutexes not supported");
+      return 0;
+    }
+#endif
+  if (err)
+    {
+      puts ("pthread_mutex_init");
+      return 1;
+    }
+
+  for (i = 0; i < sizeof (t) / sizeof (t[0]); i++)
+    {
+      err = pthread_create (&t[i], NULL, tf, (void *) (long int) i);
+      if (err)
+	{
+	  puts ("pthread_create");
+	  return 1;
+	}
+    }
+
+  for (i = 0; i < sizeof (t) / sizeof (t[0]); i++)
+    {
+      err = pthread_join (t[i], NULL);
+      if (err)
+	{
+	  puts ("pthread_join");
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+#define TIMEOUT 5
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
--- glibc-20070515T2025/nptl/tst-robustpi9.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/nptl/tst-robustpi9.c	21 May 2007 20:01:11 -0000	1.1.2.1
@@ -0,0 +1,2 @@
+#define ENABLE_PI 1
+#include "tst-robust9.c"
--- glibc-20070515T2025/nptl/tst-sem10.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/nptl/tst-sem10.c	7 Jul 2007 16:11:40 -0000	1.1.2.1
@@ -0,0 +1,88 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2007.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <stdio.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+
+static int
+do_test (void)
+{
+  sem_t s;
+  if (sem_init (&s, 0, 0) == -1)
+    {
+      puts ("sem_init failed");
+      return 1;
+    }
+
+  struct timeval tv;
+  if (gettimeofday (&tv, NULL) != 0)
+    {
+      puts ("gettimeofday failed");
+      return 1;
+    }
+
+  struct timespec ts;
+  TIMEVAL_TO_TIMESPEC (&tv, &ts);
+
+  /* Set ts to yesterday.  */
+  ts.tv_sec -= 86400;
+
+  int type_before;
+  if (pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED, &type_before) != 0)
+    {
+      puts ("first pthread_setcanceltype failed");
+      return 1;
+    }
+
+  errno = 0;
+  if (TEMP_FAILURE_RETRY (sem_timedwait (&s, &ts)) != -1)
+    {
+      puts ("sem_timedwait succeeded");
+      return 1;
+    }
+  if (errno != ETIMEDOUT)
+    {
+      printf ("sem_timedwait return errno = %d instead of ETIMEDOUT\n",
+	      errno);
+      return 1;
+    }
+
+  int type_after;
+  if (pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED, &type_after) != 0)
+    {
+      puts ("second pthread_setcanceltype failed");
+      return 1;
+    }
+  if (type_after != PTHREAD_CANCEL_DEFERRED)
+    {
+      puts ("sem_timedwait changed cancellation type");
+      return 1;
+    }
+
+  return 0;
+}
+
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
--- glibc-20070515T2025/nptl/tst-stackguard1.c	26 Jun 2005 17:44:14 -0000	1.1
+++ glibc-20070515T2025-fedora/nptl/tst-stackguard1.c	8 Aug 2005 21:24:28 -0000	1.1.2.3
@@ -190,17 +190,21 @@ do_test (void)
      the 16 runs, something is very wrong.  */
   int ndifferences = 0;
   int ndefaults = 0;
+  int npartlyrandomized = 0;
   for (i = 0; i < N; ++i) 
     {
       if (child_stack_chk_guards[i] != child_stack_chk_guards[i+1])
 	ndifferences++;
       else if (child_stack_chk_guards[i] == default_guard)
 	ndefaults++;
+      else if (*(char *) &child_stack_chk_guards[i] == 0)
+	npartlyrandomized++;
     }
 
-  printf ("differences %d defaults %d\n", ndifferences, ndefaults);
+  printf ("differences %d defaults %d partly randomized %d\n",
+	  ndifferences, ndefaults, npartlyrandomized);
 
-  if (ndifferences < N / 2 && ndefaults < N / 2)
+  if ((ndifferences + ndefaults + npartlyrandomized) < 3 * N / 4)
     {
       puts ("stack guard canaries are not randomized enough");
       puts ("nor equal to the default canary value");
--- glibc-20070515T2025/nptl/sysdeps/alpha/tls.h	27 Oct 2006 23:11:43 -0000	1.7
+++ glibc-20070515T2025-fedora/nptl/sysdeps/alpha/tls.h	7 Jul 2007 21:28:55 -0000	1.4.2.5
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  NPTL/Alpha version.
-   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -121,6 +121,29 @@ typedef struct
 #define THREAD_SETMEM_NC(descr, member, idx, value) \
   descr->member[idx] = (value)
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/i386/tls.h	27 Oct 2006 23:11:43 -0000	1.33
+++ glibc-20070515T2025-fedora/nptl/sysdeps/i386/tls.h	7 Jul 2007 21:28:55 -0000	1.26.2.9
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  nptl/i386 version.
-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -51,6 +51,7 @@ typedef struct
   uintptr_t sysinfo;
   uintptr_t stack_guard;
   uintptr_t pointer_guard;
+  int gscope_flag;
 } tcbhead_t;
 
 # define TLS_MULTIPLE_THREADS_IN_TCB 1
@@ -431,6 +432,26 @@ union user_desc_init
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
 
 
+/* Get and set the global scope generation counter in the TCB head.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									      \
+    { int __res;							      \
+      asm volatile ("xchgl %0, %%gs:%P1"				      \
+		    : "=r" (__res)					      \
+		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
+		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		      \
+    }									      \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  THREAD_SETMEM (THREAD_SELF, header.gscope_flag, THREAD_GSCOPE_FLAG_USED)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/ia64/tls.h	27 Oct 2006 23:11:43 -0000	1.12
+++ glibc-20070515T2025-fedora/nptl/sysdeps/ia64/tls.h	7 Jul 2007 21:28:55 -0000	1.7.2.7
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  nptl/IA-64 version.
-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -163,6 +163,29 @@ register struct pthread *__thread_self _
   (((uintptr_t *) ((char *) (descr) + TLS_PRE_TCB_SIZE))[-2] \
    = THREAD_GET_POINTER_GUARD ())
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/powerpc/tls.h	27 Oct 2006 23:11:43 -0000	1.12
+++ glibc-20070515T2025-fedora/nptl/sysdeps/powerpc/tls.h	7 Jul 2007 21:28:55 -0000	1.8.2.6
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  NPTL/PowerPC version.
-   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -180,6 +180,29 @@ register void *__thread_register __asm__
    different value to mean unset l_tls_offset.  */
 # define NO_TLS_OFFSET		-1
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/s390/tls.h	27 Oct 2006 23:11:44 -0000	1.15
+++ glibc-20070515T2025-fedora/nptl/sysdeps/s390/tls.h	7 Jul 2007 21:28:55 -0000	1.10.2.7
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  NPTL/s390 version.
-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -50,6 +50,7 @@ typedef struct
   int multiple_threads;
   uintptr_t sysinfo;
   uintptr_t stack_guard;
+  int gscope_flag;
 } tcbhead_t;
 
 # ifndef __s390x__
@@ -168,6 +169,29 @@ typedef struct
 #define THREAD_SET_POINTER_GUARD(value)
 #define THREAD_COPY_POINTER_GUARD(descr)
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/sh/tls.h	27 Oct 2006 23:11:44 -0000	1.11
+++ glibc-20070515T2025-fedora/nptl/sysdeps/sh/tls.h	7 Jul 2007 21:28:55 -0000	1.7.2.6
@@ -1,5 +1,5 @@
 /* Definition for thread-local data handling.  NPTL/SH version.
-   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -150,6 +150,29 @@ typedef struct
      __asm __volatile ("stc gbr,%0" : "=r" (__tcbp));			      \
      ((tcbhead_t *) (descr + 1))->pointer_guard	= __tcbp->pointer_guard;})
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/sparc/tls.h	27 Oct 2006 23:11:44 -0000	1.8
+++ glibc-20070515T2025-fedora/nptl/sysdeps/sparc/tls.h	7 Jul 2007 21:28:56 -0000	1.3.2.7
@@ -1,5 +1,5 @@
 /* Definitions for thread-local data handling.  NPTL/sparc version.
-   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -141,6 +141,29 @@ register struct pthread *__thread_self _
 # define THREAD_COPY_POINTER_GUARD(descr) \
   ((descr)->header.pointer_guard = THREAD_GET_POINTER_GUARD ())
 
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* !ASSEMBLER */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nptl/sysdeps/unix/sysv/linux/kernel-features.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/nptl/sysdeps/unix/sysv/linux/kernel-features.h	22 Sep 2004 21:21:02 -0000	1.1.2.1
@@ -0,0 +1,6 @@
+#include_next <kernel-features.h>
+
+/* NPTL can always assume all clone thread flags work.  */
+#ifndef __ASSUME_CLONE_THREAD_FLAGS
+# define __ASSUME_CLONE_THREAD_FLAGS	1
+#endif
--- glibc-20070515T2025/nptl/sysdeps/unix/sysv/linux/i386/i486/sem_timedwait.S	9 Apr 2006 02:42:29 -0000	1.8
+++ glibc-20070515T2025-fedora/nptl/sysdeps/unix/sysv/linux/i386/i486/sem_timedwait.S	7 Jul 2007 21:28:56 -0000	1.6.2.4
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -79,10 +79,7 @@ sem_timedwait:
 	jae	6f
 
 	cfi_offset(3, -16)		/* %ebx */
-7:	call	__pthread_enable_asynccancel
-	movl	%eax, 8(%esp)
-
-	xorl	%ecx, %ecx
+7:	xorl	%ecx, %ecx
 	movl	%esp, %ebx
 	movl	%ecx, %edx
 	movl	$SYS_gettimeofday, %eax
@@ -105,6 +102,10 @@ sem_timedwait:
 
 	movl	%ecx, (%esp)	/* Store relative timeout.  */
 	movl	%edx, 4(%esp)
+
+	call	__pthread_enable_asynccancel
+	movl	%eax, 8(%esp)
+
 	movl	28(%esp), %ebx
 	xorl	%ecx, %ecx
 	movl	%esp, %esi
--- glibc-20070515T2025/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S	15 May 2007 06:24:23 -0000	1.11
+++ glibc-20070515T2025-fedora/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S	7 Jul 2007 16:11:40 -0000	1.9.2.3
@@ -73,10 +73,7 @@ sem_timedwait:
 	cfi_offset(14, -24)		/* %r14 */
 	jae	6f
 
-7:	call	__pthread_enable_asynccancel
-	movl	%eax, 16(%rsp)
-
-	xorl	%esi, %esi
+7:	xorl	%esi, %esi
 	movq	%rsp, %rdi
 	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
 	callq	*%rax
@@ -99,6 +96,9 @@ sem_timedwait:
 	movq	%rdi, (%rsp)	/* Store relative timeout.  */
 	movq	%rsi, 8(%rsp)
 
+	call	__pthread_enable_asynccancel
+	movl	%eax, 16(%rsp)
+
 	movq	%rsp, %r10
 	movq	%r12, %rdi
 	xorl	%esi, %esi
--- glibc-20070515T2025/nptl/sysdeps/x86_64/tls.h	26 Apr 2007 04:44:47 -0000	1.28
+++ glibc-20070515T2025-fedora/nptl/sysdeps/x86_64/tls.h	7 Jul 2007 17:15:07 -0000	1.21.2.8
@@ -47,6 +47,7 @@ typedef struct
   dtv_t *dtv;
   void *self;		/* Pointer to the thread descriptor.  */
   int multiple_threads;
+  int gscope_flag;
   uintptr_t sysinfo;
   uintptr_t stack_guard;
   uintptr_t pointer_guard;
@@ -337,6 +338,26 @@ typedef struct
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
 
 
+/* Get and set the global scope generation counter in the TCB head.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									      \
+    { int __res;							      \
+      asm volatile ("xchgl %0, %%fs:%P1"				      \
+		    : "=r" (__res)					      \
+		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
+		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1);		      \
+    }									      \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  THREAD_SETMEM (THREAD_SELF, header.gscope_flag, THREAD_GSCOPE_FLAG_USED)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
--- glibc-20070515T2025/nscd/connections.c	1 Feb 2007 16:05:31 -0000	1.98
+++ glibc-20070515T2025-fedora/nscd/connections.c	10 May 2007 17:07:30 -0000	1.55.2.29
@@ -68,6 +68,7 @@ static gid_t *server_groups;
 # define NGROUPS 32
 #endif
 static int server_ngroups;
+static volatile int sighup_pending;
 
 static pthread_attr_t attr;
 
@@ -1363,6 +1364,10 @@ nscd_run (void *p)
 	      if (readylist == NULL && to == ETIMEDOUT)
 		{
 		  --nready;
+
+		  if (sighup_pending)
+		    goto sighup_prune;
+
 		  pthread_mutex_unlock (&readylist_lock);
 		  goto only_prune;
 		}
@@ -1372,6 +1377,34 @@ nscd_run (void *p)
 	    pthread_cond_wait (&readylist_cond, &readylist_lock);
 	}
 
+      if (sighup_pending)
+	{
+	  --nready;
+	  pthread_cond_signal (&readylist_cond);
+	sighup_prune:
+	  sighup_pending = 0;
+	  pthread_mutex_unlock (&readylist_lock);
+
+	  /* Prune the password database.  */
+	  if (dbs[pwddb].enabled)
+	    prune_cache (&dbs[pwddb], LONG_MAX, -1);
+
+	  /* Prune the group database.  */
+	  if (dbs[grpdb].enabled)
+	    prune_cache (&dbs[grpdb], LONG_MAX, -1);
+
+	  /* Prune the host database.  */
+	  if (dbs[hstdb].enabled)
+	    prune_cache (&dbs[hstdb], LONG_MAX, -1);
+
+	  /* Re-locking.  */
+	  pthread_mutex_lock (&readylist_lock);
+
+	  /* One more thread available.  */
+	  ++nready;
+	  continue;
+	}
+
       struct fdlist *it = readylist->next;
       if (readylist->next == readylist)
 	/* Just one entry on the list.  */
@@ -1947,3 +1980,10 @@ finish_drop_privileges (void)
   install_real_capabilities (new_caps);
 #endif
 }
+
+/* Handle the HUP signal which will force a dump of the cache */
+void
+sighup_handler (int signum)
+{
+  sighup_pending = 1;
+}
--- glibc-20070515T2025/nscd/nscd.c	16 Feb 2007 19:14:58 -0000	1.57
+++ glibc-20070515T2025-fedora/nscd/nscd.c	21 Feb 2007 11:15:53 -0000	1.38.2.16
@@ -119,6 +119,9 @@ static struct argp argp =
   options, parse_opt, NULL, doc,
 };
 
+/* The SIGHUP handler is extern to this file */
+extern void sighup_handler(int signum);
+
 /* True if only statistics are requested.  */
 static bool get_stats;
 
@@ -263,6 +266,7 @@ main (int argc, char **argv)
   signal (SIGINT, termination_handler);
   signal (SIGQUIT, termination_handler);
   signal (SIGTERM, termination_handler);
+  signal (SIGHUP, sighup_handler);
   signal (SIGPIPE, SIG_IGN);
 
   /* Cleanup files created by a previous 'bind'.  */
--- glibc-20070515T2025/nscd/nscd.conf	14 Jan 2007 05:24:04 -0000	1.14
+++ glibc-20070515T2025-fedora/nscd/nscd.conf	17 Jan 2007 10:42:40 -0000	1.8.2.6
@@ -33,8 +33,8 @@
 #	logfile			/var/log/nscd.log
 #	threads			6
 #	max-threads		128
-#	server-user		nobody
-#	stat-user		somebody
+	server-user		nscd
+#	stat-user		nocpulse
 	debug-level		0
 #	reload-count		5
 	paranoia		no
--- glibc-20070515T2025/nscd/nscd.init	1 Dec 2006 20:12:45 -0000	1.10
+++ glibc-20070515T2025-fedora/nscd/nscd.init	5 Dec 2006 21:50:20 -0000	1.6.2.5
@@ -9,6 +9,7 @@
 #		slow naming services like NIS, NIS+, LDAP, or hesiod.
 # processname: /usr/sbin/nscd
 # config: /etc/nscd.conf
+# config: /etc/sysconfig/nscd
 #
 ### BEGIN INIT INFO
 # Provides: nscd
@@ -28,20 +29,8 @@
 # Source function library.
 . /etc/init.d/functions
 
-# nscd does not run on any kernel lower than 2.2.0 because of threading
-# problems, so we require that in first place.
-case $(uname -r) in
-    2.[2-9].*)
-	# this is okay
-	;;
-    [3-9]*)
-	# these are of course also okay
-	;;
-    *)
-	#this is not
-	exit 1
-	;;
-esac
+# Source an auxiliary options file if we have one, and pick up NSCD_OPTIONS.
+[ -r /etc/sysconfig/nscd ] && . /etc/sysconfig/nscd
 
 RETVAL=0
 prog=nscd
@@ -50,7 +39,7 @@ start () {
     [ -d /var/run/nscd ] || mkdir /var/run/nscd
     [ -d /var/db/nscd ] || mkdir /var/db/nscd
     echo -n $"Starting $prog: "
-    daemon /usr/sbin/nscd
+    daemon /usr/sbin/nscd $NSCD_OPTIONS
     RETVAL=$?
     echo
     [ $RETVAL -eq 0 ] && touch /var/lock/subsys/nscd
--- glibc-20070515T2025/nscd/nscd_helper.c	16 Feb 2007 06:34:19 -0000	1.22
+++ glibc-20070515T2025-fedora/nscd/nscd_helper.c	7 Jul 2007 16:15:16 -0000	1.6.2.14
@@ -269,11 +269,12 @@ get_mapping (request_type type, const ch
 			!= keylen, 0))
     goto out_close2;
 
-  mapfd = *(int *) CMSG_DATA (cmsg);
+  if (__builtin_expect (CMSG_FIRSTHDR (&msg) == NULL
+			|| (CMSG_FIRSTHDR (&msg)->cmsg_len
+			    != CMSG_LEN (sizeof (int))), 0))
+    goto out_close2;
 
-  if (__builtin_expect (CMSG_FIRSTHDR (&msg)->cmsg_len
-			!= CMSG_LEN (sizeof (int)), 0))
-    goto out_close;
+  mapfd = *(int *) CMSG_DATA (cmsg);
 
   struct stat64 st;
   if (__builtin_expect (strcmp (resdata, key) != 0, 0)
--- glibc-20070515T2025/posix/Makefile	3 Apr 2007 23:28:20 -0000	1.197
+++ glibc-20070515T2025-fedora/posix/Makefile	16 Apr 2007 23:59:05 -0000	1.171.2.24
@@ -110,7 +110,7 @@ generated := $(addprefix wordexp-test-re
 	     tst-rxspencer-mem tst-rxspencer.mtrace tst-getconf.out \
 	     tst-pcre-mem tst-pcre.mtrace tst-boost-mem tst-boost.mtrace \
 	     bug-ga2.mtrace bug-ga2-mem bug-glob2.mtrace bug-glob2-mem \
-	     tst-vfork3-mem tst-vfork3.mtrace
+	     tst-vfork3-mem tst-vfork3.mtrace getconf.speclist
 
 include ../Rules
 
@@ -291,12 +291,16 @@ bug-glob2-ENV = MALLOC_TRACE=$(objpfx)bu
 $(objpfx)bug-glob2-mem: $(objpfx)bug-glob2.out
 	$(common-objpfx)malloc/mtrace $(objpfx)bug-glob2.mtrace > $@
 
-$(inst_libexecdir)/getconf: $(objpfx)getconf FORCE
+$(inst_libexecdir)/getconf: $(objpfx)getconf $(objpfx)getconf.speclist FORCE
 	$(addprefix $(..)./scripts/mkinstalldirs ,\
 		    $(filter-out $(wildcard $@),$@))
-	for spec in `LC_ALL=C GETCONF_DIR=/dev/null \
-		     $(run-program-prefix) $< \
-		     _POSIX_V6_WIDTH_RESTRICTED_ENVS`; do \
-		$(INSTALL_PROGRAM) $< $@/$$spec.new; \
-		mv -f $@/$$spec.new $@/$$spec; \
+	for spec in `cat $(objpfx)getconf.speclist`; do \
+	  $(INSTALL_PROGRAM) $< $@/$$spec.new; \
+	  mv -f $@/$$spec.new $@/$$spec; \
 	done
+
+$(objpfx)getconf.speclist: getconf.speclist.h
+	$(CC) -E $(CFLAGS) $(CPPFLAGS) $< \
+	  | sed -n -e '/START_OF_STRINGS/,$${/POSIX_V6_/{s/^[^"]*"//;s/".*$$//;p}}' \
+	  > $@.new
+	mv -f $@.new $@
--- glibc-20070515T2025/posix/getconf.speclist.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/posix/getconf.speclist.h	13 Dec 2004 23:32:37 -0000	1.1.2.2
@@ -0,0 +1,15 @@
+#include <unistd.h>
+const char *START_OF_STRINGS =
+#if _POSIX_V6_ILP32_OFF32 == 1
+"POSIX_V6_ILP32_OFF32"
+#endif
+#if _POSIX_V6_ILP32_OFFBIG == 1
+"POSIX_V6_ILP32_OFFBIG"
+#endif
+#if _POSIX_V6_LP64_OFF64 == 1
+"POSIX_V6_LP64_OFF64"
+#endif
+#if _POSIX_V6_LPBIG_OFFBIG == 1
+"POSIX_V6_LPBIG_OFFBIG"
+#endif
+"";
--- glibc-20070515T2025/rt/tst-shm.c	2 Apr 2002 23:51:07 -0000	1.5
+++ glibc-20070515T2025-fedora/rt/tst-shm.c	21 May 2007 20:01:11 -0000	1.5.2.1
@@ -60,7 +60,7 @@ static void
 worker (int write_now)
 {
   struct timespec ts;
-  struct stat st;
+  struct stat64 st;
   int i;
   int fd = do_open ();
   char *mem;
@@ -68,8 +68,10 @@ worker (int write_now)
   if (fd == -1)
     exit (fd);
 
-  if (fstat (fd, &st) == -1 || st.st_size != 4000)
+  if (fstat64 (fd, &st) == -1)
     error (EXIT_FAILURE, 0, "stat failed");
+  if (st.st_size != 4000)
+    error (EXIT_FAILURE, 0, "size incorrect");
 
   mem = mmap (NULL, 4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
   if (mem == NULL)
@@ -131,7 +133,7 @@ do_test (void)
   pid_t pid2;
   int status1;
   int status2;
-  struct stat st;
+  struct stat64 st;
 
   /* Create the shared memory object.  */
   fd = shm_open ("/shm-test", O_RDWR | O_CREAT | O_TRUNC | O_EXCL, 0600);
@@ -155,11 +157,16 @@ do_test (void)
       return 0;
     }
 
-  if (fstat (fd, &st) == -1 || st.st_size != 4000)
+  if (fstat64 (fd, &st) == -1)
     {
       shm_unlink ("/shm-test");
       error (EXIT_FAILURE, 0, "initial stat failed");
     }
+  if (st.st_size != 4000)
+    {
+      shm_unlink ("/shm-test");
+      error (EXIT_FAILURE, 0, "initial size not correct");
+    }
 
   /* Spawn to processes which will do the work.  */
   pid1 = fork ();
--- glibc-20070515T2025/stdio-common/Makefile	18 Feb 2007 08:25:39 -0000	1.100
+++ glibc-20070515T2025-fedora/stdio-common/Makefile	8 Jul 2007 10:08:25 -0000	1.90.2.11
@@ -54,7 +54,8 @@ tests := tstscanf test_rdwr test-popen t
 	 tst-swprintf tst-fseek tst-fmemopen test-vfprintf tst-gets \
 	 tst-perror tst-sprintf tst-rndseek tst-fdopen tst-fphex bug14 bug15 \
 	 tst-popen tst-unlockedio tst-fmemopen2 tst-put-error tst-fgets \
-	 tst-fwrite bug16 bug17 tst-swscanf
+	 tst-fwrite bug16 bug17 tst-swscanf tst-sprintf2 bug18 bug18a \
+	 bug19 bug19a
 
 test-srcs = tst-unbputc tst-printf
 
--- glibc-20070515T2025/stdio-common/bug18.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/stdio-common/bug18.c	8 Jul 2007 10:08:25 -0000	1.2.2.1
@@ -0,0 +1,48 @@
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+
+#ifndef CHAR
+# define CHAR char
+# define L(str) str
+# define SSCANF sscanf
+#endif
+
+
+static int
+do_test (void)
+{
+  printf("setting errno to EINTR\n");
+  errno = EINTR;
+
+  printf("checking sscanf\n");
+
+  CHAR str[] = L("7-11");
+  int i, j, n;
+
+  i = j = n = 0;
+  SSCANF (str, L(" %i - %i %n"), &i, &j, &n);
+  printf ("found %i-%i (length=%i)\n", i, j, n);
+
+  int result = 0;
+  if (i != 7)
+    {
+      printf ("i is %d, expected 7\n", i);
+      result = 1;
+    }
+  if (j != 11)
+    {
+      printf ("j is %d, expected 11\n", j);
+      result = 1;
+    }
+  if (n != 4)
+    {
+      printf ("n is %d, expected 4\n", j);
+      result = 1;
+    }
+
+  return result;
+}
+
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
--- glibc-20070515T2025/stdio-common/bug18a.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/stdio-common/bug18a.c	8 Jul 2007 10:08:25 -0000	1.1.2.1
@@ -0,0 +1,6 @@
+#include <wchar.h>
+#define CHAR wchar_t
+#define L(str) L##str
+#define SSCANF swscanf
+
+#include "bug18.c"
--- glibc-20070515T2025/stdio-common/bug19.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/stdio-common/bug19.c	8 Jul 2007 10:08:25 -0000	1.1.2.1
@@ -0,0 +1,58 @@
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+
+#ifndef CHAR
+# define CHAR char
+# define L(str) str
+# define FPUTS fputs
+# define FSCANF fscanf
+#endif
+
+
+static int
+do_test (void)
+{
+  FILE *fp = tmpfile ();
+  if (fp == NULL)
+    {
+      puts ("cannot open file");
+      return 1;
+    }
+
+  FPUTS (L("7-11"), fp);
+  rewind (fp);
+
+  printf("setting errno to EINTR\n");
+  errno = EINTR;
+
+  printf("checking sscanf\n");
+
+  int i, j, n;
+
+  i = j = n = 0;
+  FSCANF (fp, L(" %i - %i %n"), &i, &j, &n);
+  printf ("found %i-%i (length=%i)\n", i, j, n);
+
+  int result = 0;
+  if (i != 7)
+    {
+      printf ("i is %d, expected 7\n", i);
+      result = 1;
+    }
+  if (j != 11)
+    {
+      printf ("j is %d, expected 11\n", j);
+      result = 1;
+    }
+  if (n != 4)
+    {
+      printf ("n is %d, expected 4\n", j);
+      result = 1;
+    }
+
+  return result;
+}
+
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
--- glibc-20070515T2025/stdio-common/bug19a.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/stdio-common/bug19a.c	8 Jul 2007 10:08:25 -0000	1.1.2.1
@@ -0,0 +1,7 @@
+#include <wchar.h>
+#define CHAR wchar_t
+#define L(str) L##str
+#define FPUTS fputws
+#define FSCANF fwscanf
+
+#include "bug19.c"
--- glibc-20070515T2025/stdio-common/tst-sprintf.c	25 Jun 2003 11:04:49 -0000	1.3
+++ glibc-20070515T2025-fedora/stdio-common/tst-sprintf.c	21 May 2007 20:01:11 -0000	1.3.2.1
@@ -37,5 +37,26 @@ main (void)
       free (dst);
     }
 
+  if (sprintf (buf, "%1$d%3$.*2$s%4$d", 7, 67108863, "x", 8) != 3
+      || strcmp (buf, "7x8") != 0)
+    {
+      printf ("sprintf (buf, \"%%1$d%%3$.*2$s%%4$d\", 7, 67108863, \"x\", 8) produced `%s' output", buf);
+      result = 1;
+    }
+
+  if (sprintf (buf, "%67108863.16\"%d", 7) != 14
+      || strcmp (buf, "%67108863.16\"7") != 0)
+    {
+      printf ("sprintf (buf, \"%%67108863.16\\\"%%d\", 7) produced `%s' output", buf);
+      result = 1;
+    }
+
+  if (sprintf (buf, "%*\"%d", 0x3ffffff, 7) != 11
+      || strcmp (buf, "%67108863\"7") != 0)
+    {
+      printf ("sprintf (buf, \"%%*\\\"%%d\", 0x3ffffff, 7) produced `%s' output", buf);
+      result = 1;
+    }
+
   return result;
 }
--- glibc-20070515T2025/stdio-common/tst-sprintf2.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/stdio-common/tst-sprintf2.c	7 Jul 2007 16:19:21 -0000	1.2.2.1
@@ -0,0 +1,82 @@
+#include <float.h>
+#include <math.h>
+#include <stdio.h>
+#include <string.h>
+
+int
+main (void)
+{
+  volatile union { long double l; long long x[2]; } u, v;
+  char buf[64];
+  int result = 0;
+
+#if LDBL_MANT_DIG == 106 || LDBL_MANT_DIG == 113
+# define COMPARE_LDBL(u, v) \
+  ((u).l == (v).l && (u).x[0] == (v).x[0] && (u).x[1] == (v).x[1])
+#else
+# define COMPARE_LDBL(u, v) ((u).l == (v).l)
+#endif
+
+#define TEST(val) \
+  do									   \
+    {									   \
+      u.l = (val);							   \
+      snprintf (buf, sizeof buf, "%LaL", u.l);				   \
+      if (strcmp (buf, #val) != 0)					   \
+	{								   \
+	  printf ("Error on line %d: %s != %s\n", __LINE__, buf, #val);	   \
+	  result = 1;							   \
+	}								   \
+      if (sscanf (#val, "%La", &v.l) != 1 || !COMPARE_LDBL (u, v))	   \
+	{								   \
+	  printf ("Error sscanf on line %d: %La != %La\n", __LINE__,	   \
+		  u.l, v.l);						   \
+	  result = 1;							   \
+	}								   \
+      /* printf ("%s %La %016Lx %016Lx\n", #val, u.l, u.x[0], u.x[1]); */  \
+    }									   \
+  while (0)
+
+#if LDBL_MANT_DIG >= 106
+# if LDBL_MANT_DIG == 106
+  TEST (0x0.ffffffffffffp-1022L);
+  TEST (0x0.ffffffffffff1p-1022L);
+  TEST (0x0.fffffffffffffp-1022L);
+# endif
+  TEST (0x1p-1022L);
+  TEST (0x1.0000000000001p-1022L);
+  TEST (0x1.00000000001e7p-1022L);
+  TEST (0x1.fffffffffffffp-1022L);
+  TEST (0x1p-1021L);
+  TEST (0x1.00000000000008p-1021L);
+  TEST (0x1.0000000000001p-1021L);
+  TEST (0x1.00000000000018p-1021L);
+  TEST (0x1.0000000000000f8p-1017L);
+  TEST (0x1.0000000000001p-1017L);
+  TEST (0x1.000000000000108p-1017L);
+  TEST (0x1.000000000000dcf8p-1013L);
+  TEST (0x1.000000000000ddp-1013L);
+  TEST (0x1.000000000000dd08p-1013L);
+  TEST (0x1.ffffffffffffffffffffffffffp-1L);
+  TEST (0x1.ffffffffffffffffffffffffff8p-1L);
+  TEST (0x1p+0L);
+  TEST (0x1.000000000000000000000000008p+0L);
+  TEST (0x1.00000000000000000000000001p+0L);
+  TEST (0x1.000000000000000000000000018p+0L);
+  TEST (0x1.23456789abcdef123456789abc8p+0L);
+  TEST (0x1.23456789abcde7123456789abc8p+0L);
+  TEST (0x1.23456789abcdef123456789abc8p+64L);
+  TEST (0x1.23456789abcde7123456789abc8p+64L);
+  TEST (0x1.123456789abcdef123456789p-969L);
+# if LDBL_MANT_DIG == 106
+  TEST (-0x1.2d71957cc1263bbbeb1d365f1e8p-969L);
+  TEST (0x1.23456789abcdef0123456789abp-970L);
+  TEST (0x1.579bde02468acp-1001L);
+  TEST (0x0.abcdef0123456p-1022L);
+  TEST (0x1.abcdef0123456p-1022L);
+  TEST (0x1.abcdef012345678p-1014L);
+  TEST (0x1.abcdef0123456f8p-1014L);
+# endif
+#endif
+  return result;
+}
--- glibc-20070515T2025/stdio-common/vfprintf.c	7 May 2007 03:43:55 -0000	1.139
+++ glibc-20070515T2025-fedora/stdio-common/vfprintf.c	21 May 2007 20:01:11 -0000	1.128.2.9
@@ -1627,6 +1627,8 @@ do_positional:
     /* Just a counter.  */
     size_t cnt;
 
+    free (workstart);
+    workstart = NULL;
 
     if (grouping == (const char *) -1)
       {
@@ -1801,7 +1803,9 @@ do_positional:
 	int use_outdigits = specs[nspecs_done].info.i18n;
 	char pad = specs[nspecs_done].info.pad;
 	CHAR_T spec = specs[nspecs_done].info.spec;
-	CHAR_T *workstart = NULL;
+
+	workstart = NULL;
+	workend = &work_buffer[sizeof (work_buffer) / sizeof (CHAR_T)];
 
 	/* Fill in last information.  */
 	if (specs[nspecs_done].width_arg != -1)
@@ -1897,8 +1901,7 @@ do_positional:
 	    break;
 	  }
 
-	if (__builtin_expect (workstart != NULL, 0))
-	  free (workstart);
+	free (workstart);
 	workstart = NULL;
 
 	/* Write the following constant string.  */
@@ -1926,7 +1929,7 @@ printf_unknown (FILE *s, const struct pr
 
 {
   int done = 0;
-  CHAR_T work_buffer[MAX (info->width, info->spec) + 32];
+  CHAR_T work_buffer[MAX (sizeof (info->width), sizeof (info->prec)) * 3];
   CHAR_T *const workend
     = &work_buffer[sizeof (work_buffer) / sizeof (CHAR_T)];
   register CHAR_T *w;
--- glibc-20070515T2025/stdio-common/vfscanf.c	27 Apr 2007 19:28:32 -0000	1.123
+++ glibc-20070515T2025-fedora/stdio-common/vfscanf.c	8 Jul 2007 10:08:25 -0000	1.110.2.7
@@ -530,12 +530,17 @@ _IO_vfscanf_internal (_IO_FILE *s, const
 	{
 	  /* Eat whitespace.  */
 	  int save_errno = errno;
-	  errno = 0;
+	  __set_errno (0);
 	  do
-	    if (__builtin_expect (inchar () == EOF && errno == EINTR, 0))
+	    /* We add the additional test for EOF here since otherwise
+	       inchar will restore the old errno value which might be
+	       EINTR but does not indicate an interrupt since nothing
+	       was read at this time.  */
+	    if (__builtin_expect ((c == EOF || inchar () == EOF)
+				  && errno == EINTR, 0))
 	      input_error ();
 	  while (ISSPACE (c));
-	  errno = save_errno;
+	  __set_errno (save_errno);
 	  ungetc (c, s);
 	  skip_space = 0;
 	}
--- glibc-20070515T2025/sysdeps/generic/dl-cache.h	25 Jun 2003 08:01:22 -0000	1.13
+++ glibc-20070515T2025-fedora/sysdeps/generic/dl-cache.h	22 Sep 2004 21:21:07 -0000	1.13.2.1
@@ -36,6 +36,14 @@
 # define add_system_dir(dir) add_dir (dir)
 #endif
 
+#ifndef arch_startup
+# define arch_startup(argc, argv) do { } while (0)
+#endif
+
+#ifndef add_arch_dirs
+# define add_arch_dirs(config_file) do { } while (0)
+#endif
+
 #define CACHEMAGIC "ld.so-1.7.0"
 
 /* libc5 and glibc 2.0/2.1 use the same format.  For glibc 2.2 another
--- glibc-20070515T2025/sysdeps/generic/ldsodefs.h	15 Jan 2007 20:48:43 -0000	1.134
+++ glibc-20070515T2025-fedora/sysdeps/generic/ldsodefs.h	7 Jul 2007 17:31:45 -0000	1.102.2.23
@@ -38,7 +38,6 @@
 #include <bits/libc-lock.h>
 #include <hp-timing.h>
 #include <tls.h>
-#include <rtld-lowlevel.h>
 
 __BEGIN_DECLS
 
@@ -439,18 +438,18 @@ struct rtld_global
   EXTERN void (*_dl_rtld_unlock_recursive) (void *);
 #endif
 
-  /* Prevailing state of the stack, PF_X indicating it's executable.  */
-  EXTERN ElfW(Word) _dl_stack_flags;
-
   /* If loading a shared object requires that we make the stack executable
      when it was not, we do it by calling this function.
      It returns an errno code or zero on success.  */
   EXTERN int (*_dl_make_stack_executable_hook) (void **) internal_function;
 
-  /* Highest dtv index currently needed.  */
-  EXTERN size_t _dl_tls_max_dtv_idx;
+  /* Prevailing state of the stack, PF_X indicating it's executable.  */
+  EXTERN ElfW(Word) _dl_stack_flags;
+
   /* Flag signalling whether there are gaps in the module ID allocation.  */
   EXTERN bool _dl_tls_dtv_gaps;
+  /* Highest dtv index currently needed.  */
+  EXTERN size_t _dl_tls_max_dtv_idx;
   /* Information about the dtv slots.  */
   EXTERN struct dtv_slotinfo_list
   {
@@ -486,6 +485,14 @@ struct rtld_global
 
   EXTERN void (*_dl_init_static_tls) (struct link_map *);
 
+  EXTERN void (*_dl_wait_lookup_done) (void);
+
+  /* Scopes to free after next THREAD_GSCOPE_WAIT ().  */
+  EXTERN struct dl_scope_free_list
+  {
+    size_t count;
+    struct r_scope_elem **list[50];
+  } *_dl_scope_free_list;
 #ifdef SHARED
 };
 # define __rtld_global_attribute__
@@ -532,15 +539,15 @@ struct rtld_global_ro
 #define DL_DEBUG_HELP       (1 << 9)
 #define DL_DEBUG_PRELINK    (1 << 10)
 
-  /* Cached value of `getpagesize ()'.  */
-  EXTERN size_t _dl_pagesize;
-
   /* OS version.  */
   EXTERN unsigned int _dl_osversion;
   /* Platform name.  */
   EXTERN const char *_dl_platform;
   EXTERN size_t _dl_platformlen;
 
+  /* Cached value of `getpagesize ()'.  */
+  EXTERN size_t _dl_pagesize;
+
   /* Copy of the content of `_dl_main_searchlist' at startup time.  */
   EXTERN struct r_scope_elem _dl_initial_searchlist;
 
@@ -569,9 +576,6 @@ struct rtld_global_ro
   /* Expected cache ID.  */
   EXTERN int _dl_correct_cache_id;
 
-  /* 0 if internal pointer values should not be guarded, 1 if they should.  */
-  EXTERN int _dl_pointer_guard;
-
   /* Mask for hardware capabilities that are available.  */
   EXTERN uint64_t _dl_hwcap;
 
@@ -655,6 +659,9 @@ struct rtld_global_ro
   /* List of auditing interfaces.  */
   struct audit_ifaces *_dl_audit;
   unsigned int _dl_naudit;
+
+  /* 0 if internal pointer values should not be guarded, 1 if they should.  */
+  EXTERN int _dl_pointer_guard;
 };
 # define __rtld_global_attribute__
 # ifdef IS_IN_rtld
@@ -838,9 +845,7 @@ enum
     DL_LOOKUP_ADD_DEPENDENCY = 1,
     /* Return most recent version instead of default version for
        unversioned lookup.  */
-    DL_LOOKUP_RETURN_NEWEST = 2,
-    /* Set if the scopr lock in the UNDEF_MAP is taken.  */
-    DL_LOOKUP_SCOPE_LOCK = 4
+    DL_LOOKUP_RETURN_NEWEST = 2
   };
 
 /* Lookup versioned symbol.  */
@@ -1048,6 +1053,11 @@ extern void *_dl_open (const char *name,
 		       Lmid_t nsid, int argc, char *argv[], char *env[])
      attribute_hidden;
 
+/* Free or queue for freeing scope OLD.  If other threads might be
+   in the middle of _dl_fixup, _dl_profile_fixup or dl*sym using the
+   old scope, OLD can't be freed until no thread is using it.  */
+extern int _dl_scope_free (struct r_scope_elem **old) attribute_hidden;
+
 /* Add module to slot information data.  */
 extern void _dl_add_to_slotinfo (struct link_map  *l) attribute_hidden;
 
@@ -1059,6 +1069,8 @@ extern struct link_map *_dl_update_sloti
    but never touch anything.  Return null if it's not allocated yet.  */
 extern void *_dl_tls_get_addr_soft (struct link_map *l) internal_function;
 
+extern int _dl_addr_inside_object (struct link_map *l, const ElfW(Addr) addr)
+     internal_function attribute_hidden;
 
 __END_DECLS
 
--- glibc-20070515T2025/sysdeps/i386/Makefile	6 Mar 2005 00:18:16 -0000	1.20
+++ glibc-20070515T2025-fedora/sysdeps/i386/Makefile	30 Jun 2006 09:16:34 -0000	1.16.2.4
@@ -64,4 +64,12 @@ endif
 
 ifneq (,$(filter -mno-tls-direct-seg-refs,$(CFLAGS)))
 defines += -DNO_TLS_DIRECT_SEG_REFS
+else
+# .a libraries are not performance critical and so we
+# build them without direct TLS segment references
+# always.
+CPPFLAGS-.o += -DNO_TLS_DIRECT_SEG_REFS
+CFLAGS-.o += -mno-tls-direct-seg-refs
+CPPFLAGS-.oS += -DNO_TLS_DIRECT_SEG_REFS
+CFLAGS-.oS += -mno-tls-direct-seg-refs
 endif
--- glibc-20070515T2025/sysdeps/i386/ldbl2mpn.c	6 Jul 2001 04:55:52 -0000	1.4
+++ glibc-20070515T2025-fedora/sysdeps/i386/ldbl2mpn.c	7 Jul 2007 21:28:56 -0000	1.4.4.2
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -19,7 +19,7 @@
 #include "gmp.h"
 #include "gmp-impl.h"
 #include "longlong.h"
-#include "ieee754.h"
+#include <ieee754.h>
 #include <float.h>
 #include <stdlib.h>
 
@@ -46,7 +46,7 @@ __mpn_extract_long_double (mp_ptr res_pt
 #elif BITS_PER_MP_LIMB == 64
   /* Hopefully the compiler will combine the two bitfield extracts
      and this composition into just the original quadword extract.  */
-  res_ptr[0] = ((unsigned long int) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
+  res_ptr[0] = ((mp_limb_t) u.ieee.mantissa0 << 32) | u.ieee.mantissa1;
   #define N 1
 #else
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
@@ -109,6 +109,13 @@ __mpn_extract_long_double (mp_ptr res_pt
 	    }
 	}
     }
+  else if (u.ieee.exponent < 0x7fff
+#if N == 2
+	   && res_ptr[0] == 0
+#endif
+	   && res_ptr[N - 1] == 0)
+    /* Pseudo zero.  */
+    *expt = 0;
 
   return N;
 }
--- glibc-20070515T2025/sysdeps/ia64/Makefile	16 Aug 2004 06:46:14 -0000	1.10
+++ glibc-20070515T2025-fedora/sysdeps/ia64/Makefile	22 Sep 2004 21:21:07 -0000	1.10.2.1
@@ -12,8 +12,8 @@ elide-routines.os += hp-timing
 
 ifeq (yes,$(build-shared))
 # Compatibility
-sysdep_routines += ia64libgcc
-shared-only-routines += ia64libgcc
+sysdep_routines += libgcc-compat
+shared-only-routines += libgcc-compat
 endif
 endif
 
--- glibc-20070515T2025/sysdeps/ia64/ia64libgcc.S	11 May 2002 05:12:35 -0000	1.2
+++ glibc-20070515T2025-fedora/sysdeps/ia64/ia64libgcc.S	22 Sep 2004 21:21:07 -0000	1.2.2.1
@@ -1,350 +0,0 @@
-/* From the Intel IA-64 Optimization Guide, choose the minimum latency
-   alternative.  */
-
-#include <sysdep.h>
-#undef ret
-
-#include <shlib-compat.h>
-
-#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_2_6)
-
-/* __divtf3
-   Compute a 80-bit IEEE double-extended quotient.
-   farg0 holds the dividend.  farg1 holds the divisor.  */
-
-ENTRY(___divtf3)
-	cmp.eq p7, p0 = r0, r0
-	frcpa.s0 f10, p6 = farg0, farg1
-	;;
-(p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
-(p6)	fnma.s1 f11 = farg1, f10, f1
-(p6)	fma.s1 f12 = farg0, f10, f0
-	;;
-(p6)	fma.s1 f13 = f11, f11, f0
-(p6)	fma.s1 f14 = f11, f11, f11
-	;;
-(p6)	fma.s1 f11 = f13, f13, f11
-(p6)	fma.s1 f13 = f14, f10, f10
-	;;
-(p6)	fma.s1 f10 = f13, f11, f10
-(p6)	fnma.s1 f11 = farg1, f12, farg0
-	;;
-(p6)	fma.s1 f11 = f11, f10, f12
-(p6)	fnma.s1 f12 = farg1, f10, f1
-	;;
-(p6)	fma.s1 f10 = f12, f10, f10
-(p6)	fnma.s1 f12 = farg1, f11, farg0
-	;;
-(p6)	fma.s0 fret0 = f12, f10, f11
-(p7)	mov fret0 = f10
-	br.ret.sptk rp
-END(___divtf3)
-	.symver ___divtf3, __divtf3@GLIBC_2.2
-
-/* __divdf3
-   Compute a 64-bit IEEE double quotient.
-   farg0 holds the dividend.  farg1 holds the divisor.  */
-
-ENTRY(___divdf3)
-	cmp.eq p7, p0 = r0, r0
-	frcpa.s0 f10, p6 = farg0, farg1
-	;;
-(p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
-(p6)	fmpy.s1 f11 = farg0, f10
-(p6)	fnma.s1 f12 = farg1, f10, f1
-	;;
-(p6)	fma.s1 f11 = f12, f11, f11
-(p6)	fmpy.s1 f13 = f12, f12
-	;;
-(p6)	fma.s1 f10 = f12, f10, f10
-(p6)	fma.s1 f11 = f13, f11, f11
-	;;
-(p6)	fmpy.s1 f12 = f13, f13
-(p6)	fma.s1 f10 = f13, f10, f10
-	;;
-(p6)	fma.d.s1 f11 = f12, f11, f11
-(p6)	fma.s1 f10 = f12, f10, f10
-	;;
-(p6)	fnma.d.s1 f8 = farg1, f11, farg0
-	;;
-(p6)	fma.d fret0 = f8, f10, f11
-(p7)	mov fret0 = f10
-	br.ret.sptk rp
-	;;
-END(___divdf3)
-	.symver	___divdf3, __divdf3@GLIBC_2.2
-
-/* __divsf3
-   Compute a 32-bit IEEE float quotient.
-   farg0 holds the dividend.  farg1 holds the divisor.  */
-
-ENTRY(___divsf3)
-	cmp.eq p7, p0 = r0, r0
-	frcpa.s0 f10, p6 = farg0, farg1
-	;;
-(p6)	cmp.ne p7, p0 = r0, r0
-	.pred.rel.mutex p6, p7
-(p6)	fmpy.s1 f8 = farg0, f10
-(p6)	fnma.s1 f9 = farg1, f10, f1
-	;;
-(p6)	fma.s1 f8 = f9, f8, f8
-(p6)	fmpy.s1 f9 = f9, f9
-	;;
-(p6)	fma.s1 f8 = f9, f8, f8
-(p6)	fmpy.s1 f9 = f9, f9
-	;;
-(p6)	fma.d.s1 f10 = f9, f8, f8
-	;;
-(p6)	fnorm.s.s0 fret0 = f10
-(p7)	mov fret0 = f10
-	br.ret.sptk rp
-	;;
-END(___divsf3)
-	.symver	___divsf3, __divsf3@GLIBC_2.2
-
-/* __divdi3
-   Compute a 64-bit integer quotient.
-   in0 holds the dividend.  in1 holds the divisor.  */
-
-ENTRY(___divdi3)
-	.regstk 2,0,0,0
-	/* Transfer inputs to FP registers.  */
-	setf.sig f8 = in0
-	setf.sig f9 = in1
-	;;
-	/* Convert the inputs to FP, so that they won't be treated as
-	   unsigned.  */
-	fcvt.xf f8 = f8
-	fcvt.xf f9 = f9
-	;;
-	/* Compute the reciprocal approximation.  */
-	frcpa.s1 f10, p6 = f8, f9
-	;;
-	/* 3 Newton-Raphson iterations.  */
-(p6)	fnma.s1 f11 = f9, f10, f1
-(p6)	fmpy.s1 f12 = f8, f10
-	;;
-(p6)	fmpy.s1 f13 = f11, f11
-(p6)	fma.s1 f12 = f11, f12, f12
-	;;
-(p6)	fma.s1 f10 = f11, f10, f10
-(p6)	fma.s1 f11 = f13, f12, f12
-	;;
-(p6)	fma.s1 f10 = f13, f10, f10
-(p6)	fnma.s1 f12 = f9, f11, f8
-	;;
-(p6)	fma.s1 f10 = f12, f10, f11
-	;;
-	/* Round quotient to an integer.  */
-	fcvt.fx.trunc.s1 f10 = f10
-	;;
-	/* Transfer result to GP registers.  */
-	getf.sig ret0 = f10
-	br.ret.sptk rp
-	;;
-END(___divdi3)
-	.symver	___divdi3, __divdi3@GLIBC_2.2
-
-/* __moddi3
-   Compute a 64-bit integer modulus.
-   in0 holds the dividend (a).  in1 holds the divisor (b).  */
-
-ENTRY(___moddi3)
-	.regstk 2,0,0,0
-	/* Transfer inputs to FP registers.  */
-	setf.sig f14 = in0
-	setf.sig f9 = in1
-	;;
-	/* Convert the inputs to FP, so that they won't be treated as
-	   unsigned.  */
-	fcvt.xf f8 = f14
-	fcvt.xf f9 = f9
-	;;
-	/* Compute the reciprocal approximation.  */
-	frcpa.s1 f10, p6 = f8, f9
-	;;
-	/* 3 Newton-Raphson iterations.  */
-(p6)	fmpy.s1 f12 = f8, f10
-(p6)	fnma.s1 f11 = f9, f10, f1
-	;;
-(p6)	fma.s1 f12 = f11, f12, f12
-(p6)	fmpy.s1 f13 = f11, f11
-	;;
-(p6)	fma.s1 f10 = f11, f10, f10
-(p6)	fma.s1 f11 = f13, f12, f12
-	;;
-	sub in1 = r0, in1
-(p6)	fma.s1 f10 = f13, f10, f10
-(p6)	fnma.s1 f12 = f9, f11, f8
-	;;
-	setf.sig f9 = in1
-(p6)	fma.s1 f10 = f12, f10, f11
-	;;
-	fcvt.fx.trunc.s1 f10 = f10
-	;;
-	/* r = q * (-b) + a  */
-	xma.l f10 = f10, f9, f14
-	;;
-	/* Transfer result to GP registers.  */
-	getf.sig ret0 = f10
-	br.ret.sptk rp
-	;;
-END(___moddi3)
-	.symver ___moddi3, __moddi3@GLIBC_2.2
-
-/* __udivdi3
-   Compute a 64-bit unsigned integer quotient.
-   in0 holds the dividend.  in1 holds the divisor.  */
-
-ENTRY(___udivdi3)
-	.regstk 2,0,0,0
-	/* Transfer inputs to FP registers.  */
-	setf.sig f8 = in0
-	setf.sig f9 = in1
-	;;
-	/* Convert the inputs to FP, to avoid FP software-assist faults.  */
-	fcvt.xuf.s1 f8 = f8
-	fcvt.xuf.s1 f9 = f9
-	;;
-	/* Compute the reciprocal approximation.  */
-	frcpa.s1 f10, p6 = f8, f9
-	;;
-	/* 3 Newton-Raphson iterations.  */
-(p6)	fnma.s1 f11 = f9, f10, f1
-(p6)	fmpy.s1 f12 = f8, f10
-	;;
-(p6)	fmpy.s1 f13 = f11, f11
-(p6)	fma.s1 f12 = f11, f12, f12
-	;;
-(p6)	fma.s1 f10 = f11, f10, f10
-(p6)	fma.s1 f11 = f13, f12, f12
-	;;
-(p6)	fma.s1 f10 = f13, f10, f10
-(p6)	fnma.s1 f12 = f9, f11, f8
-	;;
-(p6)	fma.s1 f10 = f12, f10, f11
-	;;
-	/* Round quotient to an unsigned integer.  */
-	fcvt.fxu.trunc.s1 f10 = f10
-	;;
-	/* Transfer result to GP registers.  */
-	getf.sig ret0 = f10
-	br.ret.sptk rp
-	;;
-END(___udivdi3)
-	.symver	___udivdi3, __udivdi3@GLIBC_2.2
-
-/* __umoddi3
-   Compute a 64-bit unsigned integer modulus.
-   in0 holds the dividend (a).  in1 holds the divisor (b).  */
-
-ENTRY(___umoddi3)
-	.regstk 2,0,0,0
-	/* Transfer inputs to FP registers.  */
-	setf.sig f14 = in0
-	setf.sig f9 = in1
-	;;
-	/* Convert the inputs to FP, to avoid FP software assist faults.  */
-	fcvt.xuf.s1 f8 = f14
-	fcvt.xuf.s1 f9 = f9
-	;;
-	/* Compute the reciprocal approximation.  */
-	frcpa.s1 f10, p6 = f8, f9
-	;;
-	/* 3 Newton-Raphson iterations.  */
-(p6)	fmpy.s1 f12 = f8, f10
-(p6)	fnma.s1 f11 = f9, f10, f1
-	;;
-(p6)	fma.s1 f12 = f11, f12, f12
-(p6)	fmpy.s1 f13 = f11, f11
-	;;
-(p6)	fma.s1 f10 = f11, f10, f10
-(p6)	fma.s1 f11 = f13, f12, f12
-	;;
-	sub in1 = r0, in1
-(p6)	fma.s1 f10 = f13, f10, f10
-(p6)	fnma.s1 f12 = f9, f11, f8
-	;;
-	setf.sig f9 = in1
-(p6)	fma.s1 f10 = f12, f10, f11
-	;;
-	/* Round quotient to an unsigned integer.  */
-	fcvt.fxu.trunc.s1 f10 = f10
-	;;
-	/* r = q * (-b) + a  */
-	xma.l f10 = f10, f9, f14
-	;;
-	/* Transfer result to GP registers.  */
-	getf.sig ret0 = f10
-	br.ret.sptk rp
-	;;
-END(___umoddi3)
-	.symver	___umoddi3, __umoddi3@GLIBC_2.2
-
-/* __multi3
-   Compute a 128-bit multiply of 128-bit multiplicands.
-   in0/in1 holds one multiplicand (a), in2/in3 holds the other one (b).  */
-
-ENTRY(___multi3)
-	.regstk 4,0,0,0
-	setf.sig f6 = in1
-	movl r19 = 0xffffffff
-	setf.sig f7 = in2
-	;;
-	and r14 = r19, in0
-	;;
-	setf.sig f10 = r14
-	and r14 = r19, in2
-	xmpy.l f9 = f6, f7
-	;;
-	setf.sig f6 = r14
-	shr.u r14 = in0, 32
-	;;
-	setf.sig f7 = r14
-	shr.u r14 = in2, 32
-	;;
-	setf.sig f8 = r14
-	xmpy.l f11 = f10, f6
-	xmpy.l f6 = f7, f6
-	;;
-	getf.sig r16 = f11
-	xmpy.l f7 = f7, f8
-	;;
-	shr.u r14 = r16, 32
-	and r16 = r19, r16
-	getf.sig r17 = f6
-	setf.sig f6 = in0
-	;;
-	setf.sig f11 = r14
-	getf.sig r21 = f7
-	setf.sig f7 = in3
-	;;
-	xma.l f11 = f10, f8, f11
-	xma.l f6 = f6, f7, f9
-	;;
-	getf.sig r18 = f11
-	;;
-	add r18 = r18, r17
-	;;
-	and r15 = r19, r18
-	cmp.ltu p7, p6 = r18, r17
-	;;
-	getf.sig r22 = f6
-(p7)	adds r14 = 1, r19
-	;;
-(p7)	add r21 = r21, r14
-	shr.u r14 = r18, 32
-	shl r15 = r15, 32
-	;;
-	add r20 = r21, r14
-	;;
-	add ret0 = r15, r16
-	add ret1 = r22, r20
-	br.ret.sptk rp
-	;;
-END(___multi3)
-	.symver	___multi3, __multi3@GLIBC_2.2
-
-#endif
--- glibc-20070515T2025/sysdeps/ia64/ldbl2mpn.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/ia64/ldbl2mpn.c	7 Jul 2007 19:59:56 -0000	1.1.2.1
@@ -0,0 +1 @@
+#include "../i386/ldbl2mpn.c"
--- glibc-20070515T2025/sysdeps/ia64/libgcc-compat.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/ia64/libgcc-compat.c	22 Sep 2004 21:21:08 -0000	1.1.2.1
@@ -0,0 +1,84 @@
+/* pre-.hidden libgcc compatibility
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <stdint.h>
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_2_6)
+
+typedef int int128_t __attribute__((__mode__(TI)));
+
+extern long double __divtf3 (long double, long double) attribute_hidden;
+long double INTUSE (__divtf3) (long double x, long double y)
+{
+  return __divtf3 (x, y);
+}
+symbol_version (INTUSE (__divtf3), __divtf3, GLIBC_2.2);
+
+extern double __divdf3 (double, double) attribute_hidden;
+double INTUSE (__divdf3) (double x, double y)
+{
+  return __divdf3 (x, y);
+}
+symbol_version (INTUSE (__divdf3), __divdf3, GLIBC_2.2);
+
+extern float __divsf3 (float, float) attribute_hidden;
+float INTUSE (__divsf3) (float x, float y)
+{
+  return __divsf3 (x, y);
+}
+symbol_version (INTUSE (__divsf3), __divsf3, GLIBC_2.2);
+
+extern int64_t __divdi3 (int64_t, int64_t) attribute_hidden;
+int64_t INTUSE (__divdi3) (int64_t x, int64_t y)
+{
+  return __divdi3 (x, y);
+}
+symbol_version (INTUSE (__divdi3), __divdi3, GLIBC_2.2);
+
+extern int64_t __moddi3 (int64_t, int64_t) attribute_hidden;
+int64_t INTUSE (__moddi3) (int64_t x, int64_t y)
+{
+  return __moddi3 (x, y);
+}
+symbol_version (INTUSE (__moddi3), __moddi3, GLIBC_2.2);
+
+extern uint64_t __udivdi3 (uint64_t, uint64_t) attribute_hidden;
+uint64_t INTUSE (__udivdi3) (uint64_t x, uint64_t y)
+{
+  return __udivdi3 (x, y);
+}
+symbol_version (INTUSE (__udivdi3), __udivdi3, GLIBC_2.2);
+
+extern uint64_t __umoddi3 (uint64_t, uint64_t) attribute_hidden;
+uint64_t INTUSE (__umoddi3) (uint64_t x, uint64_t y)
+{
+  return __umoddi3 (x, y);
+}
+symbol_version (INTUSE (__umoddi3), __umoddi3, GLIBC_2.2);
+
+extern int128_t __multi3 (int128_t, int128_t) attribute_hidden;
+int128_t INTUSE (__multi3) (int128_t x, int128_t y)
+{
+  return __multi3 (x, y);
+}
+symbol_version (INTUSE (__multi3), __multi3, GLIBC_2.2);
+
+#endif
--- glibc-20070515T2025/sysdeps/ieee754/ldbl-128ibm/mpn2ldbl.c	28 Jan 2006 00:07:25 -0000	1.1
+++ glibc-20070515T2025-fedora/sysdeps/ieee754/ldbl-128ibm/mpn2ldbl.c	7 Jul 2007 21:28:56 -0000	1.1.2.3
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 1999, 2002, 2003, 2004, 2006
+/* Copyright (C) 1995, 1996, 1997, 1998, 1999, 2002, 2003, 2004, 2006, 2007
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -31,19 +31,20 @@ long double
 __mpn_construct_long_double (mp_srcptr frac_ptr, int expt, int sign)
 {
   union ibm_extended_long_double u;
-  unsigned long hidden2, lzcount;
+  unsigned long lzcount;
   unsigned long long hi, lo;
+  int exponent2;
 
   u.ieee.negative = sign;
   u.ieee.negative2 = sign;
   u.ieee.exponent = expt + IBM_EXTENDED_LONG_DOUBLE_BIAS;
-  u.ieee.exponent2 = expt - 53 + IBM_EXTENDED_LONG_DOUBLE_BIAS;
+  u.ieee.exponent2 = 0;
+  exponent2 = expt - 53 + IBM_EXTENDED_LONG_DOUBLE_BIAS;
 
 #if BITS_PER_MP_LIMB == 32
   /* The low order 53 bits (52 + hidden) go into the lower double */
   lo = frac_ptr[0];
   lo |= (frac_ptr[1] & ((1LL << (53 - 32)) - 1)) << 32;
-  hidden2 = (frac_ptr[1] >> (52 - 32)) & ((mp_limb_t) 1);
   /* The high order 53 bits (52 + hidden) go into the upper double */
   hi = (frac_ptr[1] >> (53 - 32)) & ((1 << 11) - 1);
   hi |= ((unsigned long long) frac_ptr[2]) << 11;
@@ -51,7 +52,6 @@ __mpn_construct_long_double (mp_srcptr f
 #elif BITS_PER_MP_LIMB == 64
   /* The low order 53 bits (52 + hidden) go into the lower double */
   lo = frac_ptr[0] & (((mp_limb_t) 1 << 53) - 1);
-  hidden2 = (frac_ptr[0] >> 52) & ((mp_limb_t) 1);
   /* The high order 53 bits (52 + hidden) go into the upper double */
   hi = (frac_ptr[0] >> 53) & (((mp_limb_t) 1 << 11) - 1);
   hi |= (frac_ptr[1] << 11);
@@ -59,14 +59,62 @@ __mpn_construct_long_double (mp_srcptr f
   #error "mp_limb size " BITS_PER_MP_LIMB "not accounted for"
 #endif
 
+  if ((hi & (1LL << 52)) == 0 && (hi | lo) != 0)
+    {
+      /* denormal number  */
+      unsigned long long val = hi ? hi : lo;
+
+      if (sizeof (val) == sizeof (long))
+	lzcount = __builtin_clzl (val);
+      else if ((val >> 32) != 0)
+	lzcount = __builtin_clzl ((long) (val >> 32));
+      else
+	lzcount = __builtin_clzl ((long) val) + 32;
+      if (hi)
+	lzcount = lzcount - 11;
+      else
+	lzcount = lzcount + 42;
+
+      if (lzcount > u.ieee.exponent)
+	{
+	  lzcount = u.ieee.exponent;
+	  u.ieee.exponent = 0;
+	  exponent2 -= lzcount;
+	}
+      else
+	{
+	  u.ieee.exponent -= (lzcount - 1);
+	  exponent2 -= (lzcount - 1);
+	}
+
+      if (lzcount <= 53)
+	{
+	  hi = (hi << lzcount) | (lo >> (53 - lzcount));
+	  lo = (lo << lzcount) & ((1LL << 53) - 1);
+	}
+      else
+	{
+	  hi = lo << (lzcount - 53);
+	  lo = 0;
+	}
+    }
+
   if (lo != 0L)
     {
       /* hidden2 bit of low double controls rounding of the high double.
-	 If hidden2 is '1' then round up hi and adjust lo (2nd mantissa)
+	 If hidden2 is '1' and either the explicit mantissa is non-zero
+	 or hi is odd, then round up hi and adjust lo (2nd mantissa)
 	 plus change the sign of the low double to compensate.  */
-      if (hidden2)
+      if ((lo & (1LL << 52)) != 0
+	  && ((hi & 1) != 0 || (lo & ((1LL << 52) - 1))))
 	{
 	  hi++;
+	  if ((hi & ((1LL << 52) - 1)) == 0)
+	    {
+	      if ((hi & (1LL << 53)) != 0)
+		hi -= 1LL << 52;
+	      u.ieee.exponent++;
+	    }
 	  u.ieee.negative2 = !sign;
 	  lo = (1LL << 53) - lo;
 	}
@@ -85,17 +133,18 @@ __mpn_construct_long_double (mp_srcptr f
       if (lzcount > 0)
 	{
 	  lo = lo << lzcount;
-	  u.ieee.exponent2 = u.ieee.exponent2 - lzcount;
+	  exponent2 = exponent2 - lzcount;
 	}
+      if (exponent2 > 0)
+	u.ieee.exponent2 = exponent2;
+      else
+	lo >>= 1 - exponent2;
     }
   else
-    {
-      u.ieee.negative2 = 0;
-      u.ieee.exponent2 = 0;
-    }
+    u.ieee.negative2 = 0;
 
   u.ieee.mantissa3 = lo & 0xffffffffLL;
-  u.ieee.mantissa2 = (lo >> 32) & 0xffffff;
+  u.ieee.mantissa2 = (lo >> 32) & 0xfffff;
   u.ieee.mantissa1 = hi & 0xffffffffLL;
   u.ieee.mantissa0 = (hi >> 32) & ((1LL << (LDBL_MANT_DIG - 86)) - 1);
 
--- glibc-20070515T2025/sysdeps/ieee754/ldbl-128ibm/printf_fphex.c	28 Jan 2006 00:07:25 -0000	1.1
+++ glibc-20070515T2025-fedora/sysdeps/ieee754/ldbl-128ibm/printf_fphex.c	7 Jul 2007 21:28:56 -0000	1.1.2.3
@@ -1,5 +1,5 @@
 /* Print floating point number in hexadecimal notation according to ISO C99.
-   Copyright (C) 1997,1998,1999,2000,2001,2002,2004,2006
+   Copyright (C) 1997,1998,1999,2000,2001,2002,2004,2006,2007
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
@@ -35,21 +35,24 @@ do {									      \
 									      \
       lo = ((long long)eldbl.ieee.mantissa2 << 32) | eldbl.ieee.mantissa3;    \
       hi = ((long long)eldbl.ieee.mantissa0 << 32) | eldbl.ieee.mantissa1;    \
-   /* If the lower double is not a denomal or zero then set the hidden	      \
-      53rd bit.  */							      \
-      if (eldbl.ieee.exponent2 > 0x001)					      \
-	{								      \
-	  lo |= (1ULL << 52);						      \
-	  lo = lo << 7; /* pre-shift lo to match ieee854.  */		      \
-	  /* The lower double is normalized separately from the upper.  We    \
-	     may need to adjust the lower manitissa to reflect this.  */      \
-	  ediff = eldbl.ieee.exponent - eldbl.ieee.exponent2;		      \
-	  if (ediff > 53)						      \
-	    lo = lo >> (ediff-53);					      \
-	}								      \
-  									      \
-      if ((eldbl.ieee.negative != eldbl.ieee.negative2)			      \
-	  && ((eldbl.ieee.exponent2 != 0) && (lo != 0L)))		      \
+      lo <<= 7; /* pre-shift lo to match ieee854.  */			      \
+      /* If the lower double is not a denomal or zero then set the hidden     \
+	 53rd bit.  */							      \
+      if (eldbl.ieee.exponent2 != 0)					      \
+	lo |= (1ULL << (52 + 7));					      \
+      else								      \
+	lo <<= 1;							      \
+      /* The lower double is normalized separately from the upper.  We	      \
+	 may need to adjust the lower manitissa to reflect this.  */	      \
+      ediff = eldbl.ieee.exponent - eldbl.ieee.exponent2;		      \
+      if (ediff > 53 + 63)						      \
+	lo = 0;								      \
+      else if (ediff > 53)						      \
+	lo = lo >> (ediff - 53);					      \
+      else if (eldbl.ieee.exponent2 == 0 && ediff < 53)			      \
+	lo = lo << (53 - ediff);					      \
+      if (eldbl.ieee.negative != eldbl.ieee.negative2			      \
+	  && (eldbl.ieee.exponent2 != 0 || lo != 0L))			      \
 	{								      \
 	  lo = (1ULL << 60) - lo;					      \
 	  if (hi == 0L)							      \
--- glibc-20070515T2025/sysdeps/ieee754/ldbl-128ibm/s_fpclassifyl.c	28 Jan 2006 00:07:25 -0000	1.1
+++ glibc-20070515T2025-fedora/sysdeps/ieee754/ldbl-128ibm/s_fpclassifyl.c	7 Jul 2007 21:28:56 -0000	1.1.2.3
@@ -1,5 +1,5 @@
 /* Return classification value corresponding to argument.
-   Copyright (C) 1997,1999,2002,2004,2006 Free Software Foundation, Inc.
+   Copyright (C) 1997,1999,2002,2004,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
    		  Jakub Jelinek <jj@ultra.linux.cz>, 1999.
@@ -30,14 +30,16 @@
    * -NaN	fffn nnnn nnnn nnnn xxxx xxxx xxxx xxxx
    * +Inf	7ff0 0000 0000 0000 xxxx xxxx xxxx xxxx
    * -Inf	fff0 0000 0000 0000 xxxx xxxx xxxx xxxx
-   * +0		0000 0000 0000 0000
-   * -0		8000 0000 0000 0000
-   * +normal	001n nnnn nnnn nnnn (smallest)
-   * -normal	801n nnnn nnnn nnnn (smallest)
-   * +normal	7fen nnnn nnnn nnnn (largest)
-   * -normal	ffen nnnn nnnn nnnn (largest)
-   * +denorm	000n nnnn nnnn nnnn
-   * -denorm	800n nnnn nnnn nnnn
+   * +0		0000 0000 0000 0000 xxxx xxxx xxxx xxxx
+   * -0		8000 0000 0000 0000 xxxx xxxx xxxx xxxx
+   * +normal	0360 0000 0000 0000 0000 0000 0000 0000 (smallest)
+   * -normal	8360 0000 0000 0000 0000 0000 0000 0000 (smallest)
+   * +normal	7fef ffff ffff ffff 7c8f ffff ffff fffe (largest)
+   * +normal	ffef ffff ffff ffff fc8f ffff ffff fffe (largest)
+   * +denorm	0360 0000 0000 0000 8000 0000 0000 0001 (largest)
+   * -denorm	8360 0000 0000 0000 0000 0000 0000 0001 (largest)
+   * +denorm	000n nnnn nnnn nnnn xxxx xxxx xxxx xxxx
+   * -denorm	800n nnnn nnnn nnnn xxxx xxxx xxxx xxxx
    */
 
 int
@@ -59,12 +61,23 @@ ___fpclassifyl (long double x)
       /* +/-zero or +/- normal or +/- denormal */
       if (hx & 0x7fffffffffffffffULL) {
 	  /* +/- normal or +/- denormal */
-	  if ((hx & 0x7ff0000000000000ULL) >= 0x0360000000000000ULL) {
+	  if ((hx & 0x7ff0000000000000ULL) > 0x0360000000000000ULL) {
 	      /* +/- normal */
 	      retval = FP_NORMAL;
 	  } else {
-	      /* +/- denormal */
-	      retval = FP_SUBNORMAL;
+	      if ((hx & 0x7ff0000000000000ULL) == 0x0360000000000000ULL) {
+		  if ((lx & 0x7fffffffffffffff)	/* lower is non-zero */
+		  && ((lx^hx) & 0x8000000000000000ULL)) { /* and sign differs */
+		      /* +/- denormal */
+		      retval = FP_SUBNORMAL;
+		  } else {
+		      /* +/- normal */
+		      retval = FP_NORMAL;
+		  }
+	      } else {
+		  /* +/- denormal */
+		  retval = FP_SUBNORMAL;
+	      }
 	  }
       } else {
 	  /* +/- zero */
--- glibc-20070515T2025/sysdeps/ieee754/ldbl-128ibm/s_nextafterl.c	16 Apr 2007 20:42:16 -0000	1.2
+++ glibc-20070515T2025-fedora/sysdeps/ieee754/ldbl-128ibm/s_nextafterl.c	7 Jul 2007 16:16:55 -0000	1.1.2.3
@@ -35,7 +35,7 @@ static char rcsid[] = "$NetBSD: $";
 	long double x,y;
 #endif
 {
-	int64_t hx,hy,ihx,ihy,ilx,ily;
+	int64_t hx,hy,ihx,ihy,ilx;
 	u_int64_t lx,ly;
 
 	GET_LDOUBLE_WORDS64(hx,lx,x);
@@ -43,7 +43,6 @@ static char rcsid[] = "$NetBSD: $";
 	ihx = hx&0x7fffffffffffffffLL;		/* |hx| */
 	ilx = lx&0x7fffffffffffffffLL;		/* |lx| */
 	ihy = hy&0x7fffffffffffffffLL;		/* |hy| */
-	ily = ly&0x7fffffffffffffffLL;		/* |ly| */
 
 	if((((ihx&0x7ff0000000000000LL)==0x7ff0000000000000LL)&&
 	    ((ihx&0x000fffffffffffffLL)!=0)) ||   /* x is nan */
@@ -54,54 +53,66 @@ static char rcsid[] = "$NetBSD: $";
 	    return y;		/* x=y, return y */
 	if(ihx == 0 && ilx == 0) {			/* x == 0 */
 	    long double u;
-	    SET_LDOUBLE_WORDS64(x,hy&0x8000000000000000ULL,1);/* return +-minsubnormal */
-	    u = math_opt_barrier (u);
+	    hy = (hy & 0x8000000000000000ULL) | 1;
+	    SET_LDOUBLE_WORDS64(x,hy,0ULL);/* return +-minsubnormal */
+	    u = math_opt_barrier (x);
 	    u = u * u;
 	    math_force_eval (u);		/* raise underflow flag */
 	    return x;
 	}
-	if(ihx>=0) {			/* x > 0 */
-	    if(ihx>ihy||((ihx==ihy)&&(ilx>ily))) {	/* x > y, x -= ulp */
-
-	        if(ilx==0)
-		    hx--;
-		else
-		    lx--;
-	    } else {				/* x < y, x += ulp */
-	        if((hx==0x7fefffffffffffffLL)&&(lx==0x7c8ffffffffffffeLL))
-		  {
-		    SET_LDOUBLE_WORDS64(x,0x7ff0000000000000,0x8000000000000000);
-		    return x;
-		  }
-	        else if((hx==0xffefffffffffffffLL)&&(lx==0xfc8ffffffffffffeLL))
-		  {
-		    SET_LDOUBLE_WORDS64(x,0xfff0000000000000,0x8000000000000000);
-		    return x;
-		  }
-		else if((lx&0x7fffffffffffffff)==0) hx++;
-		else
-		  lx++;
+	
+	long double u;
+	if(x > y) {	/* x > y, x -= ulp */
+	    if((hx==0xffefffffffffffffLL)&&(lx==0xfc8ffffffffffffeLL))
+	      return x+x;	/* overflow, return -inf */
+	    if (hx >= 0x7ff0000000000000LL) {
+	      SET_LDOUBLE_WORDS64(u,0x7fefffffffffffffLL,0x7c8ffffffffffffeLL);
+	      return u;
 	    }
-	} else {				/* x < 0 */
-	    if(ihy>=0||ihx>ihy||((ihx==ihy)&&(ilx>ily))){/* x < y, x -= ulp */
-		if((lx&0x7fffffffffffffff)==0)
-		    hx--;
-		else
-		    lx--;
-	    } else {				/* x > y, x += ulp */
-		if((lx&0x7fffffffffffffff)==0) hx++;
-		else
-		  lx++;
+	    if(ihx <= 0x0360000000000000LL) {  /* x <= LDBL_MIN */
+	      u = math_opt_barrier (x);
+	      x -= __LDBL_DENORM_MIN__;
+	      if (ihx < 0x0360000000000000LL
+		  || (hx > 0 && (int64_t) lx <= 0)
+		  || (hx < 0 && (int64_t) lx > 1)) {
+		u = u * u;
+		math_force_eval (u);		/* raise underflow flag */
+	      }
+	      return x;
 	    }
+	    if (ihx < 0x06a0000000000000LL) { /* ulp will denormal */
+	      SET_LDOUBLE_WORDS64(u,(hx&0x7ff0000000000000LL),0ULL);
+	      u *= 0x1.0000000000000p-105L;
+	    } else
+	      SET_LDOUBLE_WORDS64(u,(hx&0x7ff0000000000000LL)-0x0690000000000000LL,0ULL);
+	    return x - u;
+	} else {				/* x < y, x += ulp */
+	    if((hx==0x7fefffffffffffffLL)&&(lx==0x7c8ffffffffffffeLL))
+	      return x+x;	/* overflow, return +inf */
+	    if ((u_int64_t) hx >= 0xfff0000000000000ULL) {
+	      SET_LDOUBLE_WORDS64(u,0xffefffffffffffffLL,0xfc8ffffffffffffeLL);
+	      return u;
+	    }
+	    if(ihx <= 0x0360000000000000LL) {  /* x <= LDBL_MIN */
+	      u = math_opt_barrier (x);
+	      x += __LDBL_DENORM_MIN__;
+	      if (ihx < 0x0360000000000000LL
+		  || (hx > 0 && (int64_t) lx < 0 && lx != 0x8000000000000001LL)
+		  || (hx < 0 && (int64_t) lx >= 0)) {
+		u = u * u;
+		math_force_eval (u);		/* raise underflow flag */
+	      }
+	      if (x == 0.0L)	/* handle negative __LDBL_DENORM_MIN__ case */
+		x = -0.0L;
+	      return x;
+	    }
+	    if (ihx < 0x06a0000000000000LL) { /* ulp will denormal */
+	      SET_LDOUBLE_WORDS64(u,(hx&0x7ff0000000000000LL),0ULL);
+	      u *= 0x1.0000000000000p-105L;
+	    } else
+	      SET_LDOUBLE_WORDS64(u,(hx&0x7ff0000000000000LL)-0x0690000000000000LL,0ULL);
+	    return x + u;
 	}
-	hy = hx&0x7ff0000000000000LL;
-	if(hy==0x7ff0000000000000LL) return x+x;/* overflow  */
-	if(hy==0) {
-	    long double u = x * x;		/* underflow */
-	    math_force_eval (u);		/* raise underflow flag */
-	}
-	SET_LDOUBLE_WORDS64(x,hx,lx);
-	return x;
 }
 strong_alias (__nextafterl, __nexttowardl)
 long_double_symbol (libm, __nextafterl, nextafterl);
--- glibc-20070515T2025/sysdeps/powerpc/powerpc64/Makefile	2 Feb 2006 08:23:44 -0000	1.8
+++ glibc-20070515T2025-fedora/sysdeps/powerpc/powerpc64/Makefile	30 Nov 2006 17:07:38 -0000	1.4.2.5
@@ -30,6 +30,7 @@ ifneq ($(elf),no)
 # we use -fpic instead which is much better.
 CFLAGS-initfini.s += -fpic -O1
 endif
+CFLAGS-libc-start.c += -fno-asynchronous-unwind-tables
 endif
 
 ifeq ($(subdir),elf)
--- glibc-20070515T2025/sysdeps/unix/nice.c	15 Aug 2006 05:24:45 -0000	1.7
+++ glibc-20070515T2025-fedora/sysdeps/unix/nice.c	15 Aug 2006 05:53:50 -0000	1.6.2.2
@@ -42,7 +42,12 @@ nice (int incr)
 	__set_errno (save);
     }
 
-  result = setpriority (PRIO_PROCESS, 0, prio + incr);
+  prio += incr;
+  if (prio < PRIO_MIN)
+    prio = PRIO_MIN;
+  else if (prio >= PRIO_MAX)
+    prio = PRIO_MAX - 1;
+  result = setpriority (PRIO_PROCESS, 0, prio);
   if (result == -1)
     {
       if (errno == EACCES)
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/Makefile	11 May 2007 06:39:01 -0000	1.151
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/Makefile	21 May 2007 20:01:11 -0000	1.142.2.10
@@ -13,7 +13,7 @@ endif
 
 ifeq ($(subdir),misc)
 sysdep_routines += sysctl clone llseek umount umount2 readahead \
-		   setfsuid setfsgid makedev
+		   setfsuid setfsgid makedev epoll_pwait
 
 CFLAGS-gethostid.c = -fexceptions
 
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/check_pf.c	25 Apr 2007 16:05:18 -0000	1.10
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/check_pf.c	4 May 2007 10:05:57 -0000	1.3.2.7
@@ -27,13 +27,10 @@
 #include <unistd.h>
 #include <sys/socket.h>
 
-#include <asm/types.h>
-#include <linux/netlink.h>
-#include <linux/rtnetlink.h>
-
 #include <not-cancel.h>
 #include <kernel-features.h>
 
+#include "netlinkaccess.h"
 
 #ifndef IFA_F_TEMPORARY
 # define IFA_F_TEMPORARY IFA_F_SECONDARY
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/dl-osinfo.h	1 Aug 2006 06:55:27 -0000	1.23
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/dl-osinfo.h	2 Aug 2006 16:57:42 -0000	1.14.2.9
@@ -18,11 +18,14 @@
    02111-1307 USA.  */
 
 #include <string.h>
+#include <errno.h>
 #include <fcntl.h>
 #include <sys/utsname.h>
 #include <kernel-features.h>
 #include <dl-sysdep.h>
 #include <stdint.h>
+#include <hp-timing.h>
+#include <endian.h>
 
 #ifndef MIN
 # define MIN(a,b) (((a)<(b))?(a):(b))
@@ -176,5 +179,31 @@ _dl_setup_stack_chk_guard (void)
   unsigned char *p = (unsigned char *) &ret;
   p[sizeof (ret) - 1] = 255;
   p[sizeof (ret) - 2] = '\n';
+#ifdef HP_TIMING_NOW
+  hp_timing_t hpt;
+  HP_TIMING_NOW (hpt);
+  hpt = (hpt & 0xffff) << 8;
+  ret ^= hpt;
+#endif
+  uintptr_t stk;
+  /* Avoid GCC being too smart.  */
+  asm ("" : "=r" (stk) : "r" (p));
+  stk &= 0x7ffff0;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+  stk <<= (__WORDSIZE - 23);
+#elif __WORDSIZE == 64
+  stk <<= 31;
+#endif
+  ret ^= stk;
+  /* Avoid GCC being too smart.  */
+  p = (unsigned char *) &errno;
+  asm ("" : "=r" (stk) : "r" (p));
+  stk &= 0x7fff00;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+  stk <<= (__WORDSIZE - 29);
+#else
+  stk >>= 8;
+#endif
+  ret ^= stk;
   return ret;
 }
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/epoll_pwait.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/epoll_pwait.c	21 May 2007 20:01:11 -0000	1.1.2.1
@@ -0,0 +1,69 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+
+#ifdef __NR_epoll_pwait
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).
+   The thread's signal mask is temporarily and atomically replaced with
+   the one provided as parameter.  */
+
+int epoll_pwait (int epfd, struct epoll_event *events,
+		 int maxevents, int timeout,
+		 const sigset_t *set)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (epoll_pwait, 6, epfd, events, maxevents, timeout,
+			   set, _NSIG / 8);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (epoll_pwait, 6, epfd, events, maxevents,
+			       timeout, set, _NSIG / 8);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+#else
+
+int epoll_pwait (int epfd, struct epoll_event *events,
+		 int maxevents, int timeout,
+		 const sigset_t *set)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (epoll_pwait)
+
+# include <stub-tag.h>
+#endif
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/futimesat.c	3 Feb 2006 05:26:34 -0000	1.6
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/futimesat.c	3 Feb 2006 09:43:55 -0000	1.1.2.7
@@ -37,14 +37,14 @@ futimesat (fd, file, tvp)
 {
   int result;
 
+  if (file == NULL)
+    return __futimes (fd, tvp);
+
 #ifdef __NR_futimesat
 # ifndef __ASSUME_ATFCTS
   if (__have_atfcts >= 0)
 # endif
     {
-      if (file == NULL)
-	return __futimes (fd, tvp);
-
       result = INLINE_SYSCALL (futimesat, 3, fd, file, tvp);
 # ifndef __ASSUME_ATFCTS
       if (result == -1 && errno == ENOSYS)
@@ -58,22 +58,7 @@ futimesat (fd, file, tvp)
 #ifndef __ASSUME_ATFCTS
   char *buf = NULL;
 
-  if (file == NULL)
-    {
-      static const char procfd[] = "/proc/self/fd/%d";
-      /* Buffer for the path name we are going to use.  It consists of
-	 - the string /proc/self/fd/
-	 - the file descriptor number.
-	 The final NUL is included in the sizeof.   A bit of overhead
-	 due to the format elements compensates for possible negative
-	 numbers.  */
-      size_t buflen = sizeof (procfd) + sizeof (int) * 3;
-      buf = alloca (buflen);
-
-      __snprintf (buf, buflen, procfd, fd);
-      file = buf;
-    }
-  else if (fd != AT_FDCWD && file[0] != '/')
+  if (fd != AT_FDCWD && file[0] != '/')
     {
       size_t filelen = strlen (file);
       static const char procfd[] = "/proc/self/fd/%d/%s";
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/netlinkaccess.h	8 Jan 2006 08:21:15 -0000	1.3
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/netlinkaccess.h	10 Dec 2006 10:51:12 -0000	1.1.2.3
@@ -25,6 +25,24 @@
 
 #include <kernel-features.h>
 
+#ifndef IFA_MAX
+/* 2.6.19 kernel headers helpfully removed some macros and
+   moved lots of stuff into new headers, some of which aren't
+   included by linux/rtnetlink.h.  */
+#include <linux/if_addr.h>
+#endif
+
+#ifndef IFA_RTA
+# define IFA_RTA(r) \
+  ((struct rtattr*) ((char*)(r) + NLMSG_ALIGN (sizeof (struct ifaddrmsg))))
+# define IFA_PAYLOAD(n) NLMSG_PAYLOAD (n, sizeof (struct ifaddrmsg))
+#endif
+
+#ifndef IFLA_RTA
+# define IFLA_RTA(r) \
+  ((struct rtattr*) ((char*)(r) + NLMSG_ALIGN (sizeof (struct ifinfomsg))))
+# define IFLA_PAYLOAD(n) NLMSG_PAYLOAD (n, sizeof (struct ifinfomsg))
+#endif
 
 struct netlink_res
 {
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/paths.h	15 Nov 2000 23:06:47 -0000	1.11
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/paths.h	22 Sep 2004 21:21:08 -0000	1.11.4.1
@@ -61,7 +61,7 @@
 #define	_PATH_TTY	"/dev/tty"
 #define	_PATH_UNIX	"/boot/vmlinux"
 #define _PATH_UTMP	"/var/run/utmp"
-#define	_PATH_VI	"/usr/bin/vi"
+#define	_PATH_VI	"/bin/vi"
 #define _PATH_WTMP	"/var/log/wtmp"
 
 /* Provide trailing slash, since mostly used for building pathnames. */
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/syscalls.list	7 May 2007 03:58:18 -0000	1.130
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/syscalls.list	21 May 2007 20:01:11 -0000	1.114.2.15
@@ -10,7 +10,6 @@ delete_module	EXTRA	delete_module	3	dele
 epoll_create	EXTRA	epoll_create	i:i	epoll_create
 epoll_ctl	EXTRA	epoll_ctl	i:iiip	epoll_ctl
 epoll_wait	EXTRA	epoll_wait	Ci:ipii	epoll_wait
-epoll_pwait	EXTRA	epoll_pwait	Ci:ipiipi	epoll_pwait
 fdatasync	-	fdatasync	Ci:i	fdatasync
 flock		-	flock		i:ii	__flock		flock
 fork		-	fork		i:	__libc_fork	__fork fork
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/tcsetattr.c	10 Sep 2003 19:16:07 -0000	1.16
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/tcsetattr.c	22 Sep 2004 21:21:08 -0000	1.16.2.1
@@ -49,6 +49,7 @@ tcsetattr (fd, optional_actions, termios
 {
   struct __kernel_termios k_termios;
   unsigned long int cmd;
+  int retval;
 
   switch (optional_actions)
     {
@@ -80,6 +81,35 @@ tcsetattr (fd, optional_actions, termios
   memcpy (&k_termios.c_cc[0], &termios_p->c_cc[0],
 	  __KERNEL_NCCS * sizeof (cc_t));
 
-  return INLINE_SYSCALL (ioctl, 3, fd, cmd, &k_termios);
+  retval = INLINE_SYSCALL (ioctl, 3, fd, cmd, &k_termios);
+
+  if (retval == 0 && cmd == TCSETS)
+    {
+      /* The Linux kernel has a bug which silently ignore the invalid
+        c_cflag on pty. We have to check it here. */
+      int save = errno;
+      retval = INLINE_SYSCALL (ioctl, 3, fd, TCGETS, &k_termios);
+      if (retval)
+       {
+         /* We cannot verify if the setting is ok. We don't return
+            an error (?). */
+         __set_errno (save);
+         retval = 0;
+       }
+      else if ((termios_p->c_cflag & (PARENB | CREAD))
+              != (k_termios.c_cflag & (PARENB | CREAD))
+              || ((termios_p->c_cflag & CSIZE)
+                  && ((termios_p->c_cflag & CSIZE)
+                      != (k_termios.c_cflag & CSIZE))))
+       {
+         /* It looks like the Linux kernel silently changed the
+            PARENB/CREAD/CSIZE bits in c_cflag. Report it as an
+            error. */
+         __set_errno (EINVAL);
+         retval = -1;
+       }
+    }
+
+  return retval;
 }
 libc_hidden_def (tcsetattr)
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/i386/clone.S	3 Dec 2006 23:12:36 -0000	1.27
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/i386/clone.S	14 Dec 2006 09:06:34 -0000	1.22.2.6
@@ -120,9 +120,6 @@ L(pseudo_end):
 	ret
 
 L(thread_start):
-	cfi_startproc;
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (eip);
 	/* Note: %esi is zero.  */
 	movl	%esi,%ebp	/* terminate the stack frame */
 #ifdef RESET_PID
@@ -155,7 +152,6 @@ L(nomoregetpid):
 	jmp	L(haspid)
 	.previous
 #endif
-	cfi_endproc;
 
 	cfi_startproc
 PSEUDO_END (BP_SYM (__clone))
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/i386/dl-cache.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/i386/dl-cache.h	22 Sep 2004 21:21:08 -0000	1.1.2.1
@@ -0,0 +1,59 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+static inline int
+is_ia64 (void)
+{
+  unsigned int fl1, fl2;
+
+  /* See if we can use cpuid.  */
+  __asm__ ("pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;"
+           "pushl %0; popfl; pushfl; popl %0; popfl"
+           : "=&r" (fl1), "=&r" (fl2)
+           : "i" (0x00200000));
+  if (((fl1 ^ fl2) & 0x00200000) == 0)
+    return 0;
+
+  /* Host supports cpuid.  See if cpuid gives capabilities, try
+     CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we
+     don't need their CPUID values here, and %ebx may be the PIC
+     register.  */
+  __asm__ ("pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx"
+           : "=a" (fl1) : "0" (0) : "edx", "cc");
+  if (fl1 == 0)
+    return 0;
+
+  /* Invoke CPUID(1), return %edx; caller can examine bits to
+     determine what's supported.  */
+  __asm__ ("pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx"
+           : "=d" (fl2), "=a" (fl1) : "1" (1) : "cc");
+  return (fl2 & (1 << 30)) != 0;
+}
+
+#define arch_startup(argc, argv) \
+  do {									\
+    /* On IA-64, try to execute 64-bit ldconfig if possible.		\
+       This is because the badly designed /emul/ia32-linux hack		\
+       will cause 32-bit ldconfig to do all sorts of weird things.  */	\
+    if (is_ia64 ())							\
+      execv ("/emul/ia32-linux/../../sbin/ldconfig",			\
+	     (char *const *) argv);					\
+  } while (0)
+
+#include_next <dl-cache.h>
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/i386/epoll_pwait.S 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/i386/epoll_pwait.S	21 May 2007 20:01:11 -0000	1.2.2.1
@@ -0,0 +1,80 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H
+#include <bits/errno.h>
+#define _SIGNAL_H
+#include <bits/signum.h>
+
+
+	.text
+ENTRY (epoll_pwait)
+
+#ifdef __NR_epoll_pwait
+
+	/* Save registers.  */
+	pushl %ebp
+	cfi_adjust_cfa_offset (4)
+	pushl %ebx
+	cfi_adjust_cfa_offset (4)
+	pushl %esi
+	cfi_adjust_cfa_offset (4)
+	pushl %edi
+	cfi_adjust_cfa_offset (4)
+	cfi_rel_offset (edi, 0)
+	cfi_rel_offset (esi, 4)
+	cfi_rel_offset (ebx, 8)
+	cfi_rel_offset (ebp, 12)
+
+	movl 20(%esp), %ebx
+	movl 24(%esp), %ecx
+	movl 28(%esp), %edx
+	movl 32(%esp), %esi
+	movl 36(%esp), %edi
+	movl $_NSIG/8, %ebp
+	movl $__NR_epoll_pwait, %eax
+
+	ENTER_KERNEL
+
+	/* Restore registers.  */
+	popl %edi
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (edi)
+	popl %esi
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (esi)
+	popl %ebx
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (ebx)
+	popl %ebp
+	cfi_adjust_cfa_offset (-4)
+	cfi_restore (ebp)
+
+	/* If 0 > %eax > -4096 there was an error.  */
+	cmpl $-4096, %eax
+	ja SYSCALL_ERROR_LABEL
+
+	/* Successful; return the syscall's value.  */
+#else
+	movl $-ENOSYS, %eax
+	jmp SYSCALL_ERROR_LABEL
+#endif
+L(pseudo_end):
+	ret
+PSEUDO_END (epoll_pwait)
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/i386/sync_file_range.S	31 Mar 2006 21:47:34 -0000	1.1
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/i386/sync_file_range.S	21 May 2007 20:01:11 -0000	1.1.2.2
@@ -1,5 +1,5 @@
 /* Selective file content synch'ing.
-   Copyright (C) 2006 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -63,10 +63,10 @@ ENTRY (sync_file_range)
 
 	cmpl	$-4095, %eax
 	jae	SYSCALL_ERROR_LABEL
-L(pseudo_end):
-	ret
 #else
 	movl	$-ENOSYS, %eax
 	jmp	SYSCALL_ERROR_LABEL
 #endif
+L(pseudo_end):
+	ret
 PSEUDO_END (sync_file_range)
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/ia64/dl-cache.h	6 Jul 2001 04:56:17 -0000	1.2
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/ia64/dl-cache.h	22 Sep 2004 21:21:09 -0000	1.2.4.1
@@ -22,4 +22,31 @@
 #define _dl_cache_check_flags(flags) \
   ((flags) == _DL_CACHE_DEFAULT_ID)
 
+#define EMUL_HACK "/emul/ia32-linux"
+
+#define arch_startup(argc, argv) unlink (EMUL_HACK LD_SO_CACHE)
+
+#define add_arch_dirs(config_file) \
+  do {							\
+    int save_verbose = opt_verbose;			\
+    opt_verbose = 0;					\
+							\
+    parse_conf (config_file, EMUL_HACK, true);		\
+							\
+    /* Always add the standard search paths.  */	\
+    add_system_dir (EMUL_HACK SLIBDIR);			\
+    if (strcmp (SLIBDIR, LIBDIR))			\
+      add_system_dir (EMUL_HACK LIBDIR);		\
+							\
+    char emul_config_file[strlen (config_file)		\
+			  + sizeof EMUL_HACK];		\
+    strcpy (mempcpy (emul_config_file, EMUL_HACK,	\
+		     strlen (EMUL_HACK)), config_file);	\
+							\
+    if (! access (emul_config_file, R_OK))		\
+      parse_conf (emul_config_file, EMUL_HACK, true);	\
+							\
+    opt_verbose = save_verbose;				\
+  } while (0)
+
 #include_next <dl-cache.h>
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/ia64/dl-procinfo.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/ia64/dl-procinfo.c	22 Sep 2004 21:21:09 -0000	1.1.2.1
@@ -0,0 +1,5 @@
+#ifdef IS_IN_ldconfig
+#include <sysdeps/i386/dl-procinfo.c>
+#else
+#include <sysdeps/generic/dl-procinfo.c>
+#endif
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/ia64/dl-procinfo.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/ia64/dl-procinfo.h	22 Sep 2004 21:21:09 -0000	1.1.2.1
@@ -0,0 +1,5 @@
+#ifdef IS_IN_ldconfig
+#include <sysdeps/unix/sysv/linux/i386/dl-procinfo.h>
+#else
+#include <sysdeps/generic/dl-procinfo.h>
+#endif
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/ia64/ldd-rewrite.sed	17 Jan 2002 06:49:28 -0000	1.2
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/ia64/ldd-rewrite.sed	22 Sep 2004 21:21:09 -0000	1.2.2.1
@@ -1 +1 @@
-s_^\(RTLDLIST=\)\([^ 	]*\)-ia64\(\.so\.[0-9.]*\)[ 	]*$_\1"\2-ia64\3 \2\3"_
+s_^\(RTLDLIST=\)\([^ 	]*\)-ia64\(\.so\.[0-9.]*\)[ 	]*$_\1"\2-ia64\3 /emul/ia32-linux\2\3"_
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/x86_64/clone.S	3 Dec 2006 23:12:36 -0000	1.7
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/x86_64/clone.S	14 Dec 2006 09:06:34 -0000	1.4.2.4
@@ -89,9 +89,6 @@ L(pseudo_end):
 	ret
 
 L(thread_start):
-	cfi_startproc;
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (rip);
 	/* Clear the frame pointer.  The ABI suggests this be done, to mark
 	   the outermost frame obviously.  */
 	xorl	%ebp, %ebp
@@ -116,7 +113,6 @@ L(thread_start):
 	/* Call exit with return value from function call. */
 	movq	%rax, %rdi
 	call	HIDDEN_JUMPTARGET (_exit)
-	cfi_endproc;
 
 	cfi_startproc;
 PSEUDO_END (BP_SYM (__clone))
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/x86_64/sysconf.c	10 Nov 2006 07:31:55 -0000	1.7
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/x86_64/sysconf.c	7 Jul 2007 21:28:56 -0000	1.2.2.7
@@ -1,5 +1,5 @@
 /* Get file-specific information about a file.  Linux version.
-   Copyright (C) 2003, 2004, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,328 +24,17 @@
 
 
 static long int linux_sysconf (int name);
-
-
-static const struct intel_02_cache_info
-{
-  unsigned int idx;
-  int name;
-  long int size;
-  long int assoc;
-  long int linesize;
-} intel_02_known[] =
-  {
-    { 0x06, _SC_LEVEL1_ICACHE_SIZE, 8192, 4, 32 },
-    { 0x08, _SC_LEVEL1_ICACHE_SIZE, 16384, 4, 32 },
-    { 0x0a, _SC_LEVEL1_DCACHE_SIZE, 8192, 2, 32 },
-    { 0x0c, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 32 },
-    { 0x22, _SC_LEVEL3_CACHE_SIZE, 524288, 4, 64 },
-    { 0x23, _SC_LEVEL3_CACHE_SIZE, 1048576, 8, 64 },
-    { 0x25, _SC_LEVEL3_CACHE_SIZE, 2097152, 8, 64 },
-    { 0x29, _SC_LEVEL3_CACHE_SIZE, 4194304, 8, 64 },
-    { 0x2c, _SC_LEVEL1_DCACHE_SIZE, 32768, 8, 64 },
-    { 0x30, _SC_LEVEL1_ICACHE_SIZE, 32768, 8, 64 },
-    { 0x39, _SC_LEVEL2_CACHE_SIZE, 131072, 4, 64 },
-    { 0x3a, _SC_LEVEL2_CACHE_SIZE, 196608, 6, 64 },
-    { 0x3b, _SC_LEVEL2_CACHE_SIZE, 131072, 2, 64 },
-    { 0x3c, _SC_LEVEL2_CACHE_SIZE, 262144, 4, 64 },
-    { 0x3d, _SC_LEVEL2_CACHE_SIZE, 393216, 6, 64 },
-    { 0x3e, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 64 },
-    { 0x41, _SC_LEVEL2_CACHE_SIZE, 131072, 4, 32 },
-    { 0x42, _SC_LEVEL2_CACHE_SIZE, 262144, 4, 32 },
-    { 0x43, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 32 },
-    { 0x44, _SC_LEVEL2_CACHE_SIZE, 1048576, 4, 32 },
-    { 0x45, _SC_LEVEL2_CACHE_SIZE, 2097152, 4, 32 },
-    { 0x46, _SC_LEVEL3_CACHE_SIZE, 4194304, 4, 64 },
-    { 0x47, _SC_LEVEL3_CACHE_SIZE, 8388608, 8, 64 },
-    { 0x49, _SC_LEVEL2_CACHE_SIZE, 4194304, 16, 64 },
-    { 0x4a, _SC_LEVEL3_CACHE_SIZE, 6291456, 12, 64 },
-    { 0x4b, _SC_LEVEL3_CACHE_SIZE, 8388608, 16, 64 },
-    { 0x4c, _SC_LEVEL3_CACHE_SIZE, 12582912, 12, 64 },
-    { 0x4d, _SC_LEVEL3_CACHE_SIZE, 16777216, 16, 64 },
-    { 0x60, _SC_LEVEL1_DCACHE_SIZE, 16384, 8, 64 },
-    { 0x66, _SC_LEVEL1_DCACHE_SIZE, 8192, 4, 64 },
-    { 0x67, _SC_LEVEL1_DCACHE_SIZE, 16384, 4, 64 },
-    { 0x68, _SC_LEVEL1_DCACHE_SIZE, 32768, 4, 64 },
-    { 0x78, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
-    { 0x79, _SC_LEVEL2_CACHE_SIZE, 131072, 8, 64 },
-    { 0x7a, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 64 },
-    { 0x7b, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 64 },
-    { 0x7c, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
-    { 0x7d, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 64 },
-    { 0x7f, _SC_LEVEL2_CACHE_SIZE, 524288, 2, 64 },
-    { 0x82, _SC_LEVEL2_CACHE_SIZE, 262144, 8, 32 },
-    { 0x83, _SC_LEVEL2_CACHE_SIZE, 524288, 8, 32 },
-    { 0x84, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 32 },
-    { 0x85, _SC_LEVEL2_CACHE_SIZE, 2097152, 8, 32 },
-    { 0x86, _SC_LEVEL2_CACHE_SIZE, 524288, 4, 64 },
-    { 0x87, _SC_LEVEL2_CACHE_SIZE, 1048576, 8, 64 },
-  };
-#define nintel_02_known (sizeof (intel_02_known) / sizeof (intel_02_known[0]))
-
-
-static int
-intel_02_known_compare (const void *p1, const void *p2)
-{
-  const struct intel_02_cache_info *i1;
-  const struct intel_02_cache_info *i2;
-
-  i1 = (const struct intel_02_cache_info *) p1;
-  i2 = (const struct intel_02_cache_info *) p2;
-
-  if (i1->idx == i2->idx)
-    return 0;
-
-  return i1->idx < i2->idx ? -1 : 1;
-}
-
-
-static long int
-__attribute__ ((noinline))
-intel_check_word (int name, unsigned int value, bool *has_level_2,
-		  bool *no_level_2_or_3)
-{
-  if ((value & 0x80000000) != 0)
-    /* The register value is reserved.  */
-    return 0;
-
-  /* Fold the name.  The _SC_ constants are always in the order SIZE,
-     ASSOC, LINESIZE.  */
-  int folded_name = (_SC_LEVEL1_ICACHE_SIZE
-		     + ((name - _SC_LEVEL1_ICACHE_SIZE) / 3) * 3);
-
-  while (value != 0)
-    {
-      unsigned int byte = value & 0xff;
-
-      if (byte == 0x40)
-	{
-	  *no_level_2_or_3 = true;
-
-	  if (folded_name == _SC_LEVEL3_CACHE_SIZE)
-	    /* No need to look further.  */
-	    break;
-	}
-      else
-	{
-	  if (byte == 0x49 && folded_name == _SC_LEVEL3_CACHE_SIZE)
-	    {
-	      /* Intel reused this value.  For family 15, model 6 it
-		 specifies the 3rd level cache.  Otherwise the 2nd
-		 level cache.  */
-	      unsigned int eax;
-	      unsigned int ebx;
-	      unsigned int ecx;
-	      unsigned int edx;
-	      asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
-			    : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
-			    : "0" (1));
-
-	      unsigned int family = ((eax >> 20) & 0xff) + ((eax >> 8) & 0xf);
-	      unsigned int model = ((((eax >>16) & 0xf) << 4)
-				    + ((eax >> 4) & 0xf));
-	      if (family == 15 && model == 6)
-		{
-		  /* The level 3 cache is encoded for this model like
-		     the level 2 cache is for other models.  Pretend
-		     the caller asked for the level 2 cache.  */
-		  name = (_SC_LEVEL2_CACHE_SIZE
-			  + (name - _SC_LEVEL3_CACHE_SIZE));
-		  folded_name = _SC_LEVEL3_CACHE_SIZE;
-		}
-	    }
-
-	  struct intel_02_cache_info *found;
-	  struct intel_02_cache_info search;
-
-	  search.idx = byte;
-	  found = bsearch (&search, intel_02_known, nintel_02_known,
-			   sizeof (intel_02_known[0]), intel_02_known_compare);
-	  if (found != NULL)
-	    {
-	      if (found->name == folded_name)
-		{
-		  unsigned int offset = name - folded_name;
-
-		  if (offset == 0)
-		    /* Cache size.  */
-		    return found->size;
-		  if (offset == 1)
-		    return found->assoc;
-
-		  assert (offset == 2);
-		  return found->linesize;
-		}
-
-	      if (found->name == _SC_LEVEL2_CACHE_SIZE)
-		*has_level_2 = true;
-	    }
-	}
-
-      /* Next byte for the next round.  */
-      value >>= 8;
-    }
-
-  /* Nothing found.  */
-  return 0;
-}
-
-
-static long int __attribute__ ((noinline))
-handle_intel (int name, unsigned int maxidx)
-{
-  assert (maxidx >= 2);
-
-  /* OK, we can use the CPUID instruction to get all info about the
-     caches.  */
-  unsigned int cnt = 0;
-  unsigned int max = 1;
-  long int result = 0;
-  bool no_level_2_or_3 = false;
-  bool has_level_2 = false;
-  while (cnt++ < max)
-    {
-      unsigned int eax;
-      unsigned int ebx;
-      unsigned int ecx;
-      unsigned int edx;
-      asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
-		    : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
-		    : "0" (2));
-
-      /* The low byte of EAX in the first round contain the number of
-	 rounds we have to make.  At least one, the one we are already
-	 doing.  */
-      if (cnt == 1)
-	{
-	  max = eax & 0xff;
-	  eax &= 0xffffff00;
-	}
-
-      /* Process the individual registers' value.  */
-      result = intel_check_word (name, eax, &has_level_2, &no_level_2_or_3);
-      if (result != 0)
-	return result;
-
-      result = intel_check_word (name, ebx, &has_level_2, &no_level_2_or_3);
-      if (result != 0)
-	return result;
-
-      result = intel_check_word (name, ecx, &has_level_2, &no_level_2_or_3);
-      if (result != 0)
-	return result;
-
-      result = intel_check_word (name, edx, &has_level_2, &no_level_2_or_3);
-      if (result != 0)
-	return result;
-    }
-
-  if (name >= _SC_LEVEL2_CACHE_SIZE && name <= _SC_LEVEL3_CACHE_LINESIZE
-      && no_level_2_or_3)
-    return -1;
-
-  return 0;
-}
-
-
-static long int __attribute__ ((noinline))
-handle_amd (int name)
-{
-  unsigned int eax;
-  unsigned int ebx;
-  unsigned int ecx;
-  unsigned int edx;
-  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
-		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
-		: "0" (0x80000000));
-
-  if (name >= _SC_LEVEL3_CACHE_SIZE)
-    return 0;
-
-  unsigned int fn = 0x80000005 + (name >= _SC_LEVEL2_CACHE_SIZE);
-  if (eax < fn)
-    return 0;
-
-  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
-		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
-		: "0" (fn));
-
-  if (name < _SC_LEVEL1_DCACHE_SIZE)
-    {
-      name += _SC_LEVEL1_DCACHE_SIZE - _SC_LEVEL1_ICACHE_SIZE;
-      ecx = edx;
-    }
-
-  switch (name)
-    {
-    case _SC_LEVEL1_DCACHE_SIZE:
-      return (ecx >> 14) & 0x3fc00;
-    case _SC_LEVEL1_DCACHE_ASSOC:
-      ecx >>= 16;
-      if ((ecx & 0xff) == 0xff)
-	/* Fully associative.  */
-	return (ecx << 2) & 0x3fc00;
-      return ecx & 0xff;
-    case _SC_LEVEL1_DCACHE_LINESIZE:
-      return ecx & 0xff;
-    case _SC_LEVEL2_CACHE_SIZE:
-      return (ecx & 0xf000) == 0 ? 0 : (ecx >> 6) & 0x3fffc00;
-    case _SC_LEVEL2_CACHE_ASSOC:
-      ecx >>= 12;
-      switch (ecx & 0xf)
-        {
-        case 0:
-        case 1:
-        case 2:
-        case 4:
-	  return ecx & 0xf;
-	case 6:
-	  return 8;
-	case 8:
-	  return 16;
-	case 0xf:
-	  return (ecx << 6) & 0x3fffc00;
-	default:
-	  return 0;
-        }
-    case _SC_LEVEL2_CACHE_LINESIZE:
-      return (ecx & 0xf000) == 0 ? 0 : ecx & 0xff;
-    default:
-      assert (! "cannot happen");
-    }
-  return -1;
-}
+extern long int __cache_sysconf (int) attribute_hidden;
 
 
 /* Get the value of the system variable NAME.  */
 long int
 __sysconf (int name)
 {
-  /* We only handle the cache information here (for now).  */
-  if (name < _SC_LEVEL1_ICACHE_SIZE || name > _SC_LEVEL4_CACHE_LINESIZE)
-    return linux_sysconf (name);
-
-  /* Find out what brand of processor.  */
-  unsigned int eax;
-  unsigned int ebx;
-  unsigned int ecx;
-  unsigned int edx;
-  asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
-		: "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
-		: "0" (0));
-
-  /* This spells out "GenuineIntel".  */
-  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
-    return handle_intel (name, eax);
-
-  /* This spells out "AuthenticAMD".  */
-  if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
-    return handle_amd (name);
-
-  // XXX Fill in more vendors.
+  if (name >= _SC_LEVEL1_ICACHE_SIZE && name <= _SC_LEVEL4_CACHE_LINESIZE)
+    return __cache_sysconf (name);
 
-  /* CPU not known, we have no information.  */
-  return 0;
+  return linux_sysconf (name);
 }
 
 /* Now the generic Linux version.  */
--- glibc-20070515T2025/sysdeps/unix/sysv/linux/x86_64/sys/epoll.h	22 Feb 2006 05:48:50 -0000	1.3
+++ glibc-20070515T2025-fedora/sysdeps/unix/sysv/linux/x86_64/sys/epoll.h	21 May 2007 20:01:11 -0000	1.2.2.2
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002,2003,2004,2005,2006 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -22,6 +22,14 @@
 #include <stdint.h>
 #include <sys/types.h>
 
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
 
 enum EPOLL_EVENTS
   {
@@ -105,6 +113,16 @@ extern int epoll_ctl (int __epfd, int __
 extern int epoll_wait (int __epfd, struct epoll_event *__events,
 		       int __maxevents, int __timeout);
 
+
+/* Same as epoll_wait, but the thread's signal mask is temporarily
+   and atomically replaced with the one provided as parameter.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_pwait (int __epfd, struct epoll_event *__events,
+			int __maxevents, int __timeout,
+			__const __sigset_t *__ss);
+
 __END_DECLS
 
 #endif /* sys/epoll.h */
--- glibc-20070515T2025/sysdeps/x86_64/Makefile	16 Aug 2004 06:46:14 -0000	1.4
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/Makefile	7 Jul 2007 16:06:42 -0000	1.4.2.1
@@ -9,3 +9,7 @@ endif
 ifeq ($(subdir),gmon)
 sysdep_routines += _mcount
 endif
+
+ifeq ($(subdir),string)
+sysdep_routines += cacheinfo
+endif
--- glibc-20070515T2025/sysdeps/x86_64/cacheinfo.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/cacheinfo.c	7 Jul 2007 16:06:42 -0000	1.2.2.1
@@ -0,0 +1,451 @@
+/* x86_64 cache info.
+   Copyright (C) 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.
+*/
+
+#include <assert.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+static const struct intel_02_cache_info
+{
+  unsigned int idx;
+  int name;
+  long int size;
+  long int assoc;
+  long int linesize;
+} intel_02_known [] =
+  {
+    { 0x06, _SC_LEVEL1_ICACHE_SIZE,    8192,  4, 32 },
+    { 0x08, _SC_LEVEL1_ICACHE_SIZE,   16384,  4, 32 },
+    { 0x0a, _SC_LEVEL1_DCACHE_SIZE,    8192,  2, 32 },
+    { 0x0c, _SC_LEVEL1_DCACHE_SIZE,   16384,  4, 32 },
+    { 0x22, _SC_LEVEL3_CACHE_SIZE,   524288,  4, 64 },
+    { 0x23, _SC_LEVEL3_CACHE_SIZE,  1048576,  8, 64 },
+    { 0x25, _SC_LEVEL3_CACHE_SIZE,  2097152,  8, 64 },
+    { 0x29, _SC_LEVEL3_CACHE_SIZE,  4194304,  8, 64 },
+    { 0x2c, _SC_LEVEL1_DCACHE_SIZE,   32768,  8, 64 },
+    { 0x30, _SC_LEVEL1_ICACHE_SIZE,   32768,  8, 64 },
+    { 0x39, _SC_LEVEL2_CACHE_SIZE,   131072,  4, 64 },
+    { 0x3a, _SC_LEVEL2_CACHE_SIZE,   196608,  6, 64 },
+    { 0x3b, _SC_LEVEL2_CACHE_SIZE,   131072,  2, 64 },
+    { 0x3c, _SC_LEVEL2_CACHE_SIZE,   262144,  4, 64 },
+    { 0x3d, _SC_LEVEL2_CACHE_SIZE,   393216,  6, 64 },
+    { 0x3e, _SC_LEVEL2_CACHE_SIZE,   524288,  4, 64 },
+    { 0x41, _SC_LEVEL2_CACHE_SIZE,   131072,  4, 32 },
+    { 0x42, _SC_LEVEL2_CACHE_SIZE,   262144,  4, 32 },
+    { 0x43, _SC_LEVEL2_CACHE_SIZE,   524288,  4, 32 },
+    { 0x44, _SC_LEVEL2_CACHE_SIZE,  1048576,  4, 32 },
+    { 0x45, _SC_LEVEL2_CACHE_SIZE,  2097152,  4, 32 },
+    { 0x46, _SC_LEVEL3_CACHE_SIZE,  4194304,  4, 64 },
+    { 0x47, _SC_LEVEL3_CACHE_SIZE,  8388608,  8, 64 },
+    { 0x49, _SC_LEVEL2_CACHE_SIZE,  4194304, 16, 64 },
+    { 0x4a, _SC_LEVEL3_CACHE_SIZE,  6291456, 12, 64 },
+    { 0x4b, _SC_LEVEL3_CACHE_SIZE,  8388608, 16, 64 },
+    { 0x4c, _SC_LEVEL3_CACHE_SIZE, 12582912, 12, 64 },
+    { 0x4d, _SC_LEVEL3_CACHE_SIZE, 16777216, 16, 64 },
+    { 0x60, _SC_LEVEL1_DCACHE_SIZE,   16384,  8, 64 },
+    { 0x66, _SC_LEVEL1_DCACHE_SIZE,    8192,  4, 64 },
+    { 0x67, _SC_LEVEL1_DCACHE_SIZE,   16384,  4, 64 },
+    { 0x68, _SC_LEVEL1_DCACHE_SIZE,   32768,  4, 64 },
+    { 0x78, _SC_LEVEL2_CACHE_SIZE,  1048576,  8, 64 },
+    { 0x79, _SC_LEVEL2_CACHE_SIZE,   131072,  8, 64 },
+    { 0x7a, _SC_LEVEL2_CACHE_SIZE,   262144,  8, 64 },
+    { 0x7b, _SC_LEVEL2_CACHE_SIZE,   524288,  8, 64 },
+    { 0x7c, _SC_LEVEL2_CACHE_SIZE,  1048576,  8, 64 },
+    { 0x7d, _SC_LEVEL2_CACHE_SIZE,  2097152,  8, 64 },
+    { 0x7f, _SC_LEVEL2_CACHE_SIZE,   524288,  2, 64 },
+    { 0x82, _SC_LEVEL2_CACHE_SIZE,   262144,  8, 32 },
+    { 0x83, _SC_LEVEL2_CACHE_SIZE,   524288,  8, 32 },
+    { 0x84, _SC_LEVEL2_CACHE_SIZE,  1048576,  8, 32 },
+    { 0x85, _SC_LEVEL2_CACHE_SIZE,  2097152,  8, 32 },
+    { 0x86, _SC_LEVEL2_CACHE_SIZE,   524288,  4, 64 },
+    { 0x87, _SC_LEVEL2_CACHE_SIZE,  1048576,  8, 64 },
+  };
+
+#define nintel_02_known (sizeof (intel_02_known) / sizeof (intel_02_known [0]))
+
+static int
+intel_02_known_compare (const void *p1, const void *p2)
+{
+  const struct intel_02_cache_info *i1;
+  const struct intel_02_cache_info *i2;
+
+  i1 = (const struct intel_02_cache_info *) p1;
+  i2 = (const struct intel_02_cache_info *) p2;
+
+  if (i1->idx == i2->idx)
+    return 0;
+
+  return i1->idx < i2->idx ? -1 : 1;
+}
+
+
+static long int
+__attribute__ ((noinline))
+intel_check_word (int name, unsigned int value, bool *has_level_2,
+		  bool *no_level_2_or_3)
+{
+  if ((value & 0x80000000) != 0)
+    /* The register value is reserved.  */
+    return 0;
+
+  /* Fold the name.  The _SC_ constants are always in the order SIZE,
+     ASSOC, LINESIZE.  */
+  int folded_name = (_SC_LEVEL1_ICACHE_SIZE
+		     + ((name - _SC_LEVEL1_ICACHE_SIZE) / 3) * 3);
+
+  while (value != 0)
+    {
+      unsigned int byte = value & 0xff;
+
+      if (byte == 0x40)
+	{
+	  *no_level_2_or_3 = true;
+
+	  if (folded_name == _SC_LEVEL3_CACHE_SIZE)
+	    /* No need to look further.  */
+	    break;
+	}
+      else
+	{
+	  if (byte == 0x49 && folded_name == _SC_LEVEL3_CACHE_SIZE)
+	    {
+	      /* Intel reused this value.  For family 15, model 6 it
+		 specifies the 3rd level cache.  Otherwise the 2nd
+		 level cache.  */
+	      unsigned int eax;
+	      unsigned int ebx;
+	      unsigned int ecx;
+	      unsigned int edx;
+	      asm volatile ("cpuid"
+			    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+			    : "0" (1));
+
+	      unsigned int family = ((eax >> 20) & 0xff) + ((eax >> 8) & 0xf);
+	      unsigned int model = ((((eax >>16) & 0xf) << 4)
+				    + ((eax >> 4) & 0xf));
+	      if (family == 15 && model == 6)
+		{
+		  /* The level 3 cache is encoded for this model like
+		     the level 2 cache is for other models.  Pretend
+		     the caller asked for the level 2 cache.  */
+		  name = (_SC_LEVEL2_CACHE_SIZE
+			  + (name - _SC_LEVEL3_CACHE_SIZE));
+		  folded_name = _SC_LEVEL3_CACHE_SIZE;
+		}
+	    }
+
+	  struct intel_02_cache_info *found;
+	  struct intel_02_cache_info search;
+
+	  search.idx = byte;
+	  found = bsearch (&search, intel_02_known, nintel_02_known,
+			   sizeof (intel_02_known[0]), intel_02_known_compare);
+	  if (found != NULL)
+	    {
+	      if (found->name == folded_name)
+		{
+		  unsigned int offset = name - folded_name;
+
+		  if (offset == 0)
+		    /* Cache size.  */
+		    return found->size;
+		  if (offset == 1)
+		    return found->assoc;
+
+		  assert (offset == 2);
+		  return found->linesize;
+		}
+
+	      if (found->name == _SC_LEVEL2_CACHE_SIZE)
+		*has_level_2 = true;
+	    }
+	}
+
+      /* Next byte for the next round.  */
+      value >>= 8;
+    }
+
+  /* Nothing found.  */
+  return 0;
+}
+
+
+static long int __attribute__ ((noinline))
+handle_intel (int name, unsigned int maxidx)
+{
+  assert (maxidx >= 2);
+
+  /* OK, we can use the CPUID instruction to get all info about the
+     caches.  */
+  unsigned int cnt = 0;
+  unsigned int max = 1;
+  long int result = 0;
+  bool no_level_2_or_3 = false;
+  bool has_level_2 = false;
+
+  while (cnt++ < max)
+    {
+      unsigned int eax;
+      unsigned int ebx;
+      unsigned int ecx;
+      unsigned int edx;
+      asm volatile ("cpuid"
+		    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		    : "0" (2));
+
+      /* The low byte of EAX in the first round contain the number of
+	 rounds we have to make.  At least one, the one we are already
+	 doing.  */
+      if (cnt == 1)
+	{
+	  max = eax & 0xff;
+	  eax &= 0xffffff00;
+	}
+
+      /* Process the individual registers' value.  */
+      result = intel_check_word (name, eax, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ebx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, ecx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+
+      result = intel_check_word (name, edx, &has_level_2, &no_level_2_or_3);
+      if (result != 0)
+	return result;
+    }
+
+  if (name >= _SC_LEVEL2_CACHE_SIZE && name <= _SC_LEVEL3_CACHE_LINESIZE
+      && no_level_2_or_3)
+    return -1;
+
+  return 0;
+}
+
+
+static long int __attribute__ ((noinline))
+handle_amd (int name)
+{
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("cpuid"
+		: "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0x80000000));
+
+  if (name >= _SC_LEVEL3_CACHE_SIZE)
+    return 0;
+
+  unsigned int fn = 0x80000005 + (name >= _SC_LEVEL2_CACHE_SIZE);
+  if (eax < fn)
+    return 0;
+
+  asm volatile ("cpuid"
+		: "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (fn));
+
+  if (name < _SC_LEVEL1_DCACHE_SIZE)
+    {
+      name += _SC_LEVEL1_DCACHE_SIZE - _SC_LEVEL1_ICACHE_SIZE;
+      ecx = edx;
+    }
+
+  switch (name)
+    {
+    case _SC_LEVEL1_DCACHE_SIZE:
+      return (ecx >> 14) & 0x3fc00;
+    case _SC_LEVEL1_DCACHE_ASSOC:
+      ecx >>= 16;
+      if ((ecx & 0xff) == 0xff)
+	/* Fully associative.  */
+	return (ecx << 2) & 0x3fc00;
+      return ecx & 0xff;
+    case _SC_LEVEL1_DCACHE_LINESIZE:
+      return ecx & 0xff;
+    case _SC_LEVEL2_CACHE_SIZE:
+      return (ecx & 0xf000) == 0 ? 0 : (ecx >> 6) & 0x3fffc00;
+    case _SC_LEVEL2_CACHE_ASSOC:
+      ecx >>= 12;
+      switch (ecx & 0xf)
+        {
+        case 0:
+        case 1:
+        case 2:
+        case 4:
+	  return ecx & 0xf;
+	case 6:
+	  return 8;
+	case 8:
+	  return 16;
+	case 0xf:
+	  return (ecx << 6) & 0x3fffc00;
+	default:
+	  return 0;
+        }
+    case _SC_LEVEL2_CACHE_LINESIZE:
+      return (ecx & 0xf000) == 0 ? 0 : ecx & 0xff;
+    default:
+      assert (! "cannot happen");
+    }
+  return -1;
+}
+
+
+/* Get the value of the system variable NAME.  */
+long int
+attribute_hidden
+__cache_sysconf (int name)
+{
+  /* Find out what brand of processor.  */
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  asm volatile ("cpuid"
+		: "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0));
+
+  /* This spells out "GenuineIntel".  */
+  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
+    return handle_intel (name, eax);
+
+  /* This spells out "AuthenticAMD".  */
+  if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
+    return handle_amd (name);
+
+  // XXX Fill in more vendors.
+
+  /* CPU not known, we have no information.  */
+  return 0;
+}
+
+
+/* Half the core cache size for use in memory and string routines, typically
+   L1 size. */
+long int __x86_64_core_cache_size_half attribute_hidden = 32 * 1024 / 2;
+/* Shared cache size for use in memory and string routines, typically
+   L2 or L3 size. */
+long int __x86_64_shared_cache_size_half attribute_hidden = 1024 * 1024 / 2;
+/* PREFETCHW support flag for use in memory and string routines. */
+int __x86_64_prefetchw attribute_hidden;
+
+
+static void
+__attribute__((constructor))
+init_cacheinfo (void)
+{
+  /* Find out what brand of processor.  */
+  unsigned int eax;
+  unsigned int ebx;
+  unsigned int ecx;
+  unsigned int edx;
+  int max_cpuid;
+  int max_cpuid_ex;
+  long int core = -1;
+  long int shared = -1;
+  unsigned int level;
+  unsigned int threads = 0;
+
+  asm volatile ("cpuid"
+		: "=a" (max_cpuid), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		: "0" (0));
+
+  /* This spells out "GenuineIntel".  */
+  if (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)
+    {
+      core = handle_intel (_SC_LEVEL1_DCACHE_SIZE, max_cpuid);
+
+      /* Try L3 first. */
+      level  = 3;
+      shared = handle_intel (_SC_LEVEL3_CACHE_SIZE, max_cpuid);
+
+      if (shared <= 0)
+        {
+	  /* Try L2 otherwise. */
+          level  = 2;
+          shared = handle_intel (_SC_LEVEL2_CACHE_SIZE, max_cpuid);
+	}
+
+      /* Figure out the number of logical threads that share the
+	 highest cache level. */
+      if (max_cpuid >= 4)
+        {
+	  int i = 0;
+
+	  /* Query until desired cache level is enumerated. */
+	  do
+	    {
+              asm volatile ("cpuid"
+		            : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		            : "0" (4), "2" (i++));
+	    }
+          while (((eax >> 5) & 0x7) != level);
+
+	  threads = ((eax >> 14) & 0x3ff) + 1;
+	}
+      else
+        {
+	  /* Assume that all logical threads share the highest cache level. */
+          asm volatile ("cpuid"
+		        : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		        : "0" (1));
+
+	  threads = (ebx >> 16) & 0xff;
+	}
+
+      /* Cap usage of highest cache level to the number of supported
+	 threads. */
+      if (shared > 0 && threads > 0)
+        shared /= threads;
+    }
+  /* This spells out "AuthenticAMD".  */
+  else if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)
+    {
+      core   = handle_amd (_SC_LEVEL1_DCACHE_SIZE);
+      shared = handle_amd (_SC_LEVEL2_CACHE_SIZE);
+
+      asm volatile ("cpuid"
+		    : "=a" (max_cpuid_ex), "=b" (ebx), "=c" (ecx), "=d" (edx)
+		    : "0" (0x80000000));
+
+      if (max_cpuid_ex >= 0x80000001)
+	{
+	  asm volatile ("cpuid"
+			: "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
+			: "0" (0x80000001));
+	  /*  PREFETCHW     || 3DNow! */
+	  if ((ecx & 0x100) || (edx & 0x80000000))
+	    __x86_64_prefetchw = -1;
+	}
+    }
+
+  if (core > 0)
+    __x86_64_core_cache_size_half = core / 2;
+
+  if (shared > 0)
+    __x86_64_shared_cache_size_half = shared / 2;
+}
--- glibc-20070515T2025/sysdeps/x86_64/ldbl2mpn.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/ldbl2mpn.c	7 Jul 2007 19:59:56 -0000	1.1.2.1
@@ -0,0 +1 @@
+#include "../i386/ldbl2mpn.c"
--- glibc-20070515T2025/sysdeps/x86_64/memcpy.S	18 Oct 2004 04:17:08 -0000	1.5
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/memcpy.S	7 Jul 2007 16:06:42 -0000	1.4.2.2
@@ -1,7 +1,10 @@
-/* Highly optimized version for x86-64.
-   Copyright (C) 1997, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+/*
+   Optimized memcpy for x86-64.
+
+   Copyright (C) 2007 Free Software Foundation, Inc.
+   Contributed by Evandro Menezes <evandro.menezes@amd.com>, 2007.
+
    This file is part of the GNU C Library.
-   Based on i586 version contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -16,86 +19,556 @@
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
+   02111-1307 USA.
+*/
 
 #include <sysdep.h>
 #include "asm-syntax.h"
-#include "bp-sym.h"
-#include "bp-asm.h"
 
-/* BEWARE: `#ifdef memcpy' means that memcpy is redefined as `mempcpy',
-   and the return value is the byte after the last one copied in
-   the destination. */
-#define MEMPCPY_P (defined memcpy)
+/* Stack slots in the red-zone. */
+
+#ifdef USE_AS_MEMPCPY
+#  define RETVAL	(0)
+#else
+#  define RETVAL	(-8)
+#endif
+#define SAVE0	(RETVAL - 8)
+#define SAVE1	(SAVE0	- 8)
+#define SAVE2	(SAVE1	- 8)
+#define SAVE3	(SAVE2	- 8)
 
         .text
+
 #if defined PIC && !defined NOT_IN_libc
 ENTRY (__memcpy_chk)
+
 	cmpq	%rdx, %rcx
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
+
 END (__memcpy_chk)
 #endif
-ENTRY (BP_SYM (memcpy))
-	/* Cutoff for the big loop is a size of 32 bytes since otherwise
-	   the loop will never be entered.  */
+
+ENTRY(memcpy)				/* (void *, const void*, size_t) */
+
+/* Handle tiny blocks. */
+
+L(1try):				/* up to 32B */
 	cmpq	$32, %rdx
-	movq	%rdx, %rcx
-#if !MEMPCPY_P
-	movq	%rdi, %r10	/* Save value. */
+#ifndef USE_AS_MEMPCPY
+	movq	%rdi, %rax		/* save return value */
 #endif
+	jae	L(1after)
 
-	/* We need this in any case.  */
-	cld
+L(1):					/* 1-byte once */
+	testb	$1, %dl
+	jz	L(1a)
 
-	jbe	1f
+	movzbl	(%rsi),	%ecx
+	movb	%cl, (%rdi)
 
-	/* Align destination.  */
-	movq	%rdi, %rax
-	negq	%rax
-	andq	$7, %rax
-	subq	%rax, %rcx
-	xchgq	%rax, %rcx
+	incq	%rsi
+	incq	%rdi
+
+	.p2align 4,, 4
+
+L(1a):					/* 2-byte once */
+	testb	$2, %dl
+	jz	L(1b)
+
+	movzwl	(%rsi),	%ecx
+	movw	%cx, (%rdi)
 
-	rep; movsb
+	addq	$2, %rsi
+	addq	$2, %rdi
 
-	movq	%rax, %rcx
-	subq	$32, %rcx
-	js	2f
+	.p2align 4,, 4
+
+L(1b):					/* 4-byte once */
+	testb	$4, %dl
+	jz	L(1c)
+
+	movl	(%rsi),	%ecx
+	movl	%ecx, (%rdi)
+
+	addq	$4, %rsi
+	addq	$4, %rdi
+
+	.p2align 4,, 4
+
+L(1c):					/* 8-byte once */
+	testb	$8, %dl
+	jz	L(1d)
+
+	movq	(%rsi), %rcx
+	movq	%rcx, (%rdi)
+
+	addq	$8, %rsi
+	addq	$8, %rdi
+
+	.p2align 4,, 4
+
+L(1d):					/* 16-byte loop */
+	andl	$0xf0, %edx
+	jz	L(exit)
 
 	.p2align 4
-3:
 
-	/* Now correct the loop counter.  Please note that in the following
-	   code the flags are not changed anymore.  */
-	subq	$32, %rcx
+L(1loop):
+	movq	  (%rsi), %rcx
+	movq	8 (%rsi), %r8
+	movq	%rcx,   (%rdi)
+	movq	 %r8, 8 (%rdi)
+
+	subl	$16, %edx
+
+	leaq	16 (%rsi), %rsi
+	leaq	16 (%rdi), %rdi
+
+	jnz	L(1loop)
+
+	.p2align 4,, 4
+
+L(exit):				/* exit */
+#ifdef USE_AS_MEMPCPY
+	movq	%rdi, %rax		/* return value */
+#else
+	rep
+#endif
+	retq
+
+	.p2align 4
+
+L(1after):
+#ifndef USE_AS_MEMPCPY
+	movq	%rax, RETVAL (%rsp)	/* save return value */
+#endif
+
+/* Align to the natural word size. */
+
+L(aligntry):
+	movl	%esi, %ecx      	/* align by destination */
+
+	andl	$7, %ecx
+	jz	L(alignafter)  		/* already aligned */
+
+L(align):		      		/* align */
+	leaq	-8 (%rcx, %rdx), %rdx	/* calculate remaining bytes */
+	subl	$8, %ecx
+
+	.p2align 4
+
+L(alignloop):				/* 1-byte alignment loop */
+	movzbl	(%rsi), %eax
+	movb	%al, (%rdi)
+
+	incl	%ecx
+
+	leaq	1 (%rsi), %rsi
+	leaq	1 (%rdi), %rdi
+
+	jnz	L(alignloop)
+
+	.p2align 4
+
+L(alignafter):
+
+/* Loop to handle mid-sized blocks. */
+
+L(32try):				/* up to 1KB */
+	cmpq	$1024, %rdx
+	ja	L(32after)
+
+L(32):					/* 32-byte loop */
+	movl	%edx, %ecx
+	shrl	$5, %ecx
+	jz	L(32skip)
+
+	.p2align 4
+
+L(32loop):
+	decl	%ecx
 
 	movq	(%rsi), %rax
-	movq	8(%rsi), %rdx
-	movq	16(%rsi), %r8
-	movq	24(%rsi), %r9
+	movq	 8 (%rsi), %r8
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+
 	movq	%rax, (%rdi)
-	movq	%rdx, 8(%rdi)
-	movq	%r8, 16(%rdi)
-	movq	%r9, 24(%rdi)
+	movq	 %r8,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
 
 	leaq	32(%rsi), %rsi
 	leaq	32(%rdi), %rdi
 
-	jns	3b
+	jz	L(32skip)		/* help out smaller blocks */
+
+	decl	%ecx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %r8
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+
+	movq	%rax,    (%rdi)
+	movq	 %r8,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
+
+	leaq	32 (%rsi), %rsi
+	leaq	32 (%rdi), %rdi
+
+	jnz	L(32loop)
+
+	.p2align 4
 
-	/* Correct extra loop counter modification.  */
-2:	addq	$32, %rcx
-1:	rep; movsb
+L(32skip):
+	andl	$31, %edx		/* check for left overs */
+#ifdef USE_AS_MEMPCPY
+	jnz	L(1)
 
-#if MEMPCPY_P
-	movq	%rdi, %rax		/* Set return value.  */
+	movq	%rdi, %rax
 #else
-	movq	%r10, %rax		/* Set return value.  */
+	movq	RETVAL (%rsp), %rax
+	jnz	L(1)
 	
+	rep
+#endif
+	retq				/* exit */
+
+	.p2align 4
+
+L(32after):
+
+/*
+	In order to minimize code-size in RTLD, algorithms specific for
+	larger blocks are excluded when building for RTLD.
+*/
+
+/* Handle large blocks smaller than 1/2 L1. */
+
+L(fasttry):				/* first 1/2 L1 */
+#ifndef NOT_IN_libc			/* only up to this algorithm outside of libc.so */
+	movq	__x86_64_core_cache_size_half (%rip), %r11
+	cmpq	%rdx, %r11		/* calculate the smaller of */
+	cmovaq	%rdx, %r11		/* remaining bytes and 1/2 L1 */
+#endif
+
+L(fast):				/* good ol' MOVS */
+#ifndef NOT_IN_libc
+	movq	%r11, %rcx
+	andq	$-8, %r11
+#else
+	movq	%rdx, %rcx
+#endif
+	shrq	$3, %rcx
+	jz	L(fastskip)
+
+	rep
+	movsq
+
+	.p2align 4,, 4
+
+L(fastskip):
+#ifndef NOT_IN_libc
+	subq	%r11, %rdx		/* check for more */
+	testq	$-8, %rdx
+	jnz	L(fastafter)
 #endif
-	ret
 
-END (BP_SYM (memcpy))
-#if !MEMPCPY_P
+	andl	$7, %edx		/* check for left overs */
+#ifdef USE_AS_MEMPCPY
+	jnz	L(1)
+
+	movq	%rdi, %rax
+#else
+	movq	RETVAL (%rsp), %rax
+	jnz	L(1)
+
+	rep
+#endif
+	retq				/* exit */
+
+#ifndef NOT_IN_libc			/* none of the algorithms below for RTLD */
+
+	.p2align 4
+
+L(fastafter):
+
+/* Handle large blocks smaller than 1/2 L2. */
+
+L(pretry):				/* first 1/2 L2 */
+	movq	__x86_64_shared_cache_size_half (%rip), %r8
+	cmpq	%rdx, %r8		/* calculate the lesser of */
+	cmovaq	%rdx, %r8		/* remaining bytes and 1/2 L2 */
+
+L(pre):					/* 64-byte with prefetching */
+	movq	%r8, %rcx
+	andq	$-64, %r8
+	shrq	$6, %rcx
+	jz	L(preskip)
+
+	movq	%r14, SAVE0 (%rsp)
+	cfi_rel_offset (%r14, SAVE0)
+	movq	%r13, SAVE1 (%rsp)
+	cfi_rel_offset (%r13, SAVE1)
+	movq	%r12, SAVE2 (%rsp)
+	cfi_rel_offset (%r12, SAVE2)
+	movq	%rbx, SAVE3 (%rsp)
+	cfi_rel_offset (%rbx, SAVE3)
+
+	cmpl	$0, __x86_64_prefetchw (%rip)
+	jz	L(preloop)		/* check if PREFETCHW OK */
+
+	.p2align 4
+
+/* ... when PREFETCHW is available (less cache-probe traffic in MP systems). */
+
+L(prewloop):				/* cache-line in state M */
+	decq	%rcx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %rbx
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+	movq	32 (%rsi), %r11
+	movq	40 (%rsi), %r12
+	movq	48 (%rsi), %r13
+	movq	56 (%rsi), %r14
+
+	prefetcht0	 0 + 896 (%rsi)
+	prefetcht0	64 + 896 (%rsi)
+
+	movq	%rax,    (%rdi)
+	movq	%rbx,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
+	movq	%r11, 32 (%rdi)
+	movq	%r12, 40 (%rdi)
+	movq	%r13, 48 (%rdi)
+	movq	%r14, 56 (%rdi)
+
+	leaq	64 (%rsi), %rsi
+	leaq	64 (%rdi), %rdi
+
+	jz	L(prebail)
+
+	decq	%rcx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %rbx
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+	movq	32 (%rsi), %r11
+	movq	40 (%rsi), %r12
+	movq	48 (%rsi), %r13
+	movq	56 (%rsi), %r14
+
+	movq	%rax,    (%rdi)
+	movq	%rbx,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
+	movq	%r11, 32 (%rdi)
+	movq	%r12, 40 (%rdi)
+	movq	%r13, 48 (%rdi)
+	movq	%r14, 56 (%rdi)
+
+	prefetchw	896 - 64 (%rdi)
+	prefetchw	896 -  0 (%rdi)
+
+	leaq	64 (%rsi), %rsi
+	leaq	64 (%rdi), %rdi
+
+	jnz	L(prewloop)
+	jmp	L(prebail)
+
+	.p2align 4
+
+/* ... when PREFETCHW is not available. */
+
+L(preloop):				/* cache-line in state E */
+	decq	%rcx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %rbx
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+	movq	32 (%rsi), %r11
+	movq	40 (%rsi), %r12
+	movq	48 (%rsi), %r13
+	movq	56 (%rsi), %r14
+
+	prefetcht0	896 +  0 (%rsi)
+	prefetcht0	896 + 64 (%rsi)
+
+	movq	%rax,    (%rdi)
+	movq	%rbx,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
+	movq	%r11, 32 (%rdi)
+	movq	%r12, 40 (%rdi)
+	movq	%r13, 48 (%rdi)
+	movq	%r14, 56 (%rdi)
+
+	leaq	64 (%rsi), %rsi
+	leaq	64 (%rdi), %rdi
+
+	jz	L(prebail)
+
+	decq	%rcx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %rbx
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+	movq	32 (%rsi), %r11
+	movq	40 (%rsi), %r12
+	movq	48 (%rsi), %r13
+	movq	56 (%rsi), %r14
+
+	prefetcht0	896 - 64 (%rdi)
+	prefetcht0	896 -  0 (%rdi)
+
+	movq	%rax,    (%rdi)
+	movq	%rbx,  8 (%rdi)
+	movq	 %r9, 16 (%rdi)
+	movq	%r10, 24 (%rdi)
+	movq	%r11, 32 (%rdi)
+	movq	%r12, 40 (%rdi)
+	movq	%r13, 48 (%rdi)
+	movq	%r14, 56 (%rdi)
+
+	leaq	64 (%rsi), %rsi
+	leaq	64 (%rdi), %rdi
+
+	jnz	L(preloop)
+
+L(prebail):
+	movq	SAVE3 (%rsp), %rbx
+	cfi_restore (%rbx)
+	movq	SAVE2 (%rsp), %r12
+	cfi_restore (%r12)
+	movq	SAVE1 (%rsp), %r13
+	cfi_restore (%r13)
+	movq	SAVE0 (%rsp), %r14
+	cfi_restore (%r14)
+
+/*       .p2align 4 */
+
+L(preskip):
+	subq	%r8, %rdx		/* check for more */
+	testq	$-64, %rdx
+	jnz	L(preafter)
+
+	andl	$63, %edx		/* check for left overs */
+#ifdef USE_AS_MEMPCPY
+	jnz	L(1)
+
+	movq	%rdi, %rax
+#else
+	movq	RETVAL (%rsp), %rax
+	jnz	L(1)
+
+	rep
+#endif
+	retq				/* exit */
+
+	.p2align 4
+
+L(preafter):
+
+/* Loop to handle huge blocks. */
+
+L(NTtry):
+
+L(NT):					/* non-temporal 128-byte */
+	movq	%rdx, %rcx
+	shrq	$7, %rcx
+	jz	L(NTskip)
+
+	movq	%r14, SAVE0 (%rsp)
+	cfi_rel_offset (%r14, SAVE0)
+	movq	%r13, SAVE1 (%rsp)
+	cfi_rel_offset (%r13, SAVE1)
+	movq	%r12, SAVE2 (%rsp)
+	cfi_rel_offset (%r12, SAVE2)
+
+       .p2align 4
+
+L(NTloop):
+	prefetchnta	768 (%rsi)
+	prefetchnta	832 (%rsi)
+
+	decq	%rcx
+
+	movq	   (%rsi), %rax
+	movq	 8 (%rsi), %r8
+	movq	16 (%rsi), %r9
+	movq	24 (%rsi), %r10
+	movq	32 (%rsi), %r11
+	movq	40 (%rsi), %r12
+	movq	48 (%rsi), %r13
+	movq	56 (%rsi), %r14
+
+	movntiq	%rax,    (%rdi)
+	movntiq	 %r8,  8 (%rdi)
+	movntiq	 %r9, 16 (%rdi)
+	movntiq	%r10, 24 (%rdi)
+	movntiq	%r11, 32 (%rdi)
+	movntiq	%r12, 40 (%rdi)
+	movntiq	%r13, 48 (%rdi)
+	movntiq	%r14, 56 (%rdi)
+
+	movq	 64 (%rsi), %rax
+	movq	 72 (%rsi), %r8
+	movq	 80 (%rsi), %r9
+	movq	 88 (%rsi), %r10
+	movq	 96 (%rsi), %r11
+	movq	104 (%rsi), %r12
+	movq	112 (%rsi), %r13
+	movq	120 (%rsi), %r14
+
+	movntiq	%rax,  64 (%rdi)
+	movntiq	 %r8,  72 (%rdi)
+	movntiq	 %r9,  80 (%rdi)
+	movntiq	%r10,  88 (%rdi)
+	movntiq	%r11,  96 (%rdi)
+	movntiq	%r12, 104 (%rdi)
+	movntiq	%r13, 112 (%rdi)
+	movntiq	%r14, 120 (%rdi)
+
+	leaq	128 (%rsi), %rsi
+	leaq	128 (%rdi), %rdi
+
+	jnz	L(NTloop)
+
+	sfence				/* serialize memory stores */
+
+	movq	SAVE2 (%rsp), %r12
+	cfi_restore (%r12)
+	movq	SAVE1 (%rsp), %r13
+	cfi_restore (%r13)
+	movq	SAVE0 (%rsp), %r14
+	cfi_restore (%r14)
+
+L(NTskip):
+	andl	$127, %edx		/* check for left overs */
+#ifdef USE_AS_MEMPCPY
+	jnz	L(1)
+
+	movq	%rdi, %rax
+#else
+	movq	RETVAL (%rsp), %rax
+	jnz	L(1)
+
+	rep
+#endif
+	retq				/* exit */
+
+#endif /* !NOT_IN_libc */
+
+END(memcpy)
+
+#ifndef USE_AS_MEMPCPY
 libc_hidden_builtin_def (memcpy)
 #endif
--- glibc-20070515T2025/sysdeps/x86_64/mempcpy.S	18 Oct 2004 04:17:08 -0000	1.3
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/mempcpy.S	7 Jul 2007 16:06:42 -0000	1.2.2.2
@@ -1,3 +1,4 @@
+#define USE_AS_MEMPCPY
 #define memcpy __mempcpy
 #define __memcpy_chk __mempcpy_chk
 #include <sysdeps/x86_64/memcpy.S>
--- glibc-20070515T2025/sysdeps/x86_64/fpu/k_cosl.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/fpu/k_cosl.c	21 May 2007 20:01:15 -0000	1.1.2.1
@@ -0,0 +1 @@
+/*  Not needed.  */
--- glibc-20070515T2025/sysdeps/x86_64/fpu/k_rem_pio2l.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/fpu/k_rem_pio2l.c	21 May 2007 20:01:15 -0000	1.1.2.1
@@ -0,0 +1 @@
+/*  Not needed.  */
--- glibc-20070515T2025/sysdeps/x86_64/fpu/k_sinl.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/fpu/k_sinl.c	21 May 2007 20:01:15 -0000	1.1.2.1
@@ -0,0 +1 @@
+/*  Not needed.  */
--- glibc-20070515T2025/sysdeps/x86_64/fpu/k_tanl.c 1 Jan 1970 00:00:00 -0000
+++ glibc-20070515T2025-fedora/sysdeps/x86_64/fpu/k_tanl.c	21 May 2007 20:01:15 -0000	1.1.2.1
@@ -0,0 +1 @@
+/*  Not needed.  */
