commit d53b8652880ba42913f66e7eee0567ce4cfe7791
Author: Florian Weimer <fweimer@redhat.com>
Date:   Thu May 11 14:48:51 2017 +0200

    inet_pton: Reformat in GNU style
    
    Generated machine code is identical on x86-64.

diff --git a/resolv/inet_pton.c b/resolv/inet_pton.c
index c0a7d54c303af82b..68f0fa54020e9351 100644
--- a/resolv/inet_pton.c
+++ b/resolv/inet_pton.c
@@ -25,188 +25,192 @@
 #include <string.h>
 #include <errno.h>
 
-/*
- * WARNING: Don't even consider trying to compile this on a system where
- * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
- */
-
-static int inet_pton4 (const char *src, u_char *dst) internal_function;
-static int inet_pton6 (const char *src, u_char *dst) internal_function;
+static int inet_pton4 (const char *src, unsigned char *dst);
+static int inet_pton6 (const char *src, unsigned char *dst);
 
-/* int
- * inet_pton(af, src, dst)
- *	convert from presentation format (which usually means ASCII printable)
- *	to network format (which is usually some kind of binary format).
+/* Convert from presentation format (which usually means ASCII printable)
+ * to network format (which is usually some kind of binary format).
+ *
  * return:
- *	1 if the address was valid for the specified address family
- *	0 if the address wasn't valid (`dst' is untouched in this case)
- *	-1 if some other error occurred (`dst' is untouched in this case, too)
+ *      1 if the address was valid for the specified address family
+ *      0 if the address wasn't valid (`dst' is untouched in this case)
+ *      -1 if some other error occurred (`dst' is untouched in this case, too)
  * author:
- *	Paul Vixie, 1996.
+ *      Paul Vixie, 1996.
  */
 int
 __inet_pton (int af, const char *src, void *dst)
 {
-	switch (af) {
-	case AF_INET:
-		return (inet_pton4(src, dst));
-	case AF_INET6:
-		return (inet_pton6(src, dst));
-	default:
-		__set_errno (EAFNOSUPPORT);
-		return (-1);
-	}
-	/* NOTREACHED */
+  switch (af)
+    {
+    case AF_INET:
+      return inet_pton4 (src, dst);
+    case AF_INET6:
+      return inet_pton6 (src, dst);
+    default:
+      __set_errno (EAFNOSUPPORT);
+      return -1;
+    }
 }
 libc_hidden_def (__inet_pton)
 weak_alias (__inet_pton, inet_pton)
 libc_hidden_weak (inet_pton)
 
-/* int
- * inet_pton4(src, dst)
- *	like inet_aton() but without all the hexadecimal, octal (with the
- *	exception of 0) and shorthand.
+/* Like inet_atonbut without all the hexadecimal, octal and shorthand.
+ *
  * return:
- *	1 if `src' is a valid dotted quad, else 0.
+ *      1 if `src' is a valid dotted quad, else 0.
  * notice:
- *	does not touch `dst' unless it's returning 1.
+ *      does not touch `dst' unless it's returning 1.
  * author:
- *	Paul Vixie, 1996.
+ *      Paul Vixie, 1996.
  */
 static int
-internal_function
-inet_pton4 (const char *src, u_char *dst)
+inet_pton4 (const char *src, unsigned char *dst)
 {
-	int saw_digit, octets, ch;
-	u_char tmp[NS_INADDRSZ], *tp;
-
-	saw_digit = 0;
-	octets = 0;
-	*(tp = tmp) = 0;
-	while ((ch = *src++) != '\0') {
+  int saw_digit, octets, ch;
+  unsigned char tmp[NS_INADDRSZ], *tp;
 
-		if (ch >= '0' && ch <= '9') {
-			u_int new = *tp * 10 + (ch - '0');
+  saw_digit = 0;
+  octets = 0;
+  *(tp = tmp) = 0;
+  while ((ch = *src++) != '\0')
+    {
+      if (ch >= '0' && ch <= '9')
+        {
+          unsigned int new = *tp * 10 + (ch - '0');
 
-			if (saw_digit && *tp == 0)
-				return (0);
-			if (new > 255)
-				return (0);
-			*tp = new;
-			if (! saw_digit) {
-				if (++octets > 4)
-					return (0);
-				saw_digit = 1;
-			}
-		} else if (ch == '.' && saw_digit) {
-			if (octets == 4)
-				return (0);
-			*++tp = 0;
-			saw_digit = 0;
-		} else
-			return (0);
-	}
-	if (octets < 4)
-		return (0);
-	memcpy(dst, tmp, NS_INADDRSZ);
-	return (1);
+          if (saw_digit && *tp == 0)
+            return 0;
+          if (new > 255)
+            return 0;
+          *tp = new;
+          if (! saw_digit)
+            {
+              if (++octets > 4)
+                return 0;
+              saw_digit = 1;
+            }
+        }
+      else if (ch == '.' && saw_digit)
+        {
+          if (octets == 4)
+            return 0;
+          *++tp = 0;
+          saw_digit = 0;
+        }
+      else
+        return 0;
+    }
+  if (octets < 4)
+    return 0;
+  memcpy (dst, tmp, NS_INADDRSZ);
+  return 1;
 }
 
-/* int
- * inet_pton6(src, dst)
- *	convert presentation level address to network order binary form.
+/* Cconvert presentation level address to network order binary form.
+ *
  * return:
- *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
+ *      1 if `src' is a valid [RFC1884 2.2] address, else 0.
  * notice:
- *	(1) does not touch `dst' unless it's returning 1.
- *	(2) :: in a full address is silently ignored.
+ *      (1) does not touch `dst' unless it's returning 1.
+ *      (2) :: in a full address is silently ignored.
  * credit:
- *	inspired by Mark Andrews.
+ *      inspired by Mark Andrews.
  * author:
- *	Paul Vixie, 1996.
+ *      Paul Vixie, 1996.
  */
 static int
-internal_function
-inet_pton6 (const char *src, u_char *dst)
+inet_pton6 (const char *src, unsigned char *dst)
 {
-	static const char xdigits[] = "0123456789abcdef";
-	u_char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
-	const char *curtok;
-	int ch, saw_xdigit;
-	u_int val;
+  static const char xdigits[] = "0123456789abcdef";
+  unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
+  const char *curtok;
+  int ch, saw_xdigit;
+  unsigned int val;
 
-	tp = memset(tmp, '\0', NS_IN6ADDRSZ);
-	endp = tp + NS_IN6ADDRSZ;
-	colonp = NULL;
-	/* Leading :: requires some special handling. */
-	if (*src == ':')
-		if (*++src != ':')
-			return (0);
-	curtok = src;
-	saw_xdigit = 0;
-	val = 0;
-	while ((ch = tolower (*src++)) != '\0') {
-		const char *pch;
+  tp = memset (tmp, '\0', NS_IN6ADDRSZ);
+  endp = tp + NS_IN6ADDRSZ;
+  colonp = NULL;
+  /* Leading :: requires some special handling.  */
+  if (*src == ':')
+    if (*++src != ':')
+      return 0;
+  curtok = src;
+  saw_xdigit = 0;
+  val = 0;
+  while ((ch = tolower (*src++)) != '\0')
+    {
+      const char *pch;
 
-		pch = strchr(xdigits, ch);
-		if (pch != NULL) {
-			val <<= 4;
-			val |= (pch - xdigits);
-			if (val > 0xffff)
-				return (0);
-			saw_xdigit = 1;
-			continue;
-		}
-		if (ch == ':') {
-			curtok = src;
-			if (!saw_xdigit) {
-				if (colonp)
-					return (0);
-				colonp = tp;
-				continue;
-			} else if (*src == '\0') {
-				return (0);
-			}
-			if (tp + NS_INT16SZ > endp)
-				return (0);
-			*tp++ = (u_char) (val >> 8) & 0xff;
-			*tp++ = (u_char) val & 0xff;
-			saw_xdigit = 0;
-			val = 0;
-			continue;
-		}
-		if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
-		    inet_pton4(curtok, tp) > 0) {
-			tp += NS_INADDRSZ;
-			saw_xdigit = 0;
-			break;	/* '\0' was seen by inet_pton4(). */
-		}
-		return (0);
+      pch = strchr (xdigits, ch);
+      if (pch != NULL)
+	{
+	  val <<= 4;
+	  val |= (pch - xdigits);
+	  if (val > 0xffff)
+	    return 0;
+	  saw_xdigit = 1;
+	  continue;
+	}
+      if (ch == ':')
+	{
+	  curtok = src;
+	  if (!saw_xdigit)
+	    {
+	      if (colonp)
+		return 0;
+	      colonp = tp;
+	      continue;
+	    }
+	  else if (*src == '\0')
+	    {
+	      return 0;
+	    }
+	  if (tp + NS_INT16SZ > endp)
+	    return 0;
+	  *tp++ = (unsigned char) (val >> 8) & 0xff;
+	  *tp++ = (unsigned char) val & 0xff;
+	  saw_xdigit = 0;
+	  val = 0;
+	  continue;
 	}
-	if (saw_xdigit) {
-		if (tp + NS_INT16SZ > endp)
-			return (0);
-		*tp++ = (u_char) (val >> 8) & 0xff;
-		*tp++ = (u_char) val & 0xff;
+      if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
+	  inet_pton4 (curtok, tp) > 0)
+	{
+	  tp += NS_INADDRSZ;
+	  saw_xdigit = 0;
+	  break;  /* '\0' was seen by inet_pton4.  */
 	}
-	if (colonp != NULL) {
-		/*
-		 * Since some memmove()'s erroneously fail to handle
-		 * overlapping regions, we'll do the shift by hand.
-		 */
-		const int n = tp - colonp;
-		int i;
+      return 0;
+    }
+  if (saw_xdigit)
+    {
+      if (tp + NS_INT16SZ > endp)
+	return 0;
+      *tp++ = (unsigned char) (val >> 8) & 0xff;
+      *tp++ = (unsigned char) val & 0xff;
+    }
+  if (colonp != NULL)
+    {
+      /*
+       * Since some memmove's erroneously fail to handle
+       * overlapping regions, we'll do the shift by hand.
+       */
+      const int n = tp - colonp;
+      int i;
 
-		if (tp == endp)
-			return (0);
-		for (i = 1; i <= n; i++) {
-			endp[- i] = colonp[n - i];
-			colonp[n - i] = 0;
-		}
-		tp = endp;
+      if (tp == endp)
+	return 0;
+      for (i = 1; i <= n; i++)
+	{
+	  endp[- i] = colonp[n - i];
+	  colonp[n - i] = 0;
 	}
-	if (tp != endp)
-		return (0);
-	memcpy(dst, tmp, NS_IN6ADDRSZ);
-	return (1);
+      tp = endp;
+    }
+  if (tp != endp)
+    return 0;
+  memcpy (dst, tmp, NS_IN6ADDRSZ);
+  return 1;
 }
