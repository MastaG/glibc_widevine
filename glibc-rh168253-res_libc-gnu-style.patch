commit b87d47396f8e036a111fed8816254cfe1cf87cb2
Author: Florian Weimer <fweimer@redhat.com>
Date:   Fri Jun 23 18:10:41 2017 +0200

    resolv/res_libc.c: Reformat to GNU style

diff --git a/resolv/res_libc.c b/resolv/res_libc.c
index 5202b756ff17518a..4b979f39a7c8e8ba 100644
--- a/resolv/res_libc.c
+++ b/resolv/res_libc.c
@@ -1,3 +1,21 @@
+/* Definitions related to res_init linked into libc instead of libresolv.
+   Copyright (C) 1995-2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
 /*
  * Copyright (c) 1995-1999 by Internet Software Consortium.
  *
@@ -15,9 +33,6 @@
  * SOFTWARE.
  */
 
-/* This file contains the definitions related to res_init which are
-   linked into libc instead of libresolv.  */
-
 #include <atomic.h>
 #include <limits.h>
 #include <sys/types.h>
@@ -40,74 +55,78 @@ __libc_lock_define_initialized (static, lock);
 #endif
 
 int
-res_init(void) {
-	/*
-	 * These three fields used to be statically initialized.  This made
-	 * it hard to use this code in a shared library.  It is necessary,
-	 * now that we're doing dynamic initialization here, that we preserve
-	 * the old semantics: if an application modifies one of these three
-	 * fields of _res before res_init() is called, res_init() will not
-	 * alter them.  Of course, if an application is setting them to
-	 * _zero_ before calling res_init(), hoping to override what used
-	 * to be the static default, we can't detect it and unexpected results
-	 * will follow.  Zero for any of these fields would make no sense,
-	 * so one can safely assume that the applications were already getting
-	 * unexpected results.
-	 *
-	 * _res.options is tricky since some apps were known to diddle the bits
-	 * before res_init() was first called. We can't replicate that semantic
-	 * with dynamic initialization (they may have turned bits off that are
-	 * set in RES_DEFAULT).  Our solution is to declare such applications
-	 * "broken".  They could fool us by setting RES_INIT but none do (yet).
-	 */
-	if (!_res.retrans)
-		_res.retrans = RES_TIMEOUT;
-	if (!_res.retry)
-		_res.retry = RES_DFLRETRY;
-	if (!(_res.options & RES_INIT))
-		_res.options = RES_DEFAULT;
-	else if (_res.nscount > 0)
-		__res_iclose (&_res, true);	/* Close any VC sockets.  */
-
-	/*
-	 * This one used to initialize implicitly to zero, so unless the app
-	 * has set it to something in particular, we can randomize it now.
-	 */
-	if (!_res.id)
-		_res.id = res_randomid();
-
-	atomicinclock (lock);
-	/* Request all threads to re-initialize their resolver states,
-	   resolv.conf might have changed.  */
-	atomicinc (__res_initstamp);
-	atomicincunlock (lock);
-
-	return (__res_vinit(&_res, 1));
+res_init (void)
+{
+  /* These three fields used to be statically initialized.  This made
+     it hard to use this code in a shared library.  It is necessary,
+     now that we're doing dynamic initialization here, that we
+     preserve the old semantics: if an application modifies one of
+     these three fields of _res before res_init is called,
+     res_init will not alter them.  Of course, if an application is
+     setting them to _zero_ before calling res_init, hoping to
+     override what used to be the static default, we can't detect it
+     and unexpected results will follow.  Zero for any of these fields
+     would make no sense, so one can safely assume that the
+     applications were already getting unexpected results.
+
+     _res.options is tricky since some apps were known to diddle the
+     bits before res_init was first called. We can't replicate that
+     semantic with dynamic initialization (they may have turned bits
+     off that are set in RES_DEFAULT).  Our solution is to declare
+     such applications "broken".  They could fool us by setting
+     RES_INIT but none do (yet).  */
+  if (!_res.retrans)
+    _res.retrans = RES_TIMEOUT;
+  if (!_res.retry)
+    _res.retry = RES_DFLRETRY;
+  if (!(_res.options & RES_INIT))
+    _res.options = RES_DEFAULT;
+  else if (_res.nscount > 0)
+    __res_iclose (&_res, true); /* Close any VC sockets.  */
+
+  /* This one used to initialize implicitly to zero, so unless the app
+     has set it to something in particular, we can randomize it *
+     now.  */
+  if (!_res.id)
+    _res.id = res_randomid ();
+
+  atomicinclock (lock);
+  /* Request all threads to re-initialize their resolver states,
+     resolv.conf might have changed.  */
+  atomicinc (__res_initstamp);
+  atomicincunlock (lock);
+
+  return __res_vinit (&_res, 1);
 }
 
-/* Initialize resp if RES_INIT is not yet set or if res_init in some other
-   thread requested re-initializing.  */
+/* Initialize *RESP if RES_INIT is not yet set in RESP->options, or if
+   res_init in some other thread requested re-initializing.  */
 int
 __res_maybe_init (res_state resp, int preinit)
 {
-	if (resp->options & RES_INIT) {
-		if (__res_initstamp != resp->_u._ext.initstamp) {
-			if (resp->nscount > 0)
-				__res_iclose (resp, true);
-			return __res_vinit (resp, 1);
-		}
-		return 0;
-	} else if (preinit) {
-		if (!resp->retrans)
-			resp->retrans = RES_TIMEOUT;
-		if (!resp->retry)
-			resp->retry = RES_DFLRETRY;
-		resp->options = RES_DEFAULT;
-		if (!resp->id)
-			resp->id = res_randomid ();
-		return __res_vinit (resp, 1);
-	} else
-		return __res_ninit (resp);
+  if (resp->options & RES_INIT)
+    {
+      if (__res_initstamp != resp->_u._ext.initstamp)
+        {
+          if (resp->nscount > 0)
+            __res_iclose (resp, true);
+          return __res_vinit (resp, 1);
+        }
+      return 0;
+    }
+  else if (preinit)
+    {
+      if (!resp->retrans)
+        resp->retrans = RES_TIMEOUT;
+      if (!resp->retry)
+        resp->retry = RES_DFLRETRY;
+      resp->options = RES_DEFAULT;
+      if (!resp->id)
+        resp->id = res_randomid ();
+      return __res_vinit (resp, 1);
+    }
+  else
+    return __res_ninit (resp);
 }
 libc_hidden_def (__res_maybe_init)
 
