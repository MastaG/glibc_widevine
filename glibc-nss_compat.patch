commit 64d1e08ea822bf47cb2796ad0f727136227f983c
Author: Andreas Schwab <schwab@suse.de>
Date:   Mon Oct 2 14:30:46 2017 +0200

    Move nss_compat from nis to nss subdir and install it unconditionally
    
    This has been tested that local lookup still works with and
    without an installed libnss_nis, and that NIS lookup works when
    libnss_nis is available.

diff --git a/nis/Makefile b/nis/Makefile
index 991460faa6652413..e536b043e54d90f6 100644
--- a/nis/Makefile
+++ b/nis/Makefile
@@ -34,7 +34,7 @@ databases		= proto service hosts network grp pwd rpc ethers \
 			  spwd netgrp alias publickey
 
 # Specify rules for the nss_* modules.
-services		:= nis nisplus compat
+services		:= nis nisplus
 
 extra-libs		= libnsl $(services:%=libnss_%)
 # These libraries will be built in the `others' pass rather than
@@ -57,9 +57,6 @@ libnsl-routines = yp_xdr ypclnt ypupdate_xdr \
 		  nis_findserv nis_callback nis_clone_dir nis_clone_obj\
 		  nis_clone_res nss-default
 
-libnss_compat-routines	:= $(addprefix compat-,grp pwd spwd initgroups)
-libnss_compat-inhibit-o	= $(filter-out .os,$(object-suffixes))
-
 libnss_nis-routines	:= $(addprefix nis-,$(databases)) nis-initgroups \
 			   nss-nis
 libnss_nis-inhibit-o	= $(filter-out .os,$(object-suffixes))
@@ -71,7 +68,6 @@ libnss_nisplus-inhibit-o = $(filter-out .os,$(object-suffixes))
 include ../Rules
 
 
-$(objpfx)libnss_compat.so: $(objpfx)libnsl.so$(libnsl.so-version)
 $(objpfx)libnss_nis.so: $(objpfx)libnsl.so$(libnsl.so-version) \
 			$(common-objpfx)nss/libnss_files.so
 $(objpfx)libnss_nisplus.so: $(objpfx)libnsl.so$(libnsl.so-version)
diff --git a/nis/Versions b/nis/Versions
index ef9a5124174ec0e8..90d3d9dfaa3d853b 100644
--- a/nis/Versions
+++ b/nis/Versions
@@ -63,17 +63,6 @@ libnsl {
   }
 }
 
-libnss_compat {
-  GLIBC_PRIVATE {
-    _nss_compat_endgrent; _nss_compat_endpwent; _nss_compat_endspent;
-    _nss_compat_getgrent_r; _nss_compat_getgrgid_r; _nss_compat_getgrnam_r;
-    _nss_compat_getpwent_r; _nss_compat_getpwnam_r; _nss_compat_getpwuid_r;
-    _nss_compat_getspent_r; _nss_compat_getspnam_r;
-    _nss_compat_setgrent; _nss_compat_setpwent; _nss_compat_setspent;
-    _nss_compat_initgroups_dyn;
-  }
-}
-
 libnss_nis {
   GLIBC_PRIVATE {
     _nss_nis_endaliasent; _nss_nis_endetherent; _nss_nis_endgrent;
diff --git a/nss/Makefile b/nss/Makefile
index 1f016d99c78a7433..760a52acea20d059 100644
--- a/nss/Makefile
+++ b/nss/Makefile
@@ -55,7 +55,7 @@ tests			= test-netdb tst-nss-test1 test-digits-dots \
 xtests			= bug-erange
 
 # Specify rules for the nss_* modules.  We have some services.
-services		:= files db
+services		:= files db compat
 
 extra-libs		= $(services:%=libnss_%)
 # These libraries will be built in the `others' pass rather than
@@ -78,11 +78,15 @@ libnss_db-routines	:= $(libnss_db-dbs) db-open db-init hash-string
 generated		+= $(filter-out db-alias.c db-netgrp.c, \
 					$(addsuffix .c,$(libnss_db-dbs)))
 
+libnss_compat-routines	:= $(addprefix compat-,grp pwd spwd initgroups) \
+			   nisdomain
+
 install-others		+= $(inst_vardbdir)/Makefile
 
 # Build static module into libc if requested
 libnss_files-inhibit-o	= $(filter-out .os,$(object-suffixes))
 libnss_db-inhibit-o	= $(filter-out .os,$(object-suffixes))
+libnss_compat-inhibit-o	= $(filter-out .os,$(object-suffixes))
 ifeq ($(build-static-nss),yes)
 routines                += $(libnss_files-routines)
 static-only-routines    += $(libnss_files-routines)
diff --git a/nss/Versions b/nss/Versions
index f8ababccc74d1dd2..14c2571468169e4d 100644
--- a/nss/Versions
+++ b/nss/Versions
@@ -160,3 +160,14 @@ libnss_db {
     _nss_db_init;
   }
 }
+
+libnss_compat {
+  GLIBC_PRIVATE {
+    _nss_compat_endgrent; _nss_compat_endpwent; _nss_compat_endspent;
+    _nss_compat_getgrent_r; _nss_compat_getgrgid_r; _nss_compat_getgrnam_r;
+    _nss_compat_getpwent_r; _nss_compat_getpwnam_r; _nss_compat_getpwuid_r;
+    _nss_compat_getspent_r; _nss_compat_getspnam_r;
+    _nss_compat_setgrent; _nss_compat_setpwent; _nss_compat_setspent;
+    _nss_compat_initgroups_dyn;
+  }
+}
diff --git a/nis/nss_compat/compat-grp.c b/nss/nss_compat/compat-grp.c
similarity index 97%
rename from nis/nss_compat/compat-grp.c
rename to nss/nss_compat/compat-grp.c
index 736f1df10a276067..28bef2e3745175da 100644
--- a/nis/nss_compat/compat-grp.c
+++ b/nss/nss_compat/compat-grp.c
@@ -24,7 +24,6 @@
 #include <nsswitch.h>
 #include <stdio_ext.h>
 #include <string.h>
-#include <rpc/types.h>
 #include <libc-lock.h>
 #include <kernel-features.h>
 
@@ -58,14 +57,14 @@ struct blacklist_t
 
 struct ent_t
 {
-  bool_t files;
+  bool files;
   enum nss_status setent_status;
   FILE *stream;
   struct blacklist_t blacklist;
 };
 typedef struct ent_t ent_t;
 
-static ent_t ext_ent = { TRUE, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
+static ent_t ext_ent = { true, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
 
 /* Protect global state against multiple changers.  */
 __libc_lock_define_initialized (static, lock)
@@ -85,7 +84,7 @@ int __compat_have_cloexec;
 
 /* Prototypes for local functions.  */
 static void blacklist_store_name (const char *, ent_t *);
-static int in_blacklist (const char *, int, ent_t *);
+static bool in_blacklist (const char *, int, ent_t *);
 
 /* Initialize the NSS interface/functions. The calling function must
    hold the lock.  */
@@ -107,7 +106,7 @@ internal_setgrent (ent_t *ent, int stayopen, int needent)
 {
   enum nss_status status = NSS_STATUS_SUCCESS;
 
-  ent->files = TRUE;
+  ent->files = true;
 
   if (ent->blacklist.data != NULL)
     {
@@ -369,7 +368,7 @@ getgrent_next_file (struct group *result, ent_t *ent,
       /* +:... */
       if (result->gr_name[0] == '+' && result->gr_name[1] == '\0')
 	{
-	  ent->files = FALSE;
+	  ent->files = false;
 
 	  return getgrent_next_nss (result, ent, buffer, buflen, errnop);
 	}
@@ -514,7 +513,7 @@ enum nss_status
 _nss_compat_getgrnam_r (const char *name, struct group *grp,
 			char *buffer, size_t buflen, int *errnop)
 {
-  ent_t ent = { TRUE, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
+  ent_t ent = { true, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
   enum nss_status result;
 
   if (name[0] == '-' || name[0] == '+')
@@ -646,7 +645,7 @@ enum nss_status
 _nss_compat_getgrgid_r (gid_t gid, struct group *grp,
 			char *buffer, size_t buflen, int *errnop)
 {
-  ent_t ent = { TRUE, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
+  ent_t ent = { true, NSS_STATUS_SUCCESS, NULL, { NULL, 0, 0 }};
   enum nss_status result;
 
   __libc_lock_lock (lock);
@@ -713,15 +712,15 @@ blacklist_store_name (const char *name, ent_t *ent)
   return;
 }
 
-/* returns TRUE if ent->blacklist contains name, else FALSE */
-static bool_t
+/* Return whether ent->blacklist contains name.  */
+static bool
 in_blacklist (const char *name, int namelen, ent_t *ent)
 {
   char buf[namelen + 3];
   char *cp;
 
   if (ent->blacklist.data == NULL)
-    return FALSE;
+    return false;
 
   buf[0] = '|';
   cp = stpcpy (&buf[1], name);
diff --git a/nis/nss_compat/compat-initgroups.c b/nss/nss_compat/compat-initgroups.c
similarity index 98%
rename from nis/nss_compat/compat-initgroups.c
rename to nss/nss_compat/compat-initgroups.c
index 4843e5c28fe1128d..76117033004cfa97 100644
--- a/nis/nss_compat/compat-initgroups.c
+++ b/nss/nss_compat/compat-initgroups.c
@@ -24,7 +24,6 @@
 #include <stdio_ext.h>
 #include <string.h>
 #include <unistd.h>
-#include <rpc/types.h>
 #include <sys/param.h>
 #include <nsswitch.h>
 #include <libc-lock.h>
@@ -93,7 +92,7 @@ extern int __compat_have_cloexec;
 
 /* Prototypes for local functions.  */
 static void blacklist_store_name (const char *, ent_t *);
-static int in_blacklist (const char *, int, ent_t *);
+static bool in_blacklist (const char *, int, ent_t *);
 
 /* Initialize the NSS interface/functions. The calling function must
    hold the lock.  */
@@ -602,15 +601,15 @@ blacklist_store_name (const char *name, ent_t *ent)
   return;
 }
 
-/* returns TRUE if ent->blacklist contains name, else FALSE */
-static bool_t
+/* Return whether ent->blacklist contains name.  */
+static bool
 in_blacklist (const char *name, int namelen, ent_t *ent)
 {
   char buf[namelen + 3];
   char *cp;
 
   if (ent->blacklist.data == NULL)
-    return FALSE;
+    return false;
 
   buf[0] = '|';
   cp = stpcpy (&buf[1], name);
diff --git a/nis/nss_compat/compat-pwd.c b/nss/nss_compat/compat-pwd.c
similarity index 99%
rename from nis/nss_compat/compat-pwd.c
rename to nss/nss_compat/compat-pwd.c
index 16e9404e2263c4b5..638bfe23212205a6 100644
--- a/nis/nss_compat/compat-pwd.c
+++ b/nss/nss_compat/compat-pwd.c
@@ -25,12 +25,11 @@
 #include <pwd.h>
 #include <stdio_ext.h>
 #include <string.h>
-#include <rpc/types.h>
-#include <rpcsvc/ypclnt.h>
 #include <libc-lock.h>
 #include <kernel-features.h>
 
 #include "netgroup.h"
+#include "nisdomain.h"
 
 static service_user *ni;
 static enum nss_status (*nss_setpwent) (int stayopen);
@@ -95,7 +94,7 @@ extern int __compat_have_cloexec;
 
 /* Prototypes for local functions.  */
 static void blacklist_store_name (const char *, ent_t *);
-static int in_blacklist (const char *, int, ent_t *);
+static bool in_blacklist (const char *, int, ent_t *);
 
 /* Initialize the NSS interface/functions. The calling function must
    hold the lock.  */
@@ -394,7 +393,7 @@ getpwent_next_nss_netgr (const char *name, struct passwd *result, ent_t *ent,
       if (domain != NULL)
 	{
 	  if (curdomain == NULL
-	      && yp_get_default_domain (&curdomain) != YPERR_SUCCESS)
+	      && __nss_get_default_domain (&curdomain) != 0)
 	    {
 	      __internal_endnetgrent (&ent->netgrdata);
 	      ent->netgroup = false;
@@ -1162,15 +1161,15 @@ blacklist_store_name (const char *name, ent_t *ent)
   return;
 }
 
-/* Returns TRUE if ent->blacklist contains name, else FALSE.  */
-static bool_t
+/* Returns whether ent->blacklist contains name.  */
+static bool
 in_blacklist (const char *name, int namelen, ent_t *ent)
 {
   char buf[namelen + 3];
   char *cp;
 
   if (ent->blacklist.data == NULL)
-    return FALSE;
+    return false;
 
   buf[0] = '|';
   cp = stpcpy (&buf[1], name);
diff --git a/nis/nss_compat/compat-spwd.c b/nss/nss_compat/compat-spwd.c
similarity index 98%
rename from nis/nss_compat/compat-spwd.c
rename to nss/nss_compat/compat-spwd.c
index 4db96ef29df8d703..7cdd61b6edec8572 100644
--- a/nis/nss_compat/compat-spwd.c
+++ b/nss/nss_compat/compat-spwd.c
@@ -25,12 +25,11 @@
 #include <shadow.h>
 #include <stdio_ext.h>
 #include <string.h>
-#include <rpc/types.h>
-#include <rpcsvc/ypclnt.h>
 #include <libc-lock.h>
 #include <kernel-features.h>
 
 #include "netgroup.h"
+#include "nisdomain.h"
 
 static service_user *ni;
 static enum nss_status (*nss_setspent) (int stayopen);
@@ -92,7 +91,7 @@ extern int __compat_have_cloexec;
 
 /* Prototypes for local functions.  */
 static void blacklist_store_name (const char *, ent_t *);
-static int in_blacklist (const char *, int, ent_t *);
+static bool in_blacklist (const char *, int, ent_t *);
 
 /* Initialize the NSS interface/functions. The calling function must
    hold the lock.  */
@@ -354,7 +353,7 @@ getspent_next_nss_netgr (const char *name, struct spwd *result, ent_t *ent,
       if (domain != NULL)
 	{
 	  if (curdomain == NULL
-	      && yp_get_default_domain (&curdomain) != YPERR_SUCCESS)
+	      && __nss_get_default_domain (&curdomain) != 0)
 	    {
 	      __internal_endnetgrent (&ent->netgrdata);
 	      ent->netgroup = false;
@@ -888,8 +887,8 @@ blacklist_store_name (const char *name, ent_t *ent)
 }
 
 
-/* Returns TRUE if ent->blacklist contains name, else FALSE.  */
-static bool_t
+/* Returns whether ent->blacklist contains name.  */
+static bool
 in_blacklist (const char *name, int namelen, ent_t *ent)
 {
   char buf[namelen + 3];
diff --git a/nss/nss_compat/nisdomain.c b/nss/nss_compat/nisdomain.c
new file mode 100644
index 0000000000000000..220ae27234705855
--- /dev/null
+++ b/nss/nss_compat/nisdomain.c
@@ -0,0 +1,58 @@
+/* Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <libc-lock.h>
+#include "nisdomain.h"
+
+#define MAXDOMAINNAMELEN 1024
+
+static char domainname[MAXDOMAINNAMELEN];
+
+__libc_lock_define_initialized (static, domainname_lock)
+
+int
+__nss_get_default_domain (char **outdomain)
+{
+  int result = 0;
+  *outdomain = NULL;
+
+  __libc_lock_lock (domainname_lock);
+
+  if (domainname[0] != '\0')
+    {
+      if (getdomainname (domainname, MAXDOMAINNAMELEN) < 0)
+	result = errno;
+      else if (strcmp (domainname, "(none)") == 0)
+	{
+	  /* If domainname is not set, some systems will return "(none)" */
+	  domainname[0] = '\0';
+	  result = ENOENT;
+	}
+      else
+	*outdomain = domainname;
+    }
+  else
+    *outdomain = domainname;
+
+  __libc_lock_unlock (domainname_lock);
+
+  return result;
+}
diff --git a/nss/nss_compat/nisdomain.h b/nss/nss_compat/nisdomain.h
new file mode 100644
index 0000000000000000..314f3f7c069835af
--- /dev/null
+++ b/nss/nss_compat/nisdomain.h
@@ -0,0 +1,20 @@
+/* Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Set OUTDOMAIN to a pointer to the current NIS domain name, or NULL if
+   not set.  Return zero on success, an error number on failure.  */
+extern int __nss_get_default_domain (char **outdomain);
